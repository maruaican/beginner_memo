
***

### FROM句サブクエリの徹底解説と代替構文との使い分け

応用情報技術者試験の学習において、`FROM`句サブクエリは頻出のテーマです。
しかし、実務やより高度な問題に対応するためには、同様の処理を`WITH`句やウィンドウ関数など、他の構文でも実現できることを理解し、それぞれの特徴と使い分けを把握することが不可欠です。

このドキュメントでは、`FROM`句サブクエリの基本から具体的な利用パターン、そして代替構文との比較までを体系的に解説します。

## 1. FROM句サブクエリとは

`FROM`句サブクエリは、`FROM`句の中に`SELECT`文（サブクエリ）を記述することで、その実行結果を一時的な仮想テーブルとして扱うための機能です。これにより、複雑なデータ抽出や集計処理を段階的に、かつ構造的に記述することが可能になります。

この機能はデータベース管理システム（RDBMS）によって呼び名が異なり、MySQLなどでは**派生表 (derived table)**、Oracleなどでは**インラインビュー (inline view)** と呼ばれます。

### 1.1. 基本構文と最重要ルール

最大のポイントは、**サブクエリに必ず別名（エイリアス）を付けなければならない**というルールです。この別名は、メインクエリがサブクエリの結果セットを一つのテーブルとして識別するために構文上必須となります。

```sql
SELECT
  -- ...
FROM (
    -- ここにサブクエリを記述
    SELECT ...
    FROM ...
) AS 別名 -- この別名が必須！
-- JOIN句やWHERE句で「別名.列名」のように利用する
JOIN ...
WHERE ...;
```
※ `AS`キーワードは省略可能な場合が多いですが、試験対策としては省略形も頻出します。

## 2. なぜ複数の書き方が存在するのか？ - SQL構文の進化

SQLは「どのようなデータが欲しいか」を宣言する宣言型言語であり、同じ結果を得るための表現方法が複数存在します。SQLの歴史の中で、より複雑な処理を、より可読性高く、効率的に記述するための新しい構文が追加されてきました。

*   **FROM句サブクエリ**: 比較的古くからある基本的な機能。クエリの一部として一時的なテーブルを即席で作成できますが、ネストが深くなると可読性が著しく低下します。
*   **`WITH`句 (CTE: Common Table Expression)**: FROM句サブクエリの可読性の問題を解決するために導入されました。処理のステップを名前付きのブロックに分割できるため、複雑なクエリの構造が非常に分かりやすくなります。
*   **ウィンドウ関数**: `GROUP BY`のように行を集約せず、各行のデータを残したまま集計値を計算できます。これにより、従来は自己結合やサブクエリを駆使しないと実現できなかったランキングや比率計算が、シンプルに記述できるようになりました。

応用情報技術者試験の学習者としては、「なぜ複数の書き方が存在するのか」「それぞれの使い分けや特徴は何か」を理解することが、より深い知識につながります。

## 3. 主な利用パターンと代替構文の比較

ここでは代表的な利用パターンを例に、FROM句サブクエリによる実装と、他の構文による代替案を比較し、それぞれの使い分けを解説します。

### 3.1. 集計結果に対する条件指定

サブクエリ内で先に集計を行い、その結果に対してメインクエリの`WHERE`句で条件を指定するパターンです。

*   **FROM句サブクエリによる実装**
    部署ごとの平均給与を算出し、その平均給与が30万円以上の部署のみを抽出します。
    ```sql
    SELECT 部署ID, 平均給与
    FROM (
        SELECT 部署ID, AVG(給与) AS 平均給与
        FROM 社員
        GROUP BY 部署ID
    ) AS 部署別平均 -- 派生表に「部署別平均」という別名を付与
    WHERE 平均給与 >= 300000;
    ```

*   **代替案：`HAVING`句**
    このケースでは、`HAVING`句を使うのが最もシンプルで標準的な方法です。
    ```sql
    SELECT 部署ID, AVG(給与) AS 平均給与
    FROM 社員
    GROUP BY 部署ID
    HAVING AVG(給与) >= 300000; -- 集約関数に対する条件なのでHAVING句が使える
    ```

*   **使い分け**
    *   **`HAVING`句を優先**: `AVG`, `SUM`, `COUNT`など集約関数の結果に対する条件指定は、`HAVING`句が最適です。
    *   **FROM句サブクエリ**: `HAVING`句では表現しにくい、より複雑な条件（例：集計結果にランキングを付けて上位N件を抽出する）の場合に真価を発揮します。

### 3.2. 集計結果とマスターテーブルの結合

サブクエリで集計したデータに、別のマスターテーブルから関連情報（例：部署名）を付与するパターンです。

*   **FROM句サブクエリによる実装**
    各部署の平均給与と人数を算出し、部署名を付けて表示します。
    ```sql
    SELECT
      m.部署名,
      a.平均給与,
      a.人数
    FROM
      部署マスタ AS m
    JOIN (
        SELECT
          部署ID,
          AVG(給与) AS 平均給与,
          COUNT(*) AS 人数
        FROM 社員
        GROUP BY 部署ID -- サブクエリ内でもSELECT句の非集計列はGROUP BYが必要
    ) AS a ON m.部署ID = a.部署ID
    WHERE a.平均給与 > 300000;
    ```

*   **代替案：`WITH`句 (CTE)**
    `WITH`句を使うと、処理のステップが明確になり、可読性が向上します。
    ```sql
    WITH 部署別集計 AS (
      SELECT
        部署ID,
        AVG(給与) AS 平均給与,
        COUNT(*) AS 人数
      FROM 社員 GROUP BY 部署ID
    )
    SELECT
      m.部署名,
      a.平均給与,
      a.人数
    FROM 部署マスタ m
    JOIN 部署別集計 a ON m.部署ID = a.部署ID
    WHERE a.平均給与 > 300000;
    ```

*   **使い分け**
    *   **`WITH`句を推奨**: サブクエリが長くなる場合や、複数のサブクエリを組み合わせる場合は、`WITH`句を使うとクエリ全体の見通しが格段に良くなります。保守・管理のしやすさから、実務では`WITH`句が好まれます。
    *   **FROM句サブクエリ**: 処理が単純で、使い捨ての一時的なビューで十分な場合に手軽に使えます。

### 3.3. 全体の集計値を利用した比率計算

各行のデータと、テーブル全体の集計値（スカラ値）を比較して比率などを計算するパターンです。

*   **FROM句サブクエリによる実装**
    各社員の給与が、全社平均給与の何倍かを計算します。サブクエリで全体の集計値を算出し、元のテーブルと結合（直積）します。
    ```sql
    SELECT
      s.社員ID,
      s.給与,
      s.給与 / z.平均給与 AS 比率
    FROM
      社員 s,
      (SELECT AVG(給与) AS 平均給与 FROM 社員) AS z;
    ```

*   **代替案1：ウィンドウ関数**
    この用途では、ウィンドウ関数が最もエレガントかつ効率的です。
    ```sql
    SELECT
      社員ID,
      給与,
      給与 / AVG(給与) OVER() AS 比率
    FROM
      社員;
    ```

*   **代替案2：スカラーサブクエリ**
    `SELECT`句の中に、単一の値を返すサブクエリを直接記述する方法です。
    ```sql
    SELECT
      社員ID,
      給与,
      給与 / (SELECT AVG(給与) FROM 社員) AS 比率
    FROM
      社員;
    ```

*   **使い分け**
    *   **ウィンドウ関数が最適**: `GROUP BY`で行をまとめることなく、全体の集計値や部分的な集計値（パーティションごとの集計）を利用したい場合は、ウィンドウ関数が第一選択肢となります。
    *   **その他**: FROM句サブクエリ（CROSS JOIN）やスカラーサブクエリも可能ですが、パフォーマンスや可読性の面でウィンドウ関数に劣る場合があります。

### 3.4. 自己結合との組み合わせ

一つのテーブル内に階層構造がある場合（自己参照）、同じテーブル同士を結合する**自己結合（Self Join）**と組み合わせることで、クエリの意図を明確にできます。

*   **自己結合の基本**
    `社員`テーブルに、上司を示す`上司ID`列があるとします。各部下とその直属の上司の名前を一覧表示します。
    ```sql
    SELECT
      上司.社員名 AS 上司名,
      部下.社員名 AS 部下名
    FROM
      社員 AS 部下
    JOIN
      社員 AS 上司 ON 部下.上司ID = 上司.社員ID;
    ```

*   **FROM句サブクエリを組み合わせた応用**
    サブクエリで先に対象を絞り込むことで、メインの結合処理をシンプルにします。例えば、「マネージャー」職の部下とその上司の一覧を抽出します。
    ```sql
    SELECT
      上司.社員名 AS 上司名,
      部下.社員名 AS 部下名
    FROM (
        -- 先に「マネージャー」職の社員だけを抽出するサブクエリ
        SELECT 社員ID, 社員名, 上司ID
        FROM 社員
        WHERE 役職 = 'マネージャー'
    ) AS 部下 -- この結果セットを「部下」テーブルとして扱う
    JOIN
      社員 AS 上司 ON 部下.上司ID = 上司.社員ID;
    ```
    このように、FROM句サブクエリで対象を事前にフィルタリングすることで、クエリの意図が「まずマネージャーを抽出し、その上司を紐付ける」ことであると明確になります。

### 3.5. ランキングなど複雑な条件での利用

分析関数（`RANK()`など）が使えない環境や、試験問題の意図として、サブクエリを用いてランキングを実装する場合があります。

*   **FROM句サブクエリによる実装**
    給与が高い順に上位3名の社員を抽出します。内側の相関サブクエリで各社員の順位を計算し、外側のクエリで絞り込みます。
    ```sql
    SELECT
      社員ID,
      給与,
      順位
    FROM (
        SELECT
            社員1.社員ID,
            社員1.給与,
            (SELECT COUNT(*) + 1
             FROM 社員 AS 社員2
             WHERE 社員2.給与 > 社員1.給与) AS 順位
        FROM
          社員 AS 社員1
    ) AS ランキング -- 派生表に「ランキング」という別名を付与
    WHERE
      順位 <= 3;
    ```
    *   **解説**: 内側の相関サブクエリは、外側の`社員1`の各行に対して、「自分より給与が高い社員の数」を数えます。その数に`+1`することで順位を算出しています。

## 4. どの構文を選ぶべきか？ - 選択の指針まとめ

| 状況 | 最適な選択肢 | 理由 |
| :--- | :--- | :--- |
| **集約関数の結果で絞り込みたい** | **`HAVING`句** | 最もシンプルで意図が明確。 |
| **複雑なクエリを段階的に構築したい** | **`WITH`句 (CTE)** | 可読性・保守性が最も高い。長いクエリやネストを避けられる。 |
| **集約せずに行ごとの集計値を使いたい**<br>（ランキング、比率、移動平均など） | **ウィンドウ関数** | 簡潔な記述で、パフォーマンスも良い場合が多い。 |
| **上記以外で、一時的なビューが欲しい** | **FROM句サブクエリ** | 手軽に使えるが、多用すると可読性が下がるため注意が必要。 |

## 5. 注意点

*   **別名の付け忘れ**: FROM句サブクエリで最も多い構文エラーの原因です。サブクエリには必ず別名を付けましょう。
*   **スコープの誤認**: メインクエリ（外側の`SELECT`や`WHERE`句）からは、サブクエリ（派生表）の`SELECT`句で定義された列しか参照できません。サブクエリの元テーブルの列を直接参照することはできません。