はい、承知いたしました。いただいた資料を体系的に整理し、重複を排除しつつ、すべての情報を盛り込みます。要約はせず、元の情報を明確な構造で提示します。また、具体的な命令例（MOV）と「主語・述語・目的語」を意識して説明します。

---

# 命令のアドレス指定方式：体系的整理

## 1. はじめに：命令とアドレス指定の全体像

CPUがプログラムを実行する際、命令は「何をするか」と「どこを対象にするか」という情報を含んでいます。この「どこを対象にするか」という部分（アドレス部）をCPUがどのように解釈して、実際にメモリにアクセスする番地（実効アドレス）を決定するか、その規則を「アドレス指定方式」と呼びます。

### 命令の構成

命令は基本的に以下の2つの部分から構成されます。

*   **命令部（オペコード）**: CPUに実行させる「操作」の種類を示します。（例: データを移動する、加算する、比較する など）
*   **アドレス部（オペランド指定）**: 命令の操作対象が「どこにあるか」または「何か」を示します。このアドレス部の値をどう解釈するかで、アドレス指定方式が決まります。

```
命令 ＝ ［命令部(opcode)］＋［アドレス部(操作対象の指定)］
```

### CPUの命令実行フロー

CPUは、プログラムカウンタ（PC）が指すメモリ上の番地から命令を読み出し、それを命令レジスタ（IR）に保持します。その後、アドレス生成器（AGU）が命令のアドレス部を、指定されたアドレス指定方式に基づいて解釈し、実際にアクセスするメモリ上の番地である「実効アドレス（EA）」を計算します。最終的にCPUはこの実効アドレスを使ってメモリにアクセスし、データの読み書きを行います。

```
[主記憶(MEM)]
   ↑(実効アドレスEA)
   │
[アドレス生成器(AGU)] ←―――――――――――――――――――――――――――――――――――――┐
   ↑                (どの方式でEAを作るかを決める)                           │
   │                                                                            │
[命令レジスタ(IR)] … 命令を保持：［命令部(opcode)］＋［アドレス部(操作対象の指定)］  │
   ↑                                                                            │
[プログラムカウンタ(PC)] ──→ 命令フェッチ（次に実行する命令の在処）                │
[各種レジスタ]（SP, ベースR, インデックスR, 汎用R …）―――――――――――――――――――――――┘

流れ：
1. CPUはプログラムカウンタ(PC)が指すメモリ上の番地から命令を読み出す。
2. 読み出した命令を命令レジスタ(IR)に保持する。
3. アドレス生成器(AGU)がIRのアドレス部を、アドレス指定方式に基づいて解釈する。
4. AGUは、その解釈結果から実際にメモリにアクセスする「実効アドレス(EA)」を計算する。
5. CPUは実効アドレス(EA)を使って主記憶(MEM)にアクセスし、データを読み書きする。
```

## 2. 基本概念と主要用語の定義

### 命令（Instruction）

*   **定義**: CPUに特定の操作を実行させるための情報単位です。
*   **構成**: 「命令部（オペコード）」と「アドレス部（オペランド指定）」から構成されます。
    *   例：`MOV R1, [0x1000]` という命令では、命令部は「MOV」、アドレス部は「[0x1000]」です。

### 命令部（Opcode）

*   **定義**: CPUに「何をするか」を指示する部分です。
*   **役割**: データ移動（MOV）、算術演算（ADD）、論理演算（AND）、比較（CMP）など、命令の種類を定めます。

### アドレス部（Operand specifier）

*   **定義**: CPUに「どこを対象にするか」または「何を対象にするか」を指示する部分です。
*   **役割**: CPUはアドレス部の解釈方法、すなわちアドレス指定方式に基づいて、実効アドレス（EA）を計算します。

### 実効アドレス（Effective Address; EA）

*   **定義**: CPUが実際にアクセスするメモリ上の番地です。
*   **役割**: アドレス生成器（AGU）によって計算され、CPUはこのEAを使ってメモリ上の特定のデータや命令に到達します。

### アドレス指定方式（Addressing Mode）の定義と由来

*   **定義**: 命令の「アドレス部をどう解釈して実効アドレス（EA）を求めるか」のルールや方式です。
*   **由来**: 各方式の英語名がその機能や特徴を直接的に表しています。
    *   "Direct Addressing" → 値を「直接」アドレスとするため「直接／絶対アドレス方式」。
    *   "Indirect Addressing" → 値を「間接的に」辿ってアドレスを得るため「間接アドレス方式」。
    *   "Relative Addressing" → 値を「基準レジスタ（PCやSP）」に対して「相対的」に加算して求めるため「相対アドレス方式」。

## 3. アドレス指定に関連する主要レジスタ

アドレス指定方式には、CPU内部にある様々なレジスタが基準として用いられます。

### 汎用レジスタ（General Purpose Register; 例: R1, R2など）

*   **場所**: CPU内部に存在します。
*   **役割**: 演算やデータ処理の途中結果、一時的なデータを保存するための箱です。
*   **性質**: 主記憶（RAM）と比較して容量は小さいですが、CPUから高速にアクセス可能です。
*   **たとえ**: 大きな倉庫（主記憶）から取り出した物を一時的に置く、作業机の上の小皿のようなものです。

### スタックポインタ（Stack Pointer; SP）

*   **場所**: CPU内部の特殊レジスタの一つです。
*   **役割**: スタック領域（主記憶の一部として確保された、データの出し入れを行う特殊な領域）の**一番上（先頭アドレス）を保持する**役割を持ちます。
*   **性質**: 「保持する」とは、数値（アドレス値）を記憶していることを意味します。例えば、スタックの一番上がメモリ番地`0x1000`であれば、SPの中身は`0x1000`となります。実際にメモリをアクセスするのは、SPの値を参照して命令を実行したときです。SPは戻り値を直接保存せず、関数の戻り先アドレスなどを置いたスタックの位置を覚えています。
*   **たとえ**: 積み上げられた皿の山（スタック）において、「いま一番上にある皿の位置を指している指差し棒」のようなものです。

### 基準レジスタ（Base Register と呼ばれる場合もある）

*   **場所**: CPU内部の特殊レジスタです。
*   **役割**: プログラムがアクセスする**基準となるメモリアドレスを保持します**。
*   **用途**: プログラムが大きいときに、**どのメモリ領域を使用するか**を切り替えるために使われます。
*   **イメージ**: 社宅の入口住所を覚えておいて、そこに部屋番号を足して実際の住所を得る、というように、ある区画の開始地点を示す役割を果たします。

### ベースレジスタ（Base Register）

*   **場所**: CPU内部の特殊レジスタです。
*   **役割**: 命令のアドレス部に書かれた「変位（オフセット）」に、**自分の中身（基準アドレス）を足して実効アドレスを生成します**。
*   **用途**: **プログラムやデータがメモリ上のどこにロードされても、ベースレジスタの値を変えるだけで動作可能**にすること（再配置可能性）を実現します。
*   **イメージ**: アパートの建物の基準位置を覚えておいて、部屋番号を足して目的の部屋を探すようなものです。

*補足*: 教科書や文脈によっては、「基準レジスタ」と「ベースレジスタ」をほぼ同義に扱う場合があります。

### インデックスレジスタ（Index Register）

*   **場所**: CPU内部の特殊レジスタです。
*   **役割**: 命令のアドレス部に書かれたアドレス（またはベースアドレス）に、**自分の中身（添字やオフセット）を足して実効アドレスを生成します**。
*   **用途**: **配列や繰り返し処理で、同じ基準アドレスに対して連続したデータを順次アクセスするとき**に非常に便利です。
*   **イメージ**: 本棚の先頭の位置を決めておいて、インデックスレジスタを+1ずつ増やして、次の本、次の本を参照するようなものです。

### 主要レジスタの比較表

| レジスタ名           | 保持する値                           | 主な用途                                     | たとえ                       |
| :------------------- | :----------------------------------- | :------------------------------------------- | :--------------------------- |
| **汎用レジスタ**     | 演算結果、一時データ                 | データの一時保存、演算の中間結果             | 作業机の上の小皿             |
| **スタックポインタ(SP)** | スタックの先頭アドレス               | スタック領域の管理（関数の呼び出し、ローカル変数など） | 積み上げられた皿の山を指す指差し棒 |
| **基準レジスタ**     | 基準となるメモリアドレス             | プログラムやデータ領域の基準を決める         | 社宅の入口住所               |
| **ベースレジスタ**   | 基準アドレス（プログラムの基底番地など） | プログラムの再配置、メモリ保護               | アパートの建物の基準位置     |
| **インデックスレジスタ** | 配列の添字（オフセット値）           | 配列やレコードの要素への順次アクセス         | 本棚の先頭から何冊目かを数える |

## 4. アドレス指定方式の種類と詳細：具体的な課題と解決策

ここでは、各アドレス指定方式について、その必要性、EAの求め方、特徴、具体的な命令例、そしてよくある誤解を詳しく見ていきます。

**前提となるメモリの中身（共通の具体例）**

```
アドレス : 内容
0x1000  : 0xAAAA   （データ）
0x2000  : 0x1000   （ポインタ：0x1000を指す）
0x4010  : 0xBBBB   （データ）
0x8008  : 0xCCCC   （データ）
```

---

### 4.1. 直接（絶対）アドレス方式 (Direct / Absolute Addressing)

*   **技術の必要性・解決する課題**: プログラム中で固定された特定のメモリ番地（例: I/Oデバイスのレジスタ、OSの特定のデータ領域など）に、**最も単純かつ迅速にアクセスしたい**場合に必要です。しかし、アドレスがプログラムに固定書きされるため、プログラムの柔軟性には欠けます（再配置が難しい）。
*   **実効アドレス（EA）の求め方**:
    *   **CPUは、命令のアドレス部の値を、そのまま実効アドレスとして使います。**
*   **特徴・用途**:
    *   アドレス部の値が、直接メモリ番地となります。
    *   最も単純なアドレス指定方式であり、固定アドレスへのアクセスに適しています。
*   **具体例**: `MOV R1, [0x1000]`
    *   **CPUは、`0x1000`をそのまま実効アドレスとして使い、メモリ`0x1000`番地からデータ`0xAAAA`を読み出し、R1レジスタへ格納します。**
*   **一問一答**:
    *   **Q1**: 命令のアドレス部の値を、そのまま実効アドレスとする方式は？
    *   **A**: **直接（絶対）アドレス方式**
        *   解説：余計な計算をせず「そのまま使う」のが特徴です。
*   **よくある誤解と正しい知識**:
    *   **誤解**: 「絶対アドレス方式」と「直接アドレス方式」は別物。
    *   **正しい知識**: **両者は同義です**。IPA試験では両方の表記が出題されます。
    *   **誤答例**: 「スタックポインタを基準に加算する」や「命令アドレスレジスタを基準に加算する」は、これは直接（絶対）方式ではありません（これらは相対方式です）。

---

### 4.2. 間接アドレス方式 (Indirect Addressing)

*   **技術の必要性・解決する課題**: ポインタ変数を扱うように、**アドレスを介して別の場所にあるデータにアクセスしたい**場合に必要です。これにより、プログラム中で直接アドレスを指定することなく、間接的に様々なメモリ位置のデータを操作できます。
*   **実効アドレス（EA）の求め方**:
    *   **CPUは、命令のアドレス部の値で指定されたメモリを1回読み出し、その読み出した値を実効アドレスとして使います。**
*   **特徴・用途**:
    *   アドレス部が直接のデータ番地ではなく、データ番地が格納されている番地を指します。
    *   ポインタ変数によるアクセスや、複数のデータ構造が同じルーチンで処理されるような場合に利用されます。
*   **具体例**: `MOV R1, [[0x2000]]`
    *   **CPUは、まずメモリ`0x2000`番地を読み出し、その中身である`0x1000`を実効アドレスとして使います。その後、メモリ`0x1000`番地からデータ`0xAAAA`を読み出し、R1レジスタへ格納します。**
*   **一問一答**:
    *   **Q2**: 命令のアドレス部で指定したメモリの内容をアドレスとする方式は？
    *   **A**: **間接アドレス方式**
        *   解説：「ポインタ参照」に似ています。
*   **よくある誤解と正しい知識**:
    *   **誤解**: 「間接アドレス方式」を「直接アドレス方式」と取り違える。
    *   **正しい知識**: 間接方式は「一度メモリを参照」という追加のステップが入ります。
    *   **誤解**: 間接は直接と同じ速さ。
    *   **正しい知識**: **間接方式はメモリ参照が1回増えるため、直接方式より遅い（重い）ことが多いです**。

---

### 4.3. 相対アドレス方式 (Relative Addressing)

*   **技術の必要性・解決する課題**: プログラムをメモリ上の**どの位置にロードしても、修正なしで動作させたい（再配置可能にしたい）**場合に必要です。特に、プログラムカウンタ（PC）を基準とすることで、プログラム内の分岐命令などで現在の命令位置からの相対的なジャンプを実現します。
*   **実効アドレス（EA）の求め方**:
    *   **CPUは、基準レジスタ（プログラムカウンタPCやスタックポインタSPなど）の値に、命令中の「変位（オフセット）」を加えて、実効アドレスを作ります。**
*   **特徴・用途**:
    *   PCからの相対的なアドレス指定は、プログラムの再配置（メモリのどこに置いても実行できること）を容易にします。
    *   SPからの相対的なアドレス指定は、スタックフレーム内のローカル変数や引数へのアクセスに用いられます。
*   **具体例（PC相対）**: PC=`0x4000`のとき、`MOV R1, [PC + 0x10]`
    *   **CPUは、PCの値`0x4000`に命令中の変位`0x10`を加えて実効アドレス`0x4010`を作り、メモリ`0x4010`番地からデータ`0xBBBB`を読み出し、R1レジスタへ格納します。**
*   **具体例（SP相対）**: SP=`0x8000`のとき、`MOV R1, [SP + 8]`
    *   **CPUは、SPの値`0x8000`に命令中の変位`8`を加えて実効アドレス`0x8008`を作り、メモリ`0x8008`番地からデータ`0xCCCC`を読み出し、R1レジスタへ格納します。**
*   **一問一答**:
    *   **Q3**: 命令アドレスレジスタ（PC）の値を基準に変位を加える方式は？
    *   **A**: **相対アドレス方式**
        *   解説：プログラム再配置が容易になります。
    *   **Q4**: SPを基準に変位を加える方式は？
    *   **A**: （出題によって）**相対アドレス方式**または**基底アドレス方式**として扱われます。
*   **よくある誤解と正しい知識**:
    *   **誤解**: 「相対アドレス方式」と「絶対アドレス方式」を混同する。
    *   **正しい知識**: 相対方式は基準レジスタからの「相対的な位置」でアドレスを決定します。絶対方式は「固定の番地」を使います。
    *   **誤解**: 「相対アドレス方式」はPC専用。
    *   **正しい知識**: PC相対が基本ですが、SPを基準にするケースも含まれます。

---

### 4.4. 基底アドレス方式 (Base Addressing)

*   **技術の必要性・解決する課題**: オペレーティングシステム（OS）が複数のプログラムをメモリ上で保護しつつ実行する**マルチプログラミング環境において、プログラムの再配置性を高め、メモリ保護を実現したい**場合に必要です。
*   **実効アドレス（EA）の求め方**:
    *   **CPUは、ベースレジスタの値に、命令中の「変位（オフセット）」を加えて、実効アドレスを作ります。**
*   **特徴・用途**:
    *   ベースレジスタにプログラムの開始アドレスを設定することで、OSがメモリ管理や保護のためにプログラムのロード位置を柔軟に変更できるようになります。
    *   仮想記憶システムにおけるアドレス変換にも関連します。
*   **具体例**: ベースレジスタ(BR)=`0x7000`のとき、`MOV R1, [BR + 0x100]`
    *   **CPUは、ベースレジスタの値`0x7000`に命令中の変位`0x100`を加えて実効アドレス`0x7100`を作り、メモリ`0x7100`番地からデータを読み出し、R1レジスタへ格納します。**
*   **一問一答**:
    *   **Q4**: ベースレジスタの値を基準に加算する方式は？
    *   **A**: **基底アドレス方式**
        *   解説：メモリ管理や保護に使われます。

---

### 4.5. 指標アドレス方式 (Index Addressing)

*   **技術の必要性・解決する課題**: **配列やレコード、構造体などの連続したデータ構造の各要素に、効率的かつ簡潔にアクセスしたい**場合に必要です。ループ処理の中でインデックス（添字）を増減させることで、自動的に次の要素にアクセスできます。
*   **実効アドレス（EA）の求め方**:
    *   **CPUは、インデックスレジスタの値に、命令のアドレス部（またはベースアドレス）に書かれた「変位」を加えて、実効アドレスを作ります。**
*   **特徴・用途**:
    *   配列の要素へのアクセス、繰り返し処理でのデータ走査に頻繁に用いられます。
    *   基底アドレスと組み合わせることで、「基底指標アドレス方式」として、テーブルの基底アドレスと配列のオフセットを同時に指定することも可能です。
*   **具体例**: インデックスレジスタ(IX)=`0x0004`、命令のアドレス部=`0x5000`のとき、`MOV R1, [IX + 0x5000]`
    *   **CPUは、インデックスレジスタの値`0x0004`に命令のアドレス部`0x5000`を加えて実効アドレス`0x5004`を作り、メモリ`0x5004`番地からデータを読み出し、R1レジスタへ格納します。**
*   **よくある誤解と正しい知識**:
    *   **誤解**: 「＋レジスタ」を全部「相対方式」と覚える。
    *   **正しい知識**: 「＋レジスタ」の中でも、PCやSPを基準にするのが「相対」、ベースレジスタを基準にするのが「基底」、インデックスレジスタを基準にするのが「指標」と、それぞれ目的が異なります。

---

### 4.6. 即値アドレス方式 (Immediate Addressing)

*   **技術の必要性・解決する課題**: **プログラム中で定数値を直接データとして使用したい**場合に必要です。この方式を使えば、メモリから定数を読み出す手間が省け、命令の実行速度を向上させることができます。
*   **実効アドレス（EA）の求め方**:
    *   **CPUは、命令のアドレス部の値を、アドレスとしてではなく**「**データそのもの**」として使います。実効アドレスの計算は行われず、メモリへのアクセスも不要です。
*   **特徴・用途**:
    *   命令中にデータそのものが埋め込まれます。
    *   定数の設定、カウンターの初期化、ビットマスクの適用など、頻繁に利用されます。
*   **具体例**: `MOV R1, #5`
    *   **CPUは、数値`5`をメモリアドレスではなくデータとして扱い、R1レジスタに`5`を直接書き込みます。この際、メモリの読み出しは行われません。**
*   **一問一答**:
    *   **Q5**: 命令のアドレス部の値を「アドレス」ではなく「データ」として扱う方式は？
    *   **A**: **即値アドレス方式**
        *   解説：例：`MOV AX, 5` の「5」のように、データそのものです。
*   **よくある誤解と正しい知識**:
    *   **誤解**: 「即値は“即席のアドレス”」。
    *   **正しい知識**: **即値は“データそのもの”**であり、メモリ番地ではありません。即値はメモリ参照が不要なため、非常に高速に処理できるという性能上の特徴があります。

---

## 5. アドレス指定方式の体系と試験対策

### 5.1. 分類図

```
アドレス指定方式
 ├─ 直接（絶対）…… [アドレス部の値] を そのままEAに → MEM
 ├─ 間接 ……………… [アドレス部の値] が指すMEMを読んだ中身をEAに → MEM
 ├─ 相対（PC相対/SP相対）… [基準R(PC,SP)] + 変位 → EA → MEM
 ├─ 基底（ベース）……… [ベースR] + 変位 → EA → MEM
 ├─ 指標（インデックス）… [インデックスR] + 変位（+ベース） → EA → MEM
 └─ 即値 ………………… [アドレス部の値] = データそのもの（MEMアクセス不要）
```

### 5.2. アドレス指定方式の比較表

| 方式（和名/英名）         | 実効アドレスの求め方（主語・述語・目的語）                           | 代表的な基準  | 特徴・用途                                 |
| :----------------------- | :------------------------------------------------------------------- | :------------ | :----------------------------------------- |
| **直接（絶対, Direct）**  | **CPUは、アドレス部の値を、そのまま実効アドレスとして使う。**        | なし          | 固定アドレスを直接指定。最も単純。         |
| **間接（Indirect）**     | **CPUは、アドレス部の値で指すメモリを1回読み、その読み出した値を実効アドレスとして使う。** | 主記憶        | ポインタ参照。柔軟なアクセス。             |
| **相対（Relative）**     | **CPUは、基準レジスタ（PCやSP）の値に、命令中の変位を加えて、実効アドレスを作る。** | PC / SP       | プログラムの再配置が容易。分岐命令に利用。 |
| **基底（Base）**         | **CPUは、ベースレジスタの値に、命令中の変位を加えて、実効アドレスを作る。** | ベースR       | OSによるメモリ管理・保護、プログラム再配置。 |
| **指標（Index）**        | **CPUは、インデックスレジスタの値に、命令中の変位（＋任意のベース）を加えて、実効アドレスを作る。** | インデックスR | 配列やレコードの要素への効率的アクセス。   |
| **即値（Immediate）**    | **CPUは、アドレス部の値を、アドレスではなくデータとして使う。**      | なし          | 定数の埋め込み。高速なデータ設定。         |

### 5.3. 試験の着眼点（頻出領域と解答に必要な知識）

**（1）頻出の見分けポイント**

*   「**そのまま使う**」＝ **直接（＝絶対）方式**
*   「**メモリを一度読んで、その中身をアドレスとして使う**」＝ **間接方式**
*   「**レジスタの値＋変位**」＝ **相対／基底／指標**
    *   **PC＋変位** → **相対方式**
    *   **SP＋変位** → 出題によって**相対（SP相対）**または**基底**のどちらかとして扱われることがある（文脈に注意）。

**（2）試験作成者が狙う誤解**

*   **試験作成者は、受験者が「PC相対＝相対、SP相対＝相対（or基底）」の線引きを曖昧にする誤解を狙ってきます。**
*   **試験作成者は、受験者が「間接＝直接」と取り違える誤解を狙ってきます。**
*   **試験作成者は、受験者が「即値＝実効アドレス」と誤解する（データそのもの）点を狙ってきます。**

**（3）受験者が押さえるべき知識**

*   **「そのまま使う」** → **絶対（直接）**
*   **「一度メモリを参照」** → **間接**
*   **「＋レジスタ」** → **相対／基底／指標**

## 6. まとめ

CPUは、命令の「アドレス部」を、指定されたアドレス指定方式に基づいて解釈し、実際にメモリにアクセスするための「実効アドレス」を計算します。この方式によって、プログラムは様々な方法でメモリ上のデータや命令にアクセスできます。

具体的には、アドレス部の値を**そのまま実効アドレスとする**のが**直接（絶対）方式**です。これに対し、アドレス部の値が指すメモリを**一度参照し、その内容を実効アドレスとする**のが**間接方式**です。また、**レジスタの値に変位を加える**方式には、PCやSPを基準とする**相対方式**、ベースレジスタを基準とする**基底方式**、インデックスレジスタを基準とする**指標方式**があります。最後に、アドレス部の値をアドレスではなく**データそのものとして扱う**のが**即値アドレス方式**です。

それぞれの方式は、プログラムの再配置性、配列へのアクセス、定数の利用など、特定の課題を解決するために考案され、現代のコンピュータアーキテクチャにおいて不可欠な要素となっています。