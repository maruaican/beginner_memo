はい、承知いたしました。ご提示の文章から重複している内容を統合し、不要な記述を削除した上で、論理的な順序で体系的に整理し、マークダウン形式で出力します。

---

# SQLにおけるGROUP BY句と集約関数の使い方

`GROUP BY`句と集約関数は、SQLでデータを集計・分析する上で密接に関連しており、組み合わせて使用することで詳細なデータ分析が可能になります。

*   **GROUP BY句**: データを特定の列（属性）の値に基づいてグループ化します。
*   **集約関数**: グループ化されたデータに対して、合計(`SUM`)、平均(`AVG`)、最大(`MAX`)、最小(`MIN`)、件数(`COUNT`)などの計算を行います。

基本的な流れは、`GROUP BY`句でデータをグループ分けし、集約関数で各グループの特性値を求めるというものです。

## SQL事例集

### 従業員テーブルでの集計

**テーブル定義 (例):** `従業員` (従業員ID, 氏名, 部署ID, 給与, 入社年月日)

#### 部署ごとの平均給与

```sql
SELECT
    部署ID,
    AVG(給与) AS 平均給与
FROM
    従業員
GROUP BY
    部署ID;
```
*   **解説**: `部署ID`でグループ化し、各部署の給与の平均を`AVG()`関数で計算しています。

#### 部署ごとの従業員数

```sql
SELECT
    部署ID,
    COUNT(*) AS 従業員数
FROM
    従業員
GROUP BY
    部署ID;
```
*   **解説**: `部署ID`でグループ化し、各部署の従業員数を`COUNT(*)`関数で数えています。`COUNT(*)`は各グループの行数をカウントします。

#### 部署ごとの最高給与と最低給与

```sql
SELECT
    部署ID,
    MAX(給与) AS 最高給与,
    MIN(給与) AS 最低給与
FROM
    従業員
GROUP BY
    部署ID;
```*   **解説**: `部署ID`でグループ化し、各部署の最高給与を`MAX()`、最低給与を`MIN()`関数で取得しています。

#### 部署ごとの合計給与と平均年齢

```sql
SELECT
    部署ID,
    SUM(給与) AS 合計給与,
    AVG(
        CAST(strftime('%Y.%m%d', 'now') - strftime('%Y.%m%d', 入社年月日) AS INT)
    ) AS 平均年齢 --簡易的な計算です。
FROM
    従業員
GROUP BY
    部署ID;
```
*   **解説**: 部署ごとにグループ化し、`SUM(給与)`で合計給与を、入社年月日と現在の日付の差から簡易的な平均年齢を算出しています。（**注意**: これは簡易的な年齢計算です。より正確な計算には、データベースシステム固有の日付/時刻関数を使用する必要があります。）

### 複数テーブルを結合した集計

**テーブル定義 (例):**
*   `従業員` (従業員ID, 氏名, 部署ID, ...)
*   `部署` (部署ID, 部署名)

#### 部署名ごとの従業員数

```sql
SELECT
    部署.部署名,
    COUNT(従業員.従業員ID) AS 従業員数
FROM
    従業員
INNER JOIN
    部署 ON 従業員.部署ID = 部署.部署ID
GROUP BY
    部署.部署ID, 部署.部署名;
```
*   **解説**: `部署`テーブルと`従業員`テーブルを結合し、部署ごとに従業員数をカウントしています。`GROUP BY`句には、`SELECT`句で選択する非集計列（この場合は`部署.部署名`）をすべて含める必要があります。

### 商品テーブルでの集計

**テーブル定義 (例):** `商品` (商品ID, 商品名, カテゴリID, 価格, 販売日)

#### カテゴリごとの売上合計

```sql
SELECT
    カテゴリID,
    SUM(価格) AS 売上合計
FROM
    商品
GROUP BY
    カテゴリID;
```
*   **解説**: `カテゴリID`でグループ化し、各カテゴリの売上合計を`SUM(価格)`で計算します。

#### カテゴリごとの商品数

```sql
SELECT
    カテゴリID,
    COUNT(*) AS 商品数
FROM
    商品
GROUP BY
    カテゴリID;
```
*   **解説**: `カテゴリID`でグループ化し、各カテゴリの商品数を`COUNT(*)`で数えます。

#### 月別の売上合計

```sql
SELECT
    strftime('%Y-%m', 販売日) AS 販売年月,
    SUM(価格) AS 売上合計
FROM
    商品
GROUP BY
    販売年月;
```
*   **解説**: `販売日`を`strftime('%Y-%m', 販売日)`で年月の形式に変換し、その年月でグループ化して各月の売上合計を計算します。

#### カテゴリ別、月別の売上合計

```sql
SELECT
    カテゴリID,
    strftime('%Y-%m', 販売日) AS 販売年月,
    SUM(価格) AS 売上合計
FROM
    商品
GROUP BY
    カテゴリID, 販売年月;
```
*   **解説**: `カテゴリID`と`販売年月`の2つの列でグループ化し、それぞれの組み合わせに対して売上合計を算出します。

## HAVING句：グループ化後の結果を絞り込む

`HAVING`句は、`GROUP BY`でグループ化した結果に対して、さらに条件を絞り込むために使用します。集約関数の結果を条件として指定できるのが特徴です。

#### 平均給与が500万円以上の部署

```sql
SELECT
    部署ID,
    AVG(給与) AS 平均給与
FROM
    従業員
GROUP BY
    部署ID
HAVING
    AVG(給与) >= 5000000;
```
*   **解説**: `部署ID`でグループ化して平均給与を計算した後、`HAVING`句で平均給与が500万円以上の部署のみに絞り込んでいます。

#### 従業員数が10人を超える部署

```sql
SELECT
    部署ID,
    COUNT(*) AS 従業員数
FROM
    従業員
GROUP BY
    部署ID
HAVING
    COUNT(*) > 10;
```
*   **解説**: `部署ID`でグループ化して各部署の従業員数を算出し、`HAVING`句を使って従業員数が10人を超える部署に限定しています。

## GROUP BY句の重要ルールと注意点

### SELECT句とGROUP BY句の関係

**原則として、`SELECT`句に集約関数を使わない列がある場合、その列は必ず`GROUP BY`句で指定する必要があります。** これを守らないと、多くのデータベースシステムでエラーが発生します。

*   **理由**: 集計の整合性を保つためです。`GROUP BY`句は指定された列の値が同じ行を1つのグループにまとめます。もし`SELECT`句に集約されていない列があり、それを`GROUP BY`句で指定しないと、グループ内の複数行のうちどの行の値を表示すればよいかデータベースが判断できません。

#### 例：従業員テーブル

| 従業員ID | 氏名 | 部署ID | 給与 |
| :--- | :--- | :--- | :--- |
| 1 | 山田 | 10 | 5000000 |
| 2 | 田中 | 10 | 6000000 |
| 3 | 佐藤 | 20 | 4500000 |
| 4 | 鈴木 | 20 | 5500000 |

*   **エラーになる例**: `GROUP BY`句にない非集計列 `氏名` を`SELECT`句に含んでいるため、エラーになります。
    ```sql
    SELECT
        部署ID,
        氏名,       -- 集約関数を使っていない
        AVG(給与) AS 平均給与
    FROM
        従業員
    GROUP BY
        部署ID;
    ```
*   **正しい例**: `SELECT`句にあるのはグループ化のキー(`部署ID`)と集約関数の結果だけです。
    ```sql
    SELECT
        部署ID,
        AVG(給与) AS 平均給与
    FROM
        従業員
    GROUP BY
        部署ID;
    ```

*   **例外**: 古いバージョンのMySQLなど一部のデータベースシステムでは、このルールが緩くエラーにならない場合があります。しかし、これはSQLの標準的な動作ではなく、結果が予測不可能になる可能性があるため避けるべきです。（現在のMySQLでは`ONLY_FULL_GROUP_BY`というSQLモードがデフォルトで有効になっており、標準的な動作としてエラーになります。）

### WHERE句とHAVING句の使い分け

*   **WHERE句**: `GROUP BY`でグループ化される**前**の、個々の行に対してフィルタリングを行います。
*   **HAVING句**: `GROUP BY`でグループ化された**後**の、グループに対してフィルタリングを行います。

```sql
-- 給与が400万円以上の従業員に限定し、
-- さらにその中で平均給与が550万円以上の部署のみ表示
SELECT
    部署ID,
    AVG(給与) AS 平均給与
FROM
    従業員
WHERE
    給与 >= 4000000  -- 個々の行に対する条件 (GROUP BYの前)
GROUP BY
    部署ID
HAVING
    AVG(給与) >= 5500000; -- グループに対する条件 (GROUP BYの後)
```

### その他の注意点

*   **`GROUP BY`と`ORDER BY`**: `GROUP BY`はデータをグループ化するだけで、結果の順序を保証しません。結果を特定の順序で並べ替えたい場合は、必ず`ORDER BY`句を明示的に使用してください。
*   **集約関数と`NULL`値**: `COUNT(*)`を除くほとんどの集約関数（`SUM`, `AVG`, `COUNT(列名)`など）は、計算の対象から`NULL`値を無視します。この挙動を意図しない場合、注意が必要です。
*   **`DISTINCT`と`GROUP BY`**: `DISTINCT`は重複する行を排除するのに対し、`GROUP BY`は指定列でグループ化し集約関数を適用できます。単純にユニークな値のリストが欲しい場合は、`DISTINCT`の方が高速なことがあります。
*   **データ型**: 集約関数を使用する際は、対象列のデータ型に注意が必要です。例えば、文字列型の列に`SUM`や`AVG`を使用するとエラーになります。
*   **パフォーマンス**: 大規模なデータセットに対して`GROUP BY`を使用する場合、グループ化のキーとなる列にインデックスが設定されていないと、クエリが非常に遅くなる可能性があります。

## 応用的なテクニック

### CASE式との組み合わせ

`CASE`式を集約関数と組み合わせることで、複雑な条件に基づいた集計が可能です。

*   **部署ごとに、給与が500万以上の従業員とそれ未満の従業員の数をそれぞれカウント**
    ```sql
    SELECT
        部署ID,
        COUNT(CASE WHEN 給与 >= 5000000 THEN 1 END) AS 高給与従業員数,
        COUNT(CASE WHEN 給与 < 5000000 THEN 1 END) AS 低給与従業員数
    FROM
        従業員
    GROUP BY
        部署ID;
    ```

### サブクエリやウィンドウ関数の活用

「部署ごとの平均給与」と「その部署の代表者1名の氏名」を同時に表示したい場合など、`GROUP BY`句の制約を回避して柔軟な集計を行いたい場合は、サブクエリやウィンドウ関数が有効です。

*   **サブクエリを使用する例**
    ```sql
    SELECT
        e.部署ID,
        (SELECT 氏名 FROM 従業員 WHERE 部署ID = e.部署ID LIMIT 1) AS 代表氏名,
        AVG(e.給与) AS 平均給与
    FROM
        従業員 e
    GROUP BY
        e.部署ID;
    ```

*   **ウィンドウ関数を使用する例 (より高度)**
    ```sql
    SELECT DISTINCT
        部署ID,
        FIRST_VALUE(氏名) OVER (PARTITION BY 部署ID) AS 代表氏名,
        AVG(給与) OVER (PARTITION BY 部署ID) AS 平均給与
    FROM
        従業員;
    ```
    *   **解説**: ウィンドウ関数は`GROUP BY`と異なり、元の行を集約せず、各行に対してグループ内での集計結果を付与できる強力な機能です。