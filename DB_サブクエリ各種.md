
---

# サブクエリ 詳細解説

## 1. サブクエリの概要

### 1.1. 基本定義
サブクエリとは、SQL文の中に**入れ子（ネスト）になったSELECT文**のことです。内側のSELECT文（サブクエリ）が先に実行され、その結果を外側のSQL文（親クエリ）に渡すことで、複雑な条件指定やデータ抽出を実現します。

サブクエリが返す結果の形式は、単一の値、複数行の単一列、または複数行の複数列など様々です。

### 1.2. サブクエリの分類
サブクエリは、いくつかの観点から分類することができます。

*   **使用する句による分類**
    *   **WHERE句サブクエリ**: 条件式の中で使用する。
    *   **FROM句サブクエリ**: 一時的なテーブル（派生表）として使用する。
    *   **SELECT句サブクエリ**: 取得する列の一つとして使用する。
*   **結果の行数・列数による分類**
    *   **スカラサブクエリ**: 1行1列の単一の値を返す。
    *   **行サブクエリ**: 複数列を持つ単一の行を返す。
    *   **表サブクエリ**: 複数行・複数列を返す。
*   **相関の有無による分類**
    *   **非相関サブクエリ**: 外側のクエリとは独立して単独で実行できる。サブクエリは一度だけ実行される。
    *   **相関サブクエリ**: 外側のクエリが処理している行の値を参照する。外側のクエリの行ごとにサブクエリが繰り返し実行される。

---

## 2. WHERE句サブクエリ 行を絞り込む

WHERE句でサブクエリを使用することで、別の問い合わせ結果を条件として**行**を絞り込むことができます。最も頻繁に使用される形式です。

### 2.1. 比較演算子との組み合わせ（単一行サブクエリ）
サブクエリが単一の値（スカラ値）を返す場合に、`=`, `>`, `<` などの比較演算子と組み合わせて使用します。

*   **目的**: 特定の値（例：最大値、平均値）と比較して行を抽出する。
*   **特徴**: サブクエリは**必ず1行1列**の結果を返さなければなりません。複数行を返すとエラーになります。
*   **SQL例**: 最も高い給与の社員を抽出する
    ```sql
    SELECT 社員名, 給与
    FROM 社員
    WHERE 給与 = (SELECT MAX(給与) FROM 社員);
    ```

### 2.2. IN / NOT IN / ANY / ALL との組み合わせ（複数行サブクエリ）
サブクエリが複数行のリストを返す場合に使用し、複数の候補値との集合比較を実現します。

*   **目的**: ある集合に含まれる（または含まれない）行を抽出する。
了解しました 👍
応用情報技術者試験で出題されやすい「販売業モデル」に基づいて、シンプルなサンプル表を作り、**IN / NOT IN / ANY / ALL（複数行サブクエリ）** の動作を実際に確認できるように整理します。

---

# １－１サンプル

```
顧客（customer）
+---------+--------+
| 顧客ID  | 顧客名 |
+---------+--------+
| C001    | 佐藤   |
| C002    | 鈴木   |
| C003    | 高橋   |
| C004    | 田中   |
+---------+--------+

注文（orders）
+---------+---------+--------+
| 注文番号| 顧客ID  | 金額   |
+---------+---------+--------+
| O001    | C001    | 5000   |
| O002    | C002    | 8000   |
| O003    | C003    | 12000  |
+---------+---------+--------+
```
※定義（IPA準拠）
IN：複数行サブクエリの結果に一致するかどうかを判定。
NOT IN：一致しない場合を判定。
ANY：複数行サブクエリのいずれかと比較して条件を満たす。
ALL：複数行サブクエリのすべてと比較して条件を満たす。

# １－２　SQL例と結果

### （１）IN （WHERE句複数サブクエリ）
「注文が存在する顧客をすべて抽出」
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID IN (SELECT 顧客ID FROM 注文);
```
※顧客表（FROM）を（注文表に**存在する**顧客ID）にある顧客IDで絞り込む（WHERE）
**結果**
```
佐藤
鈴木
高橋
```
（田中C004は注文なし → 出力されない）
---
### （２）NOT IN （WHERE句複数サブクエリ）
「注文が**存在しない**顧客を抽出」

```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID NOT IN (SELECT 顧客ID FROM 注文);
```
※顧客表（FROM）を（注文表に**存在しない**顧客ID）にある顧客IDで絞り込む（WHERE）

**結果**
```
田中
```
---
### （３）ANY （WHERE句複数サブクエリ）
「注文金額が 1万円を超える顧客をすべて抽出」
（ANYは「いずれか」と比較する）
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID = ANY (
    SELECT 顧客ID FROM 注文 WHERE 金額 > 10000
);
```
**結果**
```
高橋
```
（注文O003：12000 > 10000）
---
### （４）ALL （WHERE句複数サブクエリ）
「すべての注文金額が1万円以上の顧客をすべて抽出」
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID = ALL (
    SELECT 顧客ID FROM 注文 WHERE 金額 >= 10000
);
```
**結果**
```
高橋
```
（C003高橋の注文だけがすべて1万円以上）
---
# １－３　試験の着眼点

* **IN／NOT IN** は「集合との一致／不一致」
* **ANY／ALL** は「比較演算子と組み合わせて使う」

  * `> ANY` = 最小値より大きいか
  * `< ALL` = 最大値より小さいか
* 出題者は「`ANY` と `ALL` を混同させる」パターンをよく狙う。

---

# １－４　比較表 （WHERE句複数サブクエリ）

| 句      | 意味             | 例の結果     |
| ------ | -------------- | -------- |
| IN     | 集合のいずれかと一致     | 佐藤・鈴木・高橋 |
| NOT IN | 集合のどれとも一致しない   | 田中       |
| ANY    | 集合のいずれかとの比較に一致 | 高橋       |
| ALL    | 集合のすべてとの比較に一致  | 高橋       |

---

# １－５　代表例（正答例・誤答例）

* **正答例**：`WHERE 金額 > ANY (SELECT 金額 FROM 注文)`
* **誤答例**：`WHERE 金額 > ALL (SELECT 金額 FROM 注文)`（ANYとALLを取り違える）

---

# １－６　よくある誤解と正しい知識

* 誤解：`ANY` は `IN` と同じ意味。
* 正解：`ANY` は「比較演算子付き」で動作する。`= ANY` なら `IN` と等価だが、`> ANY` なら「最小値より大きい」になる。

---

# １－７　一問一答

**Q1** INを使うときの典型的な使い方は？
→ **集合のいずれかと一致**。`= ANY` と等価。

**Q2** NOT INの注意点は？
→ サブクエリの結果に`NULL`があると全体が成立しなくなる。

**Q3** `> ANY (集合)` の意味は？
→ 集合の最小値より大きければ成立。

**Q4** `< ALL (集合)` の意味は？
→ 集合の最大値より小さければ成立。

**Q5** 試験で狙われやすい誤解は？
→ ANYとALLを「IN/NOT IN」と混同させること。

---

# １－８　要約（3行以内）

* **IN／NOT IN** は「集合の一致／不一致」。
* **ANY／ALL** は「比較演算子＋集合」で条件を判定。
* 出題者はANYとALLの取り違えを狙う。

---

👉 次のステップとして、「`> ANY`」「< ALL\`」などをもう少し具体的な数値例で表に整理すると、さらに理解が深まります。作りましょうか？


#### 各演算子の詳細と注意点

| 演算子 | 判定内容 | 思考パターン / 備考 |
| :--- | :--- | :--- |
| **IN** | 集合に含まれるか | `=ANY` と同義。 |
| **NOT IN** | 集合に含まれないか | **注意**: サブクエリの結果に **NULL が含まれると、比較結果が UNKNOWN となり、全ての行が対象外**になる。 |
| **=ANY** | 集合のどれか1つと等しいか | `IN` と同義。OR的な判定。 |
| **>ANY** | 集合のいずれかの値より大きいか | 「集合の中の**最小値**より大きい」ことと同じ。 |
| **<ANY** | 集合のいずれかの値より小さいか | 「集合の中の**最大値**より小さい」ことと同じ。 |
| **=ALL** | 集合の全てと等しいか | 全ての候補が同じ値でない限り成立しないため、実用性は低い。 |
| **>ALL** | 集合の全てより大きいか | 「集合の中の**最大値**より大きい」ことと同じ。 |
| **<ALL** | 集合の全てより小さいか | 「集合の中の**最小値**より小さい」ことと同じ。 |

#### よくある質問と誤解（Q&A）
*   **Q1. `IN` と等価な表現はどれか。**
    *   **A1.** `=ANY`。集合の中のいずれか一つに一致すればよいため。
*   **Q2. 「給与が部署10の全員より高い社員」を求めるにはどの演算子か。**
    *   **A2.** `>ALL`。全員との比較はAND条件に相当するため。
*   **Q3. 「給与が部署10の誰か一人より高い社員」を求めるにはどの演算子か。**
    *   **A3.** `>ANY`。一人でも超えればよいOR条件に相当するため。
*   **Q4. `NOT IN` のサブクエリに `NULL` が含まれるとどうなるか。**
    *   **A4.** 全ての比較が `UNKNOWN` となり、結果は0件になる。
*   **Q5. 「すべての候補値に等しい」を表すのはどの演算子か。**
    *   **A5.** `=ALL`。ただし、実用上ほとんど使われない。










### 2.3. EXISTS / NOT EXISTS との組み合わせ
サブクエリが1行以上の結果を返すかどうか（存在するかどうか）を判定します。多くの場合、相関サブクエリと組み合わせて使用されます。

*   **目的**: 関連するデータが存在するかどうかに基づいて行を抽出する。
*   **特徴**: サブクエリが返す実際の値は無視され、行の有無のみが評価されます。詳細は「4. 相関サブクエリ」の章で解説します。

### 2.4. WHERE句サブクエリの注意点と試験対策

#### 代表的な誤答・凡ミス
1.  **スカラサブクエリが複数行を返してエラー**
    *   **原因**: `=` などの比較演算子を使っているのに、サブクエリが複数行を返してしまうケース。
    *   **対策**: サブクエリが必ず1行1列になるよう、`MAX`, `MIN`, `AVG` などの集約関数を使うか、`IN` 演算子に切り替える。
2.  **`NOT IN` でのNULLの扱いによる意図しない結果**
    *   **原因**: `NOT IN` のサブクエリ結果に `NULL` が含まれていると、比較が `UNKNOWN` となり、意図せず結果が0件になる。
    *   **対策**: `NOT EXISTS` を使用する方が安全。
3.  **EXISTS と IN の意味の違いの混同**
    *   **原因**: `IN` は「値の集合」に含まれるかを比較するのに対し、`EXISTS` はサブクエリの「行の存在」そのものを問う。この違いを理解せず、使い分けを誤る。
4.  **相関サブクエリと非相関サブクエリの混同**
    *   **原因**: 外側の行ごとにサブクエリが実行される相関サブクエリの構造を理解せず、非効率なクエリを作成してしまう。

#### 性能上の留意点
*   **相関サブクエリ**: 外側の各行ごとにサブクエリが実行されるため、行数が増えると性能が低下しやすい。インデックスの活用が重要。
*   **非相関サブクエリ**: サブクエリは一度だけ実行され、その結果がキャッシュされることが多い。ただし、巨大な結果セットを生成する場合は注意が必要。
*   **EXISTS**: 条件を満たす最初の行が見つかった時点で評価が終了する（早期終了）ため、`IN` よりも高速になることがある。
*   **JOINへの書き換え**: サブクエリは `JOIN` を使って書き換えられる場合があり、オプティマイザがインデックスを効率的に利用できるため、性能が向上することがある。

---




## 3. FROM句サブクエリ（派生表 / インラインビュー）

FROM句にサブクエリを記述することで、その実行結果を一時的なテーブル（ビュー）として扱うことができます。この一時テーブルは**派生表 (derived table)** や **インラインビュー (inline view)** と呼ばれます。
*   **用語**: MySQLなどでは「派生表」、Oracleなどでは「インラインビュー」と呼ばれることが多い。

### 3.1. 構文とルール
*   **目的**: `GROUP BY` などで集計・加工した結果を、さらに別のテーブルのように扱って結合や絞り込みを行う。
*   **重要ルール**: FROM句のサブクエリには**必ず別名（エイリアス）を付けなければなりません**。
    ```sql
    SELECT ...
    FROM (
        SELECT ... 
        FROM ...
    ) AS 別名 -- この別名が必須
    WHERE ...;
    ```
    ※ `AS` キーワードは省略可能な場合が多いですが、試験などでは省略形がよく見られます。

### 3.2. 代表的なパターン

#### 3.2.1. 集計結果のフィルタリング
`GROUP BY` で集計した結果に対して、`WHERE`句でさらに条件を指定したい場合に使用します。

*   **SQL例**: 部署ごとの平均給与を算出し、その平均給与が30万円以上の部署のみを抽出する
    ```sql
    SELECT 部署ID, 平均給与
    FROM (
           SELECT 部署ID, AVG(給与) AS 平均給与
           FROM 社員
           GROUP BY 部署ID
         ) AS 部署別平均
    WHERE 平均給与 >= 300000;
    ```
*   **HAVING句との使い分け**:
    *   **単純な集計条件**: 上記の例は `HAVING AVG(給与) >= 300000` でも実現可能で、その方が簡潔です。
    *   **FROM句サブクエリが有効なケース**:
        1.  **集計結果を他テーブルと結合したい時**: 集計結果にマスタテーブルから部署名を付与するなど。
        2.  **集計結果を複数回利用したい時**: 集計値を元にさらに別の計算（例：全体平均との比率）を行うなど。
        3.  **複雑な条件を指定したい時**: `HAVING`句では表現しにくい複雑な条件を `WHERE`句で指定したい場合。

*   **SQL例（応用）**: 集計結果を部署マスタと結合する
    ```sql
    SELECT m.部署名, a.平均給与, a.人数
    FROM 部署マスタ m
    JOIN (
      SELECT 部署ID, AVG(給与) AS 平均給与, COUNT(*) AS 人数
      FROM 社員
      GROUP BY 部署ID
    ) AS a ON m.部署ID = a.部署ID
    WHERE a.平均給与 > 300000;
    ```

#### 3.2.2. 集約関数の組み合わせ（比率計算）
全体の集計値（スカラ値）を返すサブクエリと元のテーブルを結合（直積）することで、各行のデータと全体集計値を比較できます。

*   **SQL例**: 各社員の給与と、全社平均給与との比率を計算する
    ```sql
    SELECT 社員ID, 給与, 給与 / 全体.平均給与 AS 比率
    FROM 社員,
         (SELECT AVG(給与) AS 平均給与 FROM 社員) AS 全体;
    ```

#### 3.2.3. ランキング処理
分析関数（`RANK()`, `ROW_NUMBER()`など）が使えない環境や、試験問題などで、サブクエリを用いてランキングを実装する場合があります。これは相関サブクエリの応用例です。

*   **SQL例**: 給与が高い順に上位3名の社員を抽出する
    ```sql
    -- FROM句の中で、相関サブクエリを使って各社員に順位を付けている
    SELECT 社員ID, 給与, 順位
    FROM (
        SELECT 
            社員1.社員ID, 
            社員1.給与,
            (SELECT COUNT(*)
             FROM 社員 社員2
             WHERE 社員2.給与 > 社員1.給与) + 1 AS 順位
        FROM 社員 AS 社員1
    ) AS サブクエリ
    WHERE 順位 <= 3;
    ```
    *   **解説**: 内側の相関サブクエリ `(SELECT COUNT(*)...)` は、外側の `社員1` の各行に対して、「自分より給与が高い社員の数」を数えています。その数に `+1` することで順位を算出しています。

#### 3.2.4. 自己結合の簡素化（自己参照）
一つのテーブル内に階層構造（例：社員と上司）がある場合、**自己結合（Self Join）**が用いられます。FROM句サブクエリで対象を明確にすることも可能です。

*   **データモデル**: `社員`テーブルに`社員ID`と、その社員の上司を示す`上司ID`（これは同じ`社員`テーブルの`社員ID`を参照する）列が存在する**自己参照**構造。
*   **SQL例**: 各部下とその直属の上司の名前を一覧表示する
    ```sql
    SELECT 上司.社員名 AS 上司名, 部下.社員名 AS 部下名
    FROM 社員 AS 部下
    JOIN 社員 AS 上司 ON 部下.上司ID = 上司.社員ID;
    ```
    *   **解説**: 同じ`社員`テーブルを「部下」と「上司」という2つの異なる役割で扱っています。`部下`テーブルの`上司ID`と、`上司`テーブルの`社員ID`を結合することで、上司と部下の関係を特定しています。

### 3.3. FROM句サブクエリの注意点
*   **別名の付け忘れ**: 最も多い構文エラーの原因です。FROM句のサブクエリには必ず別名を付けましょう。
*   **スコープの誤認**: 外側の `SELECT` や `WHERE` では、サブクエリ（派生表）で定義された列しか参照できません。

---

## 4. SELECT句サブクエリ（スカラサブクエリ）

SELECT句の中にサブクエリを記述することで、列の一つとして問い合わせ結果を表示できます。

### 4.1. 構文とルール
*   **目的**: メインのクエリで取得する各行に関連する追加情報を、別の列として取得する。
*   **重要ルール**: SELECT句のサブクエリは、外側のクエリの行ごとに実行され、**必ず1行1列の単一の値（スカラ値）**を返さなければなりません。

### 4.2. 代表的なパターン

#### 4.2.1. 非相関サブクエリ
サブクエリが外側のクエリに依存せず、常に同じ値を返します。

*   **SQL例**: 各社員の給与と、全社の平均給与を並べて表示する
    ```sql
    SELECT 
        社員名, 
        給与,
        (SELECT AVG(給与) FROM 社員) AS 全社平均給与
    FROM 社員;
    ```
    *   **解説**: サブクエリは**一度だけ実行**され、その結果（全社平均給与）が**全ての行に表示**されます。

#### 4.2.2. 相関サブクエリ
サブクエリが外側のクエリの行の値を参照するため、行ごとに異なる結果を返します。

*   **SQL例**: 各社員の給与と、その社員が所属する**部署の**平均給与を並べて表示する
    ```sql
    SELECT 
        社員名, 
        給与,
        (SELECT AVG(給与) 
         FROM 社員 AS 同部署 
         WHERE 同部署.部署ID = 社員.部署ID) AS 部署平均給与
    FROM 社員;
    ```
    *   **解説**: `WHERE 同部署.部署ID = 社員.部署ID` の部分で、外側のクエリで処理中の行（`社員`）の`部署ID`を参照しています。これにより、各社員が所属する部署の平均給与が動的に計算されます。
    
    SELECTに、集計関数 AVG() が使われているが、**相関サブクエリ（correlated subquery）**の中で使われており、メインのクエリの集計ではないので、GROUP BYは不要である。
    メインクエリの1行ごとにサブクエリが実行され、計算結果（単一の値）が1つの列として追加されるだけであり、メインクエリ自体は行をグループ化（集約）していないため、GROUP BYは必要ありません。

### 4.3. 他の構文への書き換え
SELECT句の相関サブクエリは、性能や可読性の観点から、JOINやウィンドウ関数で書き換えられることがあります。

*   **JOINによる書き換え例（上記4.2.2と同じ結果）**
    ```sql
    SELECT
        s.社員名,
        s.給与,
        d.部署平均給与
    FROM 社員 AS s
    JOIN (
        SELECT 部署ID, AVG(給与) AS 部署平均給与
        FROM 社員
        GROUP BY 部署ID
    ) AS d ON s.部署ID = d.部署ID;
    ```
*   **ウィンドウ関数による書き換え例（参考）**
    ```sql
    SELECT
        社員名,
        給与,
        AVG(給与) OVER (PARTITION BY 部署ID) AS 部署平均給与
    FROM 社員;
    ```

---

## 5. 相関サブクエリ (Correlated Subquery)

相関サブクエリは、サブクエリ（内側のクエリ）が親クエリ（外側のクエリ）の列を参照するサブクエリです。

### 5.1. 定義と特徴
*   **実行方式**: 親クエリの各行が処理されるたびに、その行の値を参照してサブクエリが**繰り返し実行**されます。
*   **非相関サブクエリとの比較**:

| 項目 | 相関サブクエリ | 非相関サブクエリ |
| :--- | :--- | :--- |
| **実行回数** | 親クエリの行数分、繰り返し実行 | 1回だけ実行 |
| **外部参照** | **あり**（親クエリの列を参照） | なし |
| **処理速度** | 遅くなる傾向がある | 速い傾向がある |
| **用途** | 行ごとの動的な比較や存在チェック | 固定的な値や集合との比較 |

### 5.2. 使用箇所ごとのパターン

#### 5.2.1. WHERE句での利用
*   **比較演算子**: 各行の値を、その行に関連するグループの集計値と比較します。
    *   **SQL例**: 自身が所属する部署の平均給与よりも高い給与をもらっている社員を抽出
        ```sql
        SELECT 社員名, 給与
        FROM 社員 s1
        WHERE 給与 > (
          SELECT AVG(給与)
          FROM 社員 s2
          WHERE s2.部署ID = s1.部署ID -- 親クエリの部署IDを参照
        );
        ```

*   **EXISTS / NOT EXISTS**: 親クエリの各行について、関連するデータがサブクエリ内に存在するかどうかをチェックします。
    *   **SQL例**: 一度でも注文を担当したことがある社員を抽出
        ```sql
        SELECT 社員名
        FROM 社員
        WHERE EXISTS (
          SELECT 1 -- '1'自体に意味はなく、行の存在チェックが目的
          FROM 注文
          WHERE 注文.社員ID = 社員.社員ID -- 親クエリの社員IDを参照
        );
        ```
    *   **`NOT EXISTS`** を使えば、「一度も注文を担当したことがない社員」を安全に抽出できます（`NOT IN` のNULL問題を回避可能）。

#### 5.2.2. SELECT句での利用
「4.2.2. 相関サブクエリ」で解説した通り、親クエリの行ごとに計算した値を新たな列として追加します。

#### 5.2.3. HAVING句での利用
`GROUP BY` で集計されたグループごとに、サブクエリを条件として利用します。
*   **SQL例**: 部署の平均給与が、全社平均よりも高い部署を抽出
    ```sql
    -- この例は非相関だが、HAVING句でサブクエリが使えることを示す
    SELECT 部署ID, AVG(給与) AS 平均給与
    FROM 社員
    GROUP BY 部署ID
    HAVING AVG(給与) > (SELECT AVG(給与) FROM 社員);
    ```

### 5.3. 相関サブクエリの注意点と試験対策
*   **外部参照の見逃し**: `WHERE s2.部署ID = s1.部署ID` のような相関条件を見落とし、非相関サブクエリと誤認しないように注意が必要です。
*   **性能問題**: 親クエリの行数が多くなると、繰り返し実行により性能が著しく低下する可能性があります。JOINへの書き換えを検討することが重要です。
*   **試験頻出パターン**:
    1.  **グループ内比較**: 「部署内の平均/最大値より大きい」など。
    2.  **存在チェック**: 「〜したことがある/ない顧客」など（`EXISTS` / `NOT EXISTS`）。
    3.  **ランキング**: 「部署内で給与がトップの社員」など。