## 応用情報技術者試験　午後DB SQL文問題集

### 問題　★
ある企業の人事システムにおいて、以下の要件を満たす社員テーブルを作成する必要があります。

**要件：**
- 社員IDは各社員を一意に識別する主キーとする
- 社員名は必須入力項目とする
- 入社状態は未入力の場合「在職」を初期値とする
- 部署IDは部署マスタテーブルの部署IDを参照する外部キーとする
- 年齢は１８歳以上６５歳以下の範囲内のみ**許可**する

以下のCREATE TABLE文の空欄を埋めて、上記要件を満たすテーブル定義を完成させてください。

```sql
CREATE TABLE 社員 (
    社員ID VARCHAR(10) 【 a 】 【 b 】,
    社員名 VARCHAR(50) 【 c 】 【 d 】,
    入社状態 VARCHAR(10) 【 e 】 '在職',
    部署ID VARCHAR(10),
    年齢 INTEGER 【 f 】 (年齢 >= 18 AND 年齢 <= 65),
    【 g 】 【 h 】 (部署ID) 【 i 】 部署マスタ(部署ID)
);
```

**【回答】**
`a`: PRIMARY　`b`: KEY
`c`: NOT　`d`: NULL
`e`: DEFAULT
`f`: CHECK
`g`: FOREIGN　`h`: KEY　`i`: REFERENCES

**【構文の解説】**
- `PRIMARY KEY`: テーブル内で各行を一意に識別する主キーを定義
- `NOT NULL`: 該当列へのNULL値格納を禁止し、必須入力を強制
- `DEFAULT 値`: INSERT時に値が省略された場合の既定値を設定
- `CHECK (条件式)`: 指定した条件を満たす値のみの入力を**許可**　★
- `FOREIGN KEY (列名) REFERENCES テーブル名(列名)`: 他テーブルとの参照整合性を維持★カッコいる

**【初心者が陥りがちな誤解や誤答例】**
* **誤解/誤答**: 制約の`記述順序`を間違える（例：`DEFAULT NOT NULL`の順序で記述）
* **解説**: SQL標準では制約の記述順序が決まっており、一般的に [ データ型 → NOT NULL → DEFAULT → CHECK → 主キー] の順序で記述します。また、**外部キー制約は列定義の後に独立**して記述します。

* **誤解/誤答**: `FOREIGN KEY`制約で参照先テーブルの列名を省略する
* **解説**: `REFERENCES`句では、`参照先テーブル名＋列名`も明示的に指定する必要があります。省略すると構文エラーになります。

* **誤解/誤答**: `CHECK`制約の条件式で列名を引用符で囲む
* **解説**: CHECK制約の条件式内で使用する列名は、文字列リテラルではないため引用符で囲んではいけません。`CHECK ('年齢' >= 18)`は誤りで、`CHECK (年齢 >= 18)`が正解です。

### 問題1
月末棚卸しのため、「倉庫C003で在庫が100以上ある商品」について、**全倉庫での在庫合計**を出したい。空欄を埋めよ。

```sql
SELECT 商品コード, SUM(在庫数) AS 在庫合計
FROM 在庫
WHERE 商品コード 【 a 】 (
  SELECT 商品コード
  FROM 在庫
  WHERE 倉庫番号 = 'C003' AND 在庫数 >= 100
)
GROUP BY 商品コード;
```

**【回答】**
`a`: IN

**【この構文が必要な理由】**
内側は「商品コードの`集合`（1列複数行）」を返すため、外側の行がその`集合`に**属するか**を判定する `IN` が最短・明解。
集合の判定は、`IN`がベストだし、分かりやすい。考えなくてよい。

**【構文の解説】**

  * 形：`値 IN (サブクエリ)`（サブクエリは1列複数行の`集合`）
  * 役割：集合への所属判定。重複は自動的に無害化される。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`商品コード = (SELECT 商品コード ...)`

      * **解説**：`=` は**スカラー値：1行1列**専用。

  * **誤答**：`EXISTS (SELECT ...)` に置換

      * **解説**：書けるが「集合所属」は `IN` が自然で可読性・保守性が高い。

  * **性能感**：`IN` は**軽い/高速**（索引があれば特に）。内側に適切な索引（`在庫(倉庫番号, 在庫数, 商品コード)`）でさらに高速。
-----
### 問題2

「**一度でも注文した顧客**」を抽出したい。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客 o
WHERE 【 a 】 (
  SELECT 1
  FROM 注文 i
  WHERE i.顧客ID = o.顧客ID
);
```

**【回答】**
`a`: EXISTS

**【この構文が必要な理由】**
「関連行が**1件でも存在**するか」を問う設計には `EXISTS` が最短で、行の中身ではなく**存在**だけを見るため効率的。

**【構文の解説】**
  * 形：`EXISTS (SELECT 1 FROM 関連表 WHERE 関連表.key = 外側.key AND 条件)`
  * 役割：存在の有無だけ真偽化（件数は不要）。
  * **FROM→WHERE(外側)** → `EXISTS` 内部で必要最小限の探索。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`SELECT *` にしないと速くならない
      * **解説**：`EXISTS` は**存在のみ**評価。`SELECT 1` で十分（中身は読まない）。「１つでも」の１とイメージすれば、おのずと`SELECT 1`となる。

  * **誤答**：`IN (SELECT 顧客ID FROM 注文)` に必ず置換
      * **解説**：`IN` でも等価になりやすいが、相関条件や追加条件が多いと `EXISTS` の方が**軽い/高速**になる場面が多い（索引命中時）。
-----
### 問題3

「**一度も注文が無い顧客**」を抽出したい。
```sql
SELECT 顧客ID, 顧客名
FROM 顧客 o
WHERE 【 a 】 (
  SELECT 1
  FROM 注文 i
  WHERE i.顧客ID = o.顧客ID
);
```

**【回答】**
`a`: NOT EXISTS
**【この構文が必要な理由】**
`NOT IN` は内側に `NULL` が混入すると意図せず結果が**0件**になり得る。`NOT EXISTS` は**NULL非依存**で安全。
**【構文の解説】**
  * 形：`NOT EXISTS (相関サブクエリ)`
  * 役割：関連行が**1件も無い**ことの判定（NULLの影響なし）。
  * 評価順注記：外側を1行ずつ検査→内側で該当行の有無だけチェック。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`顧客ID NOT IN (SELECT 顧客ID FROM 注文)`

      * **解説**：内側 `顧客ID` に `NULL` が1つでもあると三値論理で**UNKNOWN**に倒れ外側が落ちる。

  * **性能感**：適切な索引（`注文(顧客ID)`）があれば **軽い/高速**。フルスキャンは**重い/低速**。
-----
### 問題4
「**ブラックリスト顧客**（テーブル：取引停止(顧客ID)）を除外して顧客を一覧」する。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客
WHERE 顧客ID 【 a 】 (
  SELECT 顧客ID
  FROM 取引停止
  WHERE 【 b 】 
);
```

**【回答】**
`a`: NOT IN
`b`: 顧客ID IS NOT NULL

**【この構文が必要な理由】**
`NOT IN` は内側に `NULL` があると外側が**全落ち**するため、内側で `IS NOT NULL` を加えて候補から除外しておく。

**【構文の解説】**

  * 形：`値 NOT IN (SELECT 列 FROM T WHERE 列 IS NOT NULL)`
  * 役割：否定の集合比較だが、**NULL除外**が実務必須。
  * 評価順注記：内側WHEREでNULL除外→外側WHEREで否定所属判定。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`NOT IN` は `NULL` を自動無視

      * **解説**：いいえ。`NOT IN` は `NULL` が1つでもあるとサブクエリ全体がUNKNOWNとなり、ゼロ件となる。

  * **代案**：`NOT EXISTS` が**推奨**（より安全・読みやすい）。

  * **性能感**：`NOT EXISTS` の方が最適化しやすく**速い**ことが多い。

-----

### 問題5

「**特売商品**（特売商品(商品コード)）に含まれる商品だけ、商品マスタから抽出」したい。

```sql
SELECT 商品コード, 商品名
FROM 商品マスタ
WHERE 商品コード = 【 a 】 (
  SELECT 商品コード
  FROM 特売商品
);
```

**【回答】**
`a`: ANY

**【この構文が必要な理由】**
`= ANY(集合)` は `IN(集合)` と等価で、**単一値比較の形**で集合所属を表現できる。

**【構文の解説】**

  * 形：`式 = ANY (サブクエリ)`（1列複数行）
  * 量化の意味：**いずれか**と等しければ真。
  * 評価順注記：内側で候補集合→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`ANY` は「任意の値より大きい」の意味

      * **解説**：演算子と**組み合わせ**で意味が決まる。`= ANY` は `IN`、`> ALL` は「最大より大きい」など。

  * **性能感**：`IN` と同程度。索引が利くと**高速**。

-----
### 問題6
「**部門内で給与が全員より高い社員**」を抽出する。自分自身は除外して比較する。

```sql
SELECT 社員ID, 社員名, 部署ID, 給与
FROM 社員 s
WHERE 給与 【 a 】 (
  SELECT 給与
  FROM 社員 t
  WHERE t.部署ID = s.部署ID
    AND t.社員ID <> s.社員ID
);
```

**【回答】**
`a`: > ALL

**【この構文が必要な理由】**
`> ALL(集合)` は「集合の**最大値より大きい**」と同値。部署内の全員より高いを1発で表現。

**【構文の解説】**

  * 形：`式 > ALL(サブクエリ)`
  * 等価形：`給与 > (SELECT MAX(給与) FROM 社員 WHERE 部署ID = 自.部署ID AND 社員ID <> 自.社員ID)`
  * 評価順注記：内側で比較集合→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`>= ALL`

      * **解説**：自分と同額の誰かがいれば成立してしまう。問題は「全員より高い」なので `>`。

  * **性能感**：`MAX` 等価形に書き換えると**軽い/高速**になりやすい（集約1回）。

-----
### 問題7　★★

「**競合より最安**の自社商品」を抽出する（競合価格(商品コード, 競合単価)）。

```sql
SELECT s.商品コード, s.商品名, s.単価
FROM 商品マスタ s
WHERE s.単価 【 a 】 (
  SELECT 競合単価
  FROM 競合価格 c
  WHERE c.商品コード = s.商品コード
);
```

**【回答】**
`a`: <= ALL

**【この構文が必要な理由】**
`<= ALL(集合)` は「集合の**最小値以上ではない**」= **最小値以下**。競合のどれよりも高くない → **最安**を表現。

## 🗂 テーブル定義★

### 商品マスタ（商品コード, 商品名, 単価）

| 商品コード | 商品名 | 単価 |
|------------|--------|------|
| A001       | 商品A  | 170  |
| A002       | 商品B  | 185  |
| A003       | 商品C  | 160  |

### 競合価格（商品コード, 競合単価）

| 商品コード | 競合単価 |
|------------|----------|
| A001       | 180      |
| A001       | 190      |
| A001       | 200      |
| A002       | 150      |
| A002       | 160      |
| A003       | 170      |
| A003       | 160      |

---

## クエリ①：`ANY` を使った場合

```sql
SELECT 商品コード, 商品名, 単価
FROM 商品マスタ s
WHERE s.単価 <= ANY (
  SELECT 競合単価
  FROM 競合価格 c
  WHERE c.商品コード = s.商品コード
);
```

### 出力結果（成立した商品）

| 商品コード | 商品名 | 単価 |
|------------|--------|------|
| A001       | 商品A  | 170  |
| A003       | 商品C  | 160  |

※ A001（170）は 170 <= ANY(180, 190, 200) → ✅ → 出力される
※ A002（185）は 185 <= ANY(150, 160) → ❌ → 出力されない
※ A003（160）は 160 <= ANY(160, 170) → ✅ → 出力される

---

## クエリ②：`ALL` を使った場合

```sql
SELECT 商品コード, 商品名, 単価
FROM 商品マスタ s
WHERE s.単価 <= ALL (
  SELECT 競合単価
  FROM 競合価格 c
  WHERE c.商品コード = s.商品コード
);
```

### 出力結果（成立した商品）

| 商品コード | 商品名 | 単価 |
|------------|--------|------|
| A001       | 商品A  | 170  |
| A003       | 商品C  | 160  |

※ A001（170）は 170 <= ALL(180, 190, 200) → ✅ → 出力される
※ A002（185）は 185 <= ALL(150, 160) → ❌ → 出力されない
※ A003（160）は 160 <= ALL(160, 170) → ✅ → 出力される

---

## 🔍 演算子ごとの出力比較

| 商品コード | 商品名 | 単価 | `ANY`結果 | `ALL`結果 |
|------------|--------|------|------------|------------|
| A001       | 商品A  | 170  | ✅         | ✅         |
| A002       | 商品B  | 185  | ❌         | ❌         |
| A003       | 商品C  | 160  | ✅         | ✅         |

---

この形式であれば、**演算子ごとの成立条件と出力が明確に可視化**されます。  
必要なら、演算子を変えて（`>` や `=`）出力結果を再構成することもできます。どの方向に進めましょう？


★
・サブクエリは集合（値の集合）それらを、全体を相手にするのか（ALL）、一人でもよしとするのか（ANY）で、まず、ALLかANYを決める。
・その後、その集合に対して、最小値、最大値などの比較演算子を考える。



**【構文の解説】**

  * 形：`式 <= ALL(サブクエリ)`
  * 等価形：`自.単価 <= (SELECT MIN(競合単価) FROM 競合価格 WHERE 商品コード=自.商品コード)`
  * 評価順注記：内側で比較集合（商品ごと）→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`< ANY` で最安　

      * **解説**：`< ANY` は「**どれか1つ**より小さい」だけ。最安保証にならない。


## MIN(SELECT ...) と ANY(SELECT ...) の違い【重要】

## １　概要
`MIN(SELECT ...)` がダメで、`ANY(SELECT ...)` はＯＫ。
この違いは、それぞれのキーワードがＳＱＬの中で持つ「役割」の違いから来ています。

## １－１　各キーワードの役割比較

| キーワード | 役割 | 引数（カッコの中）に取るもの |
|-----------|------|----------------------------|
| `MIN()` | 集計関数：値の集合から１つの値を計算する | 列名 (`MIN(単価)`) |
| `ALL`, `ANY` | 比較演算子：サブクエリが返す値のリストと比較する | サブクエリ（SELECT文） (`< ANY (SELECT ...)`) |

## １－２　ＡＮＹ及びＡＬＬの特徴

ＡＮＹやＡＬＬは、もともとサブクエリ（SELECT文）の結果（値のリスト）と比較するために生まれてきた演算子なのです。

-----

### 問題8

「**部門平均より給与が高い社員**」を抽出せよ。

```sql
SELECT 社員ID, 社員名, 部署ID, 給与
FROM 社員 o
WHERE 給与 > (
  SELECT 【 a 】(給与)
  FROM 社員 d
  WHERE d.部署ID = o.部署ID
);
```

**【回答】**
`a`: AVG

**【この構文が必要な理由】**
スカラサブクエリ（`=` や `>` と比較）は**必ず1行1列**。部門ごとに複数行になる集合を `AVG` で**単一値**へ縮約する。

**【構文の解説】**

  * 形：`式 [比較] (SELECT 集約(列) FROM ... WHERE ...)`
  * 役割：相関して**部門単位の代表値**（平均）を得る。
  * 評価順注記：外側1行ごとに内側を評価（相関）。
  * 補足：`GROUP BY 部署ID` を使わず相関で1部署に限定→1行化。これ。WHERE d.部署ID = o.部署ID

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`WHERE 給与 > (SELECT 給与 FROM 社員 WHERE 部署ID = 外側.部署ID)`

      * **解説**：内側が**複数行**になり不適。集約（`AVG`/`MAX`）で1行化が必要。

-----

### 問題 ★
「社員」テーブルには、全社員の氏名、年齢、所属部署IDが格納されています。ここから、各社員の氏名と年齢に加えて、「その社員が所属する部署の平均年齢」を算出し、一覧で表示したい。

このように、個別のレコードと、そのレコードが属するグループの集計値（この場合は部署ごとの平均年齢）を同時に取得するためには、どのようにSQLを組み立てればよいか。以下のSQL文の空欄を埋めてください。

```sql
SELECT
  S.氏名, S.年齢, DeptAvg.平均年齢
FROM
  社員 S 【 a 】 (
  SELECT 所属部署ID, AVG(年齢) AS 平均年齢
  FROM  社員
  【 b 】
    所属部署ID
) 【 c 】  ON S.所属部署ID = DeptAvg.所属部署ID;
```

### 【回答】
a: `INNER JOIN`
b: `GROUP BY`
c: AS DeptAvg ※ASは省略可能。APではほとんど省略されるので、可読性は悪く作られている。


★　最初にSELECTを見る。次に、GROUP BYをつぶすという順序は体得しよう。

### 【この構文が必要な理由】
個々の社員レコードと、「部署ごと」という異なる粒度で集計した平均年齢データを、1つの結果セットとして結合して表示する必要があるためです。

### 【構文の解説】
このSQLでは、FROM句の中でサブクエリを使い、それを仮想的なテーブル（インラインビュー）として扱っています。

*   **`FROM ... INNER JOIN (SELECT ... ) AS <別名> ON ...`**:
    *   `()` 内の`SELECT`文が先に実行され、部署IDごとの平均年齢を算出した一時的なテーブル（この例では`DeptAvg`）が作成されます。
    *   `INNER JOIN`句と`ON`句を使い、元の「社員」テーブルとこの一時的なテーブルを`所属部署ID`をキーにして結合します。

*   **`GROUP BY <列名>`**:
    *   指定した列（この例では`所属部署ID`）の値が同じ行を一つのグループにまとめます。
    *   `AVG()`、`SUM()`、`COUNT()`などの集計関数と組み合わせて使用し、グループごとの集計値を算出するために必須の句です。

### 問題9

「**部署ごとの平均給与が30万円以上の部署**」の部署名と平均給与を求めよ。

```sql
SELECT 部署名, AVG(給与) AS 平均給与
FROM 社員
JOIN 部署 ON 部署.部署ID = 社員.部署ID
【 a 】 部署名
【 b 】 AVG(給与) >= 300000;
```

**【回答】**
`a`: GROUP BY
`b`: HAVING

**【この構文が必要な理由】**
**集計後の条件**は `HAVING`。`WHERE` は集計**前**の行を絞る。役割分担が逆だと論理破綻。

**【構文の解説】**

  * 形：`... GROUP BY 集約単位 HAVING 集約結果の条件`
  * 役割：`GROUP BY` で単位を作り、`HAVING` で**集計結果**をフィルタ。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`WHERE AVG(給与) >= 300000`

      * **解説**：`WHERE` では集約関数は使えない（まだ集計していない）。

### 問題10

「**2025年9月に一度でも売れた商品**」の**全倉庫在庫合計**を出せ。高速性を重視しろ。

```sql
SELECT 在庫.商品コード, SUM(在庫.在庫数) AS 在庫合計
FROM 在庫
WHERE 在庫.商品コード IN (
  SELECT 【 a 】 商品コード
  FROM 注文
  JOIN 注文明細 ON 注文明細.注文ID = 注文.注文ID
  WHERE 注文.注文日 >= DATE '2025-09-01'
    AND 注文.注文日 <  DATE '2025-10-01'
)
GROUP BY 在庫.商品コード;
```

**【回答】**
`a`: DISTINCT

**【この構文が必要な理由】**
`IN` は重複に強いが、内側の結果を `DISTINCT` で**最小化**するとヒット検査が**軽い/高速**になりやすい（実装依存）。

**【構文の解説】**

  * 形：`IN (SELECT DISTINCT キー FROM ... WHERE 条件)`
  * 役割：**キー集合**を先に確定（非相関）→外側で合計。
  * 評価順注記：内側WHEREで月を確定→`DISTINCT` でキー縮約→外側WHERE→外側GROUP BY。


---
## 補助メモ（検算テンプレ：頭の中で常に往復）
* `t.key IN (SELECT key FROM S WHERE 条件)`
  ⇔ `EXISTS (SELECT 1 FROM S WHERE 条件 AND S.key = t.key)`
* `x > ALL(SELECT y FROM S WHERE 条件)`
  ⇔ `x > (SELECT MAX(y) FROM S WHERE 条件)`
* `x < = ALL(SELECT y FROM S WHERE 条件)`
  ⇔ `x <= (SELECT MIN(y) FROM S WHERE 条件)`
* **NULL安全原則**：否定は `NOT EXISTS`、やむを得ず `NOT IN` なら**内側で `IS NOT NULL`**


---
### 問題　★
「今月購入履歴のある優良顧客のリストが欲しい」と依頼された。あなたは`顧客マスタ`と`売上明細`テーブルを使い、2つの設計図を書き始めた。
以下の2つのSQLを、それぞれの設計思想に沿って完成させよ。

```sql
-- 設計思想A:「今月購入した顧客IDの"リスト"」を先に作り、それと照合する
SELECT 顧客ID, 氏名
FROM 顧客マスタ
WHERE
    顧客ID 【 a 】 (SELECT 【 b 】 顧客ID FROM 売上明細);

-- 設計思想B: 顧客マスタの各行に対し、「関連する売上データが"存在"するか」を探索する
SELECT 顧客ID, 氏名
FROM 顧客マスタ M
WHERE
    【 c 】 (
        SELECT 【 d 】 FROM 売上明細 S WHERE S.顧客ID = 【 e 】
    );
```

**【回答】**
`a`: IN
`b`: DISTINCT
`c`: EXISTS
`d`: 1 (または `*`、列名など任意の値)
`e`: M.顧客ID

★WHERE　EXISTSと直結、WHERE　属性　INと間に属性が入る。
★SELECTもFROMも先に見ると、エイリアスが見えてくる。そして全体構造が見えてくる。


**【設計思想のアーキテクチャ解説】**
この課題は、同じ目的を達成するための2つの異なるアルゴリズムをSQLで表現する能力を問うています。
*   **設計思想A (`IN`) - セットベース・アーキテクチャ**:
    このアプローチの核心は、まずサブクエリで完全に独立した「値の集合（セット）」を構築することにあります。`【b】: DISTINCT` は、`売上明細`に同じ顧客のレコードが複数あっても、照合リストとしてはユニークなIDの集合であれば十分だからです。
*   **設計思想B (`EXISTS`) - 相関探索・アーキテクチャ**:
    こちらは、主問合せの1行を起点に、それに関連するデータが存在するかを探索するループ処理に近いモデルです。`【d】: 1` は、この思想を象徴する規約です。`EXISTS`は行の「存在有無」のみを判定するため、`SELECT`句で何を取得するかは結果に影響しません。「どの列の値か」ではなく「条件に合う行が見つかるか」だけが重要である、という`EXISTS`の本質を理解しているかが問われます。`【e】: M.顧客ID`は、主問合せとサブクエリを繋ぐ「探索キー」の役割を果たします。

**【プロフェッショナルへの道標】**
*   **なぜ `SELECT 1` なのか？**: `SELECT *`でも動作しますが、`SELECT 1`と記述することで、コードを読む人に **「ここで行の値は使っておらず、存在チェックだけが目的だ」**という明確な意図を伝えることができます。これは、チーム開発における可読性と保守性を高めるプロの習慣です。
*   **オプティマイザの存在**: 現代の賢いデータベース（オプティマイザ）は、`IN`と`EXISTS`のどちらで書かれても、内部で最も効率的だと判断した実行計画に変換することがあります。しかし、その挙動はデータの統計情報に依存し、常に最適とは限りません。両方の設計思想を使い分ける能力は、複雑なパフォーマンスチューニングの武器となります。

---

### 問題2　★〇

「営業部において、大阪支社の**全営業担当者の売上を上回る**という偉業を達成した、東京本社の営業担当者を全員リストアップせよ」という依頼を受けた。
この2つの異なる視点から、それぞれSQLを構築せよ。

```sql
-- 視点A：「大阪支社の全員」という集合に対して比較する
SELECT 氏名, 売上高
FROM 社員マスタ
WHERE
    所属 = '東京本社' AND
    売上高 > 【 a 】 (SELECT 売上高 FROM 社員マスタ WHERE 所属 = '大阪支社');

-- 視点B：大阪支社の集計結果と比較する
SELECT 氏名, 売上高
FROM 社員マスタ
WHERE
    所属 = '東京本社' AND
    売上高 > (SELECT 【 b 】(売上高) FROM 社員マスタ WHERE 所属 = '大阪支社');
```

**【回答】**
`a`: ALL
`b`: MAX

**【設計思想のアーキテクチャ解説】**
*   **視点A (`ALL`) - 述語論理による直接実装**:
    `ALL`は、SQLが持つ述語論理の能力を直接利用するアプローチです。「すべての（For All）」という要件をそのままコードに翻訳した形で、`人間の思考とSQLの表現が一致する`ため、ロジックの可読性が高まります。
*   **視点B (`MAX`) - 集計関数による最適化実装**:
    こちらは、「全員を上回る」という条件を「最大値を上回る」という問題に変換（最適化）してから実装するアプローチです。多くの場合、データベース内部では`ALL`よりも集計関数の方が効率的に処理できます。

**【プロフェッショナルへの道標】**
*   **対称性の理解**: `> ALL` が `> MAX` と等価であるのと同様に、` < ALL` は ` < MIN` と等価です。また、`> ANY` は `> MIN`、`< ANY` は `< MAX` となります。この対称性と関係性を体系的に理解することで、あらゆる比較条件を自在に書き換えられるようになります。
*   **インデックスとの関係**: `(SELECT MAX(売上高) ...)` のようなサブクエリは、`売上高`列にインデックスがあれば高速に動作します。`ALL`を使った場合もオプティマイザがインデックスを利用しようとしますが、集計関数を使った方がより直接的にインデックス利用の恩恵を受けやすいケースがあります。パフォーマンスとは、SQLの書き方とデータベースの物理設計の相互作用で決まるのです。



*   外ALL < |>           内側ANY          <|>  外ALL
* ` < ALL` | `> ANY`            `< ANY`  | `> ALL`
* ` < MIN` | `> MIN`            `< MAX`  | `> MAX`
*         最小値　　　　　　　　　　　　　最大値
---

### 問題 ★★
「退会者リストにいない有効会員」を抽出するSQLが、ある日突然**結果を1件も返さなくなった**のだ。調査の結果、データ移行時のミスで`退会者リスト`に`会員ID`が`NULL`のレコードが1件だけ紛れ込んでいたことが判明した。
このインシデントを引き起こした欠陥のあるSQL(`コード1`)を特定し、`NULL`の呪いを解くための2種類の修正コード(`コード2`, `コード3`)を完成させよ。

```sql
-- コード1: インシデントの元凶となった、NULLの罠に嵌ったコード
SELECT 氏名 FROM 会員マスタ
WHERE 会員ID 【 a 】 (SELECT 会員ID FROM 退会者リスト);

-- コード2: コード1を使い続けるための「応急処置」コード
SELECT 氏名 FROM 会員マスタ
WHERE 会員ID 【 a 】 (
    SELECT 会員ID FROM 退会者リスト WHERE 【 b 】
);

-- コード3:  NULLの存在を許容する、最も「堅牢」な恒久対策コード
SELECT 氏名 FROM 会員マスタ M
WHERE 【 c 】 (
    SELECT 1 FROM 退会者リスト T WHERE T.会員ID = M.会員ID
);
```

**【回答】**
`a`: NOT IN
`b`: 会員ID IS NOT NULL
`c`: NOT EXISTS

**【設計思想のアーキテクチャ解説】**
　SQLエンジニアが必ず直面する「三値論理」と`NULL`の挙動を完全にマスターしているかを問う試験です。
*   **コード1 (`NOT IN`) - 欠陥アーキテクチャ**:
    `NOT IN`は、その内部動作（`<> a AND <> b AND <> c ...`）に起因する深刻な脆弱性を抱えています。比較リストに一つでも`NULL`が含まれると、`<> NULL`という評価不能な（`UNKNOWN`）条件が発生し、SQL全体が機能不全に陥ります。
*   **コード2 (`属性`＋`IS NOT NULL`) - 防御的パッチ**:
    これは、`NOT IN`の脆弱性を認識した上で、その弱点をピンポイントで補強するアプローチです。比較対象の属性から`NULL`を事前にフィルタリングすることで、`UNKNOWN`の発生を防ぎます。これは有効な対策ですが、`NOT IN`を使うたびにこの「おまじない」を忘れないようにしなければなりません。
*   **コード3 (`NOT EXISTS`) - NULL安全（NULL-Safe）アーキテクチャ**:
    `NOT EXISTS`は、そもそも値の比較を行わず、行の「存在」のみをスキャンするため、三値論理の罠に陥ることがありません。データに`NULL`が含まれようと、そのロジックは決して揺るがない。これこそが、予測不能なデータに立ち向かうための「防御的プログラミング」の思想を体現した、最も堅牢な設計です。

**【プロフェッショナルへの道標】**
*   **思想としての「NULL安全」**: `NOT IN`は「`リスト(集合)に無い`こと」を確認するのに対し、`NOT EXISTS`は「対応する`レコードが存在しない`こと」を確認します。この僅かな違いが、`NULL`に対する堅牢性の決定的な差を生みます。「否定の条件を書くときは、まず`NOT EXISTS`を想起すること」
*   **根本原因**: このインシデントの根本原因は、`退会者リスト`の`会員ID`列に`NOT NULL`制約が課されていなかったからです。優れたSQLエンジニアは、コードで問題を解決するだけでなく、問題の発生を構造的に防ぐ視点を持っています。


#### 問題3
```sql
【 a 】 関東売上 AS (
    SELECT
        担当者ID,
        金額
    FROM
        売上明細
    WHERE
        店舗所在地 IN ('東京', '神奈川', '千葉')
)
SELECT
    担当者名,
    【 b 】(金額) AS 売上合計
FROM
    関東売上
【 c 】
    社員 ON 関東売上.担当者ID = 社員.社員ID
【 d 】 BY
    担当者名
【 e 】 BY
    売上合計 DESC;
```

【回答】

a: WITH
b: SUM
c: INNER JOIN
d: GROUP
e: ORDER


**【この構文が必要な理由】**
複雑なSQLを複数のステップに分割し、それぞれに名前を付けて管理するために `WITH`句（共通テーブル式: CTE）が必要です。これにより、可読性とメンテナンス性が向上します。

**【構文の解説】**
`WITH 別名 AS (SELECT文) SELECT ... FROM 別名;`
`SELECT`文の前に `WITH`句を定義します。`WITH`句の中で定義した「一時的な結果セット（ここでは `関東売上`）」は、後の `SELECT`文から`通常のテーブルのように`参照できます。複数のCTEをカンマで区切って定義することも可能です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WITH`句で定義したCTEを、全く別のSQL文から参照しようとする。
*   **解説**: CTEの有効範囲は、それが定義された一つのSQL文の中だけです。CTEは一時的なものであり、データベースに永続的に保存されるテーブルやビューとは異なります。

---

#### 問題4 ★〇

「各部署内で、給与が高い順に社員のランキングを付けたい」という依頼がありました。

```sql
SELECT
    社員名,
    部署名,
    給与,
    【 a 】() OVER (【 b 】 部署名 ORDER BY 給与【 c 】) AS 部署内順位
FROM
    社員;
```
**【回答】**
`a`: `RANK`
`b`: `PARTITION BY`
`c`: `DESC`

**【構文の解説】**
`関数() OVER (PARTITION BY グループ化する列 ORDER BY 順位付けの列)`
`PARTITION BY`は、データを指定した列の値に基づいて小さな窓（ウィンドウ）に分割する役割を果たします。
`GROUP BY`と異なり、元の行を一つにまとめることなく処理できるのが最大の特徴です。
`RANK()`関数はその窓の中で順位を計算します。


**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `RANK()`と`DENSE_RANK()`の違いを理解せず、何となく使ってしまう。
*   **解説**: 同順位があった場合、その次の順位の扱いが異なります。
例えば、2位が2人いた場合、
`RANK()`の次の順位は4位になりますが（`3位は欠番`）、
`DENSE_RANK()`の次の順位は3位となり、順位が詰まります。

---

#### 問題5　★★

商品カテゴリごとに月次売上を算出し、各カテゴリ内での前月売上と、それに基づいた売上の増減評価（「増加」「減少」「維持」）を同時に表示するSQLクエリを完成させてください。

```sql
[ 1 ] カテゴリ別月次売上 AS (
    SELECT
        P.商品カテゴリ,
        DATE_FORMAT(S.売上日, '%Y-%m') AS 売上月,
        SUM(S.単価 * S.数量) AS 月次売上
    FROM
        売上明細 AS S
    INNER JOIN
        商品マスタ AS P ON S.商品コード = P.商品コード
    GROUP BY
        P.商品カテゴリ, 売上月
)
SELECT
    商品カテゴリ,
    売上月,
    月次売上,
    [ 2 ](月次売上, 1, 0) OVER (
        [ 3 ] 商品カテゴリ ORDER BY 売上月
    ) AS 前月売上,
    [ 4 ]
        [ 5 ] 月次売上 > 前月売上 THEN '増加'
        WHEN 月次売上 < 前月売上 THEN '減少'
        [ 6 ] '維持'
    [ 7 ] AS 増減評価
FROM
    カテゴリ別月次売上
ORDER BY
    商品カテゴリ, 売上月;

```

**解答**

*   `1`: `WITH`
*   `2`: `LAG`★
*   `3`: `PARTITION BY`
*   `4`: `CASE`
*   `5`: `WHEN`
*   `6`: `ELSE`
*   `7`: `END`

**【解説】**

## SQLクエリの解説

### 各関数の役割

#### **[ 1 ] `WITH`句**
ここでは`WITH`句を使い、「カテゴリ別月次売上」という名前の一時的なテーブル（共通テーブル式）を作成しています。
*   **役割**: `WITH`句の役割は、複雑なSQL文を部品に分け、クエリ全体を読みやすくすることです。
*   **処理内容**:
    1.  売上明細テーブルと商品マスタテーブルを `INNER JOIN` で結合し、商品カテゴリ名を取得します。
    2.  `GROUP BY` を使って「商品カテゴリ」と「売上月」でデータをグループ化し、`SUM()` で各グループの売上合計（月次売上）を計算しています。
    3.  この計算結果が、後の処理で利用できる「カテゴリ別月次売上」という仮想的なテーブルになります。

#### **[ 2 ] `LAG`関数**★★
この関数は、指定された順序（`ORDER BY`）に基づいて、現在の行より前の行の値を取得します。
*   `LAG(月次売上, 1, 0)` は「"月次売上"カラムの1つ前の値を取得し、もし存在しなければ0を返す」という意味です。

#### **[ 3 ] `PARTITION BY`句**
ウィンドウ関数を適用する範囲を区切る（パーティションを作成する）ための句です。
*   **役割**: `PARTITION BY 商品カテゴリ` と指定することで、「商品カテゴリごと」にデータを区切り、その中で `LAG` 関数を適用します。これにより、"PC"カテゴリの売上は"PC"カテゴリ内だけで前月比較され、"書籍"カテゴリの売上が混ざることはありません。

#### **[ 4 ] - [ 7 ] `CASE`式 (`CASE / WHEN / ELSE / END`)**
`CASE`式は、プログラミング言語の `if-then-else` 文のように、条件に応じて異なる値を返すための構文です。
*   **役割**: ここでは、`LAG`関数で取得した「前月売上」と当月の「月次売上」を比較し、その大小関係に基づいて**「増加」「減少」「維持」という評価ラベルを動的に生成**しています。

---

### クエリ全体の処理フロー

1.  **データ準備 (`WITH`句)**
    *   売上明細と商品マスタの2つのテーブルを結合し、「商品カテゴリごとの月次売上」を事前に集計しておきます。

2.  **前月売上の取得 (メインクエリ)**
    *   1.で作成した集計結果に対し、`PARTITION BY`でカテゴリごとにデータを区切ります。
    *   その区切りの中で`LAG`関数を使い、時系列順（`ORDER BY 売上月`）に1つ前の月の売上を取得します。

3.  **増減評価の付与 (`CASE`式)**
    *   2.で取得した前月売上と当月売上を`CASE`式で比較し、「増加」「減少」「維持」のいずれかの文字列を「増減評価」カラムとして追加します。

4.  **結果の表示**
    *   最終的に、「商品カテゴリ」「売上月」「月次売上」「前月売上」「増減評価」の各カラムを、カテゴリと日付で並べ替えて表示します。

現在の行を基準として、それより「前」または「後」の行のデータを直接参照するために `LAG`（前）や `LEAD`（後）★といったウィンドウ関数が必要です。これにより、複雑な自己結合やサブクエリなしで、時系列データの前後の値との比較が簡単に行えます。

**【構文の解説】**
`LAG(参照したい列, ずらす行数, [NULLの場合のデフォルト値]) OVER (ORDER BY 並び順)`
`ORDER BY`で指定された順序に基づき、現在の行から指定した行数だけ前の行のデータを取得します。このSQLでは、売上月で並べた上で1つ前の行（`LAG(月次売上, 1)`）の`月次売上`を取得しています。



---

#### 問題6

休眠顧客を把握するため、顧客マスタに登録はされているものの、「一度も注文をしたことがない顧客」を特定せよ。

```sql
SELECT
    C.顧客名
FROM
    顧客マスタ AS C
WHERE
    【 a 】 (SELECT 1 FROM 注文 AS O WHERE O.顧客ID = C.顧客ID);
```

**【回答】】**
`a`: `NOT EXISTS`

**【この構文が必要な理由】**
ある条件に一致するデータが、別のテーブル（サブクエリ内）に「一件も存在しないこと」を確認するために `NOT EXISTS` 演算子が必要です。これにより、「注文履歴がない」という条件を効率的に判定できます。

**【構文の解説】**
`WHERE NOT EXISTS (サブクエリ)`
`NOT IN`と異なり、サブクエリ内の `NULL` の影響を受けないため、より安全で確実な方法とされています。

---
#### 問題7 ★★

問題6と同じく、「一度も注文をしたことがない顧客」を特定します。今度はテーブルを外部結合し、データが存在しないことを利用するアプローチです。

```sql
SELECT
    C.顧客名
FROM
    顧客マスタ AS C
【 a 】
    注文 AS O ON C.顧客ID = O.顧客ID
WHERE
   O.注文ID 【 b 】;
```

**【回答】】**
`a`: `LEFT JOIN`
`b`: ` IS NULL`

**【この構文が必要な理由】**
`LEFT JOIN` を使うと、基準となる左側のテーブル（顧客マスタ）のデータはすべて残り、右側のテーブル（注文）に対応するデータがない場合はその列が `NULL` になります。この性質を利用し、**「注文IDが `NULL` であること」を条件**に絞り込むことで、注文履歴のない顧客を抽出できます。

**【2つのアプローチの比較】**
*   **`NOT EXISTS`（問題6）**: 「存在チェック」の意図が明確で、可読性が高いと考える人もいます。
*   **`LEFT JOIN ... IS NULL`（問題7）**: 結合結果をイメージしやすく直感的です。顧客情報だけでなく、他の結合したテーブルの情報も `SELECT`句で利用したい場合に拡張しやすいという利点があります。

---
#### 問題 ★★
「書籍マスタ」テーブルから、書籍名が特定のパターンに一致する書籍の情報を抽出します。以下のそれぞれの条件を満たすためのSQL文について、空欄【 a 】〜【 d 】に入る最も適切な字句の組み合わせを答えてください。

```sql
-- 条件1: 書籍名の2文字目が 'Q' で、末尾が '入門' である書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE '【 a 】';
-- 条件2: 書籍名に '100%' という文字列自体が含まれる書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE 【 b1 】【 b2 】 '!';
-- 条件3: 書籍名の先頭が 'A', 'B', 'C' のいずれかで始まる書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE '【 c 】';
-- 条件4: 書籍名の先頭が英字(A-Z)ではない書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE '【 d 】%';

```
**【回答】**
`a`: `_Q%入門`


`b1`: `'%100!%%'`
`b2`: `ESCAPE`


`c`: `[ABC]%` または `[A-C]%`


`d`: `[^A-Z]`

**【この構文が必要な理由】**
ECサイトの検索機能のように「一部の文字しか覚えていない」「特定のパターンに合う商品を探したい」といった、**あいまいな条件でデータを検索する**際に、ワイルドカードを用いた`LIKE`演算子は不可欠です。完全に一致するデータだけでなく、柔軟な文字列検索を実現するために、これらのワイルドカードの役割を正確に理解することが重要です。

**【構文の解説】**
*   `LIKE 演算子`: 文字列の部分一致やパターンマッチング検索を行います。
*   **ワイルドカードの種類**:
    *   `%` (パーセント): `_Q%入門` の `%` の部分。**0文字以上の任意の文字列**を表します。「Q」と「入門」の間にどんな文字が何文字あっても（0文字でも）一致します。
    *   `_` (アンダースコア): `_Q%入門` の `_` の部分。**任意の1文字**を表します。先頭に何かしらの1文字があり、2文字目が「Q」である、という条件を指定します。
    *   `[]` (角括弧): `[ABC]` の部分。角括弧内に指定された**いずれか1文字**に一致することを表します。`[A-C]`のようにハイフン `-` を使うと範囲指定も可能です。
    *   `^` (キャレット): `[^A-Z]` の部分。角括弧の先頭で使うことで、指定した文字**以外**の1文字に一致することを表します。(NOTの意味)
    *   `ESCAPE` 句: `LIKE`句の中でワイルドカードとして扱われる文字 (`%` や `_`) そのものを検索したい場合に使います。`ESCAPE '!'`と指定することで、「**`!`の直後の1文字はワイルドカードではなく、ただの文字** として扱ってください」という意味になります。この例では `!%` を `%` という文字として検索しています。

**【初心者が陥りがりがちな誤解や誤答例】**
*   **誤解/誤答3**: `[]` や `[^]` がどんな環境でも使えると思い込んでしまう。
*   **解説**: これらの角括弧を使ったパターンマッチングは、標準SQLでは定義されておらず、DBMSの拡張機能です。そのため、Oracle Databaseのように対応していないシステムや、MySQLのように `REGEXP` という別の演算子を使う必要があるシステムも存在します。実務では、開発対象のDBMSの仕様を確認する癖をつけることが重要です。

---

#### 問題 ★★
ある社員（社員ID: 'S010'）が営業部に異動し、基本給が300,000円に昇給しました。この情報を「社員」テーブルに反映させてください。また、その後、退職した社員（社員ID: 'S003'）のデータをテーブルから削除する必要が出てきました。

```sql
-- ① 異動と昇給の反映
【 a 】 社員
【 b 】 部署コード = 'D03', 基本給 = 300000
【 c 】 社員ID = 'S010';

-- ② 退職者データの削除
【 d 】 FROM 社員
【 e 】 社員ID = 'S003';
```

**【回答】**
`a`: UPDATE
`b`: SET
`c`: WHERE★
`d`: DELETE
`e`: WHERE★
**【この構文が必要な理由】**
`UPDATE`は既存データの値を`変更`し、`DELETE`は既存の行を`削除`する命令です。
これらの操作で**最も重要なのは`WHERE`句**であり、処理対象を正確に特定しないと、意図しないデータ破壊を引き起こす危険があります。

**【構文の解説】**
*   `UPDATE テーブル名 SET 列 = 値 WHERE 条件;`: 条件に一致する行の指定された列の値を更新します。
*   `DELETE FROM テーブル名 WHERE 条件;`: 条件に一致する行を削除します。
*   **重要**: `UPDATE`と`DELETE`において、** `WHERE`句を省略すると、テーブルの**全行**が対象となり致命的な操作ミスに繋がります。
---

### 問題
人事異動のデータ処理において、中途入社した社員「田中」（社員番号 'E101'）のデータが、仮の部署コードと上長で登録されている。今回、彼の正式な配属先が、先輩社員「鈴木」（社員番号 'E055'）と**全く同じ部署・同じ上長**に決定した。
この時、先輩社員のレコードを一度だけ参照し、後輩社員の「部署コード」と「上長社員番号」の2つの列を**同時に、かつアトミックに（不可分な一処理として）**更新したい。この要件を最も洗練された形で実現するための、以下のSQL文の空欄を埋めなさい。

```sql
UPDATE 社員
SET
    【 a 】 = (
        SELECT 部署コード, 上長社員番号
        FROM 社員
        WHERE 社員番号 = 'E055'
    )
WHERE
    【 b 】 = 'E101';
```

**【回答】**
`a`: `(部署コード, 上長社員番号)`
`b`: `社員番号`

**【この構文が必要な理由】**
関連する複数の列（部署と上長）を、単一のデータソース（先輩社員のレコード）から取得した値で一括更新する必要があるためです。この構文を用いることで、処理が一つの命令で完結するため、複数の`UPDATE`文を発行するよりも効率的かつ安全（アトミック）にデータの一貫性を保ったまま更新できます。

**【構文の解説】**
`SET (列1, 列2, ...) = (サブクエリ)` という形式は「行値コンストラクタ」を利用した更新です。

*   **`SET (部署コード, 上長社員番号)`**: 更新対象となる複数の列をタプル（値の組）として`()`で囲って指定します。
*   **`= (SELECT 部署コード, 上長社員番号 ...)`**: `=`の右辺には、左辺の列リストと「列の数」「順序」「データ型」が一致する**単一行**を返すサブクエリを記述します。このサブクエリが返す値の組が、そのまま左辺の列の組に代入されます。

このSQLは、「社員番号'E055'の部署コードと上長社員番号のペアを取得し、そのペアを社員番号'E101'の行の対応する列にセットする」という処理を一度に行います。


*   **誤-答2**: `SET`句の列リストとサブクエリの列リストの数が一致しない。
    ```sql
    -- 構文エラーになる例
    SET (部署コード, 上長社員番号) = (SELECT 部署コード FROM 社員 WHERE 社員番号 = 'E055')
    ```
    *   **解説**: 左辺では2つの列への代入を期待しているのに対し、右辺のサブクエリは1つの列しか返していません。このように列の数が一致しない場合、SQLは構文エラーとなります。

*   **誤答3**: `SET`句に`()`を付け忘れる。
    ```sql
    -- 構文エラーになる例
    SET 部署コード, 上長社員番号 = (SELECT 部署コード, 上長社員番号 FROM ... )
    ```
    *   **解説**: `(列1, 列2) = (値1, 値2)` という形式は、値の組（タプル）同士を比較・代入するための特殊な構文です。`()`を省略すると、`部署コード`には代入する値がなく、`上長社員番号`にタプルを代入しようとしている、と解釈され構文エラーになります。この`()`が、行値による更新を宣言する重要な記号です。


### 問題（高難易度）★★
ある企業で、優秀な人材の定着を目的とした給与改定案が検討されている。その内容は、「**『部長』職の社員が一人でも存在する部署**に所属している、**『一般』職の社員全員**の基本給を、**その部署内の最高基本給と同じ額まで引き上げる**」というものである。

この複雑な要件を、単一の`UPDATE`文で実現するために、以下のSQL文の空欄を埋めなさい。このSQLは、更新対象行の絞り込みと、更新する値の動的な計算の両方に、相関サブクエリを駆使している。

```sql
UPDATE 社員 S
SET
    基本給 = (
        SELECT MAX(S2.基本給)
        FROM 社員 S2
        WHERE S2.部署コード = 【 a 】
    )
WHERE
    S.役職 = '一般'
    AND 【 b 】 (
        SELECT *
        FROM 社員 S3
        WHERE S3.役職 = '部長' AND 【 c 】
    );
```

**【回答】**
`a`: `S.部署コード`
`b`: `EXISTS`　　★WHEREは、ANDの前にあるので、いらない。AND　EXISTSでOK.
`c`: `S3.部署コード = S.部署コード`　すべてのWHEREで部署コードを結合している。

**【この構文が必要な理由】**
この課題は、「`どの行を更新`するか（更新対象の条件）」と「その行を`何の値で更新するか`（更新値）」が、`どちらも各行が持つデータ（所属部署）に依存`するという二重の複雑さを持っています。
`WHERE`句の相関サブクエリで更新対象行を動的に絞り込み、`SET`句の相関サブクエリで各行に応じた更新値をリアルタイムに算出するために、この構文が不可欠となります。

**【構文の解説】**
このSQLは、`UPDATE`文の中で役割の異なる2つの相関サブクエリを組み合わせています。

1.  **`SET`句の相関サブクエリ（スカラサブクエリ）**:
    *   `SET 基本給 = (SELECT MAX(S2.基本給) ...)`
    *   **役割**: `更新するスカラー値` を算出します。このサブクエリは、外側のクエリで処理中の行（`S`）の部署コードを受け取り、その部署の`最大基本給という単一の値（スカラ値）`を返します。

2.  **`WHERE`句の相関サブクエリ（存在条件の判定）**:
    *   `WHERE ... AND EXISTS (SELECT * ...)`
    *   **役割**: 更新対象とする行か否かを判定します。`EXISTS`は、サブクエリが**1行でも結果を返せば真（True）**、1行も返さなければ偽（False）を返します。ここでは、外側の行（`S`）の部署コードと同じ部署に「部長」が存在するかをチェックしています。`SELECT *` と記述するのが慣例ですが、実際には列の値は見ておらず、条件に合う行の「存在」だけを確認しています。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答1**: `WHERE`句で`EXISTS`の代わりに`IN`を使おうとする。
    ```sql
    -- 誤答例 (b, c)
    ... WHERE S.役職 = '一般' AND S.部署コード IN (SELECT S3.部署コード FROM 社員 S3 WHERE S3.役職 = '部長')
    ```
    *   **解説**: この書き方でも同じ結果を得ることはできます。しかし、`IN`はサブクエリの結果セット（部長がいる部署コードのリスト）を一度すべて作成し、そのリストと外部の行を一つずつ比較します。一方、`EXISTS`は条件に合う行が**最初に見つかった時点**で評価を打ち切るため、一般的にパフォーマンスが良いとされています。特にサブクエリの対象データが大きい場合、この差は顕著になります。AP試験では、この両者の特性の違いが問われることがあります。

*   **誤解/誤答2**: `SET`句のサブクエリが単一の値を返さない可能性に気づかない。
    ```sql
    -- 構文エラーになる例
    ... SET 基本給 = (SELECT 基本給 FROM 社員 S2 WHERE S2.部署コード = S.部署コード AND S2.役職 = '部長')
    ```　MAXでスカラーにしていないので、サブクエリが集合になってしまう。
---


### 問題 ★★〇

「社員」テーブルと「部署」テーブルがあります。以下の5つの要件でデータを取得する場合、それぞれどの結合方法が適切ですか？下のSQL構文の `【 あ 】`～`【 お 】` に入る句を答えなさい。

1.  部署に所属している社員とその部署名の一覧を取得したい。
2.  **すべての**社員を表示し、もし部署に所属していればその部署名も表示したい（未所属者は部署名をNULLで表示）。
3.  **すべての**部署を表示し、もし社員が所属していればその社員名も表示したい（社員がいない部署は社員名をNULLで表示）。
4.  部署に所属していない社員や、社員が一人もいない部署も含め、**すべての**社員と**すべての**部署の情報を一覧で表示したい（対応するデータがない部分はNULLで表示）。
5.  社員と部署で考えられる**すべての組み合わせ**を、所属関係を一切無視して一覧表示したい（いわゆる「総当たり」リスト）。

```sql
-- 要件1: 部署に所属している社員
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 あ 】 部署 AS D ON S.部署コード = D.部署コード;

-- 要件2: 全ての社員を表示
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 い 】 部署 AS D ON S.部署コード = D.部署コード;

-- 要件3: 全ての部署を表示
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 う 】 部署 AS D ON S.部署コード = D.部署コード;

-- 要件4: 全ての社員と部署（所属関係なしはNULL）
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 え 】 部署 AS D ON S.部署コード = D.部署コード;

-- 要件5: 全ての組み合わせ（総当たり）
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 お 】 部署 AS D;

```

**【回答】**
`【 あ 】`: `INNER JOIN`
`【 い 】`: `LEFT JOIN` (または `LEFT OUTER JOIN`)
`【 う 】`: `RIGHT JOIN` (または `RIGHT OUTER JOIN`)
`【 え 】`: `FULL OUTER JOIN`
`【 お 】`: `CROSS JOIN`

**【この構文が必要な理由】**
業務要件に応じて、2つのテーブルから「どの範囲のデータ」を「どのように関連付けて」取得したいかは様々です。`INNER JOIN`は関連があるデータに限定し、`LEFT/RIGHT JOIN`は片方のテーブルを主軸とします。そして `FULL OUTER JOIN`は両方のテーブルの全データを網羅し、`CROSS JOIN`はあらゆる組み合わせを生成します。これらの適切な使い分けは、データ分析やシステム開発において必須のスキルです。

**【構文の解説】**
*   `INNER JOIN` (要件1): 両テーブルに共通のキーが存在するデータのみを結合します。この場合、いずれかの部署に所属している社員のみが結果に現れます。
*   `LEFT JOIN` (要件2): 左テーブル（`社員`）の全データを表示し、右テーブル（`部署`）にON句で指定したキーが一致するデータがあれば結合します。一致しなければ、右テーブル由来の列（部署名）は`NULL`になります。
*   `RIGHT JOIN` (要件3): 右テーブル（`部署`）の全データを表示し、左テーブル（`社員`）に一致データがあれば結合します。社員が一人も所属していない部署も表示され、その場合、左テーブル由来の列（氏名）は`NULL`になります。
*   `FULL OUTER JOIN` (要件4): 両テーブルの全データを表示します。部署に所属していない社員や、社員が一人もいない部署もすべて結果に含まれ、対応するデータがない部分は`NULL`で補完されます。
*   `CROSS JOIN` (要件5): 2つのテーブルの「**直積（デカルト積）**」を求める結合です。結合キー（ON句）は不要で、左テーブルの各行に対して右テーブルの全ての行を組み合わせた結果を返します。社員が3名、部署が4つあれば、3×4=12通りの全組み合わせが生成されます。

---

### 参考：JOINとの違い - 集合演算子 `INTERSECT`

ご質問にあった `INTERSECT` は、テーブルを横に結合する`JOINとは異なる**集合演算子**`です。
`INTERSECT`は、2つの`SELECT`文の結果セットの中から、**両方に共通して存在する行のみ**を返します。

**JOINとの主な違い:**

*   **目的:**
    *   **JOIN**: テーブルを**横に結合**し、関連する列を増やして1つの広いテーブルのように扱います。
    *   **INTERSECT**: 複数の`SELECT`結果（テーブル）から共通の行を抽出し、**縦のデータ（行）を絞り込み**ます。
*   **条件:**
    *   **JOIN**: `ON`句でテーブル間の関連（キー）を指定します。
    *   **INTERSECT**: 2つの`SELECT`文で取得する列の数とデータ型が一致している必要があります。

**使用例:**
「関東支社の社員リスト」と「営業職の社員リスト」という2つの`SELECT`文があった場合、`INTERSECT`を使うと「**関東支社に勤務する営業職の社員**」のリストを取得できます。

```sql
-- 関東支社の社員リスト
SELECT 社員ID, 氏名 FROM 社員 WHERE 支社コード = 'Kanto';
INTERSECT
-- 営業職の社員リスト
SELECT 社員ID, 氏名 FROM 社員 WHERE 職種コード = 'Sales';
```

このように、`JOIN`がテーブル間の「関連」を見るのに対し、`INTERSECT`は結果セット間の「共通部分」を見るという違いがあります。


ＳＱＬにおける「ＩＮＴＥＲＳＥＣＴ」は、２つのＳＥＬＥＣＴ文から「両方に存在するレコード（共通部分）」だけを抽出する集合演算子です。これは論理演算で言う「ＡＮＤ」に似ていますが、用途と意味合いが異なります。[2][3][7]

１　ＩＮＴＥＲＳＥＣＴの特徴
（１）複数のＳＥＬＥＣＴ文の結果セット間で「共通しているもの（積集合）」だけを結果として返します。
（２）各ＳＥＬＥＣＴ文で指定するカラムの数とデータ型は一致している必要があります。
（３）重複行は除外され、ＤＩＳＴＩＮＣＴな結果となります。[3][2]

２　ＡＮＤ演算との違い
（１）「ＡＮＤ」は「１つの行に対して複数条件を同時に満たすか」を評価します（例：ＷＨＥＲＥ句）。
（２）「ＩＮＴＥＲＳＥＣＴ」は「２つの問い合わせ結果の共通部分（重なり）」を返します。

３　図解で表すと
・「ＡＮＤ」：１つのテーブルで条件Ａかつ条件Ｂを満たす行を抽出
・「ＩＮＴＥＲＳＥＣＴ」：テーブルＡの結果セットとテーブルＢの結果セットに共通して含まれるものを抽出
　
類似しているが、実際の用途や文法は大きく異なるため、正確に使い分けてください。[7][2][3]

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `LEFT JOIN`と`RIGHT JOIN`はテーブルの記述順を入れ替えれば同じなので、`LEFT JOIN`だけ覚えればよいと考えてしまう。
*   **解説**: 理論的にはその通りですが、SQLでは主軸となる情報を左側に置く`LEFT JOIN`が好まれる傾向にあり、可読性が高まります。しかし、既存の複雑なクエリを修正する際など、`RIGHT JOIN`のままの方が変更箇所が少なく済む場合もあります。AP試験では、どちらの結合も読んで理解できる必要があります。

### 問題
年末商戦の成果を分析し、特に貢献度の高かった優良顧客をリストアップするよう依頼されました。

**抽出要件**:
1.  分析対象は、**2024年12月の1ヶ月間**の注文データに限定する。
2.  顧客一人ひとりの**購入金額を合計**する。
3.  上記期間中の合計購入金額が、**10万円以上**の顧客のみを抽出する。

```sql
SELECT
    顧客ID,
    SUM(購入金額) AS 12月購入合計
FROM
    注文履歴
【 a 】
    注文日 >= '2024-12-01' AND 注文日 <= '2024-12-31'
【 b 】
    顧客ID
HAVING
    【 c 】 >= 100000;
```

**【回答】**
`a`: `WHERE`
`b`: `GROUP BY`
`c`: `SUM(購入金額)`

**【BETWEENについて】**

以下は等価。
WHERE `注文日` >= '2024-12-01' AND `注文日` <= '2024-12-31'　※注文日を２回使う。

WHERE `注文日` BETWEEN '2024-12-01' AND '2024-12-31'　　　　※注文日は１回のみ



**【SQL文の設計をゼロからやる点について力不足を感じた件】**
ユーザーがおっしゃる「ゼロから設計できない」「SUMする場所が思いつかない」というのは、**SQLの設計手順を体系的に踏めていない**ことが原因です。
穴埋め問題は「部品が揃っている状態」なので、迷子になりにくいのですが、ゼロから組み立てる際は **「分析要件 → 評価順序 → SQL文の各句の役割」** の対応を意識するのがコツです。

## １　アプローチ方法（ゼロから設計する思考手順）

### ステップ（思考の流れ）

1. **出力形式を明確化する**
   → 欲しい結果は「顧客IDごとの購入合計」。
   → `SELECT 顧客ID, SUM(購入金額)` が出発点。まず、出力結果をとらえる。

2. **分析対象の範囲を限定する**
   → 「2024年12月」だけ欲しい。
   → 集計前にデータを削る必要がある → `WHERE 注文日 BETWEEN ...`  出力結果を絞る（時期）

3. **集計の単位を決める**
   → 顧客ごとに集計したい → `GROUP BY 顧客ID`　出力結果を絞る（ごと）

4. **集計結果に条件をかける**
   → 「合計購入金額が10万円以上」 → `HAVING SUM(購入金額) >= 100000`　（金額　別名つけてないので今回はSUM関数そのまんま使う。いかに別名が有効かがわかる。AS　購入合計とすればいいのに）

5. **実行順序を確認**

   * FROM → WHERE（レコード削減）
   * GROUP BY（グループ化）
   * HAVING（集計後の条件判定）
   * SELECT（出力）
   * ORDER BY（並び替えが必要なら最後に）

---

## ２　別解SQL（同一結果）

元のSQLはシンプルで典型的（`SELECT内でSUM関数を使う`）ですが、以下のような別解もあります。
違いは「集計のやり方」を変えても、最終結果は同じになる点です。

### 別解１：サブクエリで先に合計を出す
```sql
SELECT
    顧客ID,
    12月購入合計　※GROUP BYはFROMサブクエリの中でやっている。
FROM
    (
        SELECT
            顧客ID,
            SUM(購入金額) AS 12月購入合計
        FROM
            注文履歴
        WHERE
            注文日 BETWEEN '2024-12-01' AND '2024-12-31'
        GROUP BY
            顧客ID
    ) 集計結果　　※FROMサブクエリには、別名は必須
WHERE
    12月購入合計 >= 100000;
```

* ポイント：`HAVING`を使わず、サブクエリの結果を`WHERE`で判定。
**WHERE 12月購入合計 >= 100000 は、FROMサブクエリの中の別名なので、FROM→WHEREの処理順序に従っているので使える**のである。別名使ったから使えるというわけではない。

* メリット：合計金額を「列」として扱えるため、読みやすい場合がある。
* デメリット：サブクエリの入れ子構造が増えるので冗長。

---

### 別解２：ウィンドウ関数を使う

```sql
SELECT DISTINCT
    顧客ID,
    SUM(購入金額) OVER (PARTITION BY 顧客ID) AS 12月購入合計
FROM
    注文履歴
WHERE
    注文日 BETWEEN '2024-12-01' AND '2024-12-31'
AND
    SUM(購入金額) OVER (PARTITION BY 顧客ID) >= 100000;
```

* ポイント：`SUM() OVER(PARTITION BY)` で顧客単位の合計を「集計列」として出し、`WHERE`で判定。
* メリット：集計しつつ明細レベルも保持できる。分析用途に強い。
* デメリット：SQL初心者にはやや難解。

WHEREは SELECTより前に評価されるので、「12月購入合計」という別名はまだ存在していない。
したがって、WHEREでは冗長に SUM(...) OVER(...) をもう一度書かざるを得ません。
これは`ウィンドウ関数特有の「美しくないポイント」`です。

---
## ３　新しい穴埋め問題（別解を利用）

### 問題（サブクエリ版）
2024年12月に合計購入金額が10万円以上の顧客を抽出する。
ただし、**サブクエリで集計した結果に対して条件を適用する方法**でSQLを完成させよ。

```sql
SELECT
    顧客ID,
    12月購入合計
FROM
    (
        SELECT
            顧客ID,
            【 a 】 AS 12月購入合計
        FROM
            注文履歴
        【 b 】
            注文日 BETWEEN '2024-12-01' AND '2024-12-31'
        【 c 】
            顧客ID
    ) 集計結果
【 d 】
    12月購入合計 >= 100000;
```

**【回答】**

* a: `SUM(購入金額)`
* b: `WHERE`
* c: `GROUP BY`
* d: `WHERE`

---

✅ ポイントは、「SUMする場所をどう決めるか？」の発想です。
これは **「出力要件を見て → 集計単位を決め → SQLの実行順序に落とす」** という型を覚えれば、毎回応用できます。
12月購入合計 >= 100000; これは、FROMが先に処理して別名つけているから使える。だからスマート。
---

---
#　問題その１★
「社員」テーブルから社員一覧を出す際に、`備考`列が`NULL`の場合は「特記事項なし」と表示し、かつ`役職コード`に応じて役職名を日本語で表示したい（'MGR'なら「部長職」、'TL'なら「チームリーダー」、それ以外は「一般職」）。

```sql
SELECT
    氏名,
    【 a 　　　　　 】
        WHEN 'MGR' THEN '部長職'
        WHEN 'TL'  THEN 'チームリーダー'
        【 b 】 '一般職'
    【 c 】 AS 役職名,
    【 d 】(備考, '特記事項なし') AS 備考欄
FROM
    社員;
```

**【回答】**
`a`: CASE 役職コード　★CASEは、SELECTに直入可能。
`b`: ELSE
`c`: END
`d`: COALESCE

**【この構文が必要な理由】**
`CASE`式は、SQL内で条件分岐ロジックを実現し、データを変換・分類するために不可欠です。
しかも、SELECTに直接入れられる。
`COALESCE`関数は、`NULL`値を別の値に置き換えるためのシンプルで方法であり、表示や計算で`NULL`が原因となる問題を回避するために頻繁に使用されます。

**【構文の解説】**
*   `CASE WHEN 条件 THEN 値 ... ELSE 値 END`: 一連の条件を評価し、最初に真となった条件に対応する値を返します。
*   `COALESCE(値1, 値2, ...)`: 引数リストの中で最初に見つかった`NULL`でない値を返します。`IFNULL`や`NVL`といった各DBMS固有の関数の標準SQL版です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `CASE`式で`ELSE`句を省略してしまう。
*   **解説**: `ELSE`句を省略した場合、どの`WHEN`条件にも一致しない行は`NULL`が返されます。これが意図した動作であれば問題ありませんが、意図せず`NULL`が生まれると後続の計算に影響を与える可能性があります。必ずデフォルトの値を`ELSE`で指定する癖をつけることが堅牢なクエリ作成に繋がります。


# 問題その２　★★
 上記と同じ結果となるように空欄を埋めよ。
 なお、上記は、単純 CASE 式（属性あり）。今回は、検索CASE式（属性なし）

```sql
SELECT
    氏名,
    CASE
        WHEN 【 a 】 THEN '部長職'
        WHEN 【 b 】 THEN 'チームリーダー'
        WHEN 【 c 】 THEN 'ベテラン職'
        ELSE '一般職'
    END AS 役職名
FROM 社員;

```
**回答**
a: 役職コード = 'MGR'
b: 役職コード = 'TL'
c: 勤続年数 >= 10

このように「検索 CASE 式」では、WHENの後に書く条件式が自由に変えられるのがポイントです。 列名だけでなく、数値比較や複数列の組み合わせも使えるため、柔軟なロジックが組めます。

---

## 問題
一度でも商品を購入したことがある顧客の情報だけを「顧客マスタ」から抽出したい。また、逆に、まだ一度も購入履歴がない顧客を抽出したい。
さらに、サブクエリは、メインクエリの何を読み込んでいるのか答えよ。

```sql
-- ① 購入履歴のある顧客
SELECT 氏名 FROM 顧客マスタ AS C
WHERE 【 a 】 (SELECT【 c 】 FROM 購入履歴 AS H WHERE H.顧客ID = C.顧客ID);

-- ② 購入履歴のない顧客
SELECT 氏名 FROM 顧客マスタ AS C
WHERE 【 b 】 (SELECT【 c 】FROM 購入履歴 AS H WHERE H.顧客ID = C.顧客ID);

```
**【回答】**
`a`: EXISTS
`b`: NOT EXISTS
 c : 1
`追加問題`：`C.顧客ID`　※まず、根拠のFROMが違う（相関サブクエリ）。そして、読んでいるのは、サブクエリ内の属性。

**【この構文が必要な理由】**
`EXISTS`は「関連データが一件でも存在するか」という事実だけを確認したい場合に、最も効率的な手段です。サブクエリの結果をすべて取得して比較する`IN`句と異なり、`EXISTS`は該当データが一件見つかった時点で評価を打ち切るため、特にサブクエリの対象テーブルが大きい場合にパフォーマンスが向上します。

**【構文の解説】**
*   `EXISTS (相関サブクエリ)`: サブクエリが1行でも結果を返せば真 (TRUE) となります。
*   `NOT EXISTS (相関サブクエリ)`: サブクエリが1行も結果を返さなければ真 (TRUE) となります。
*   **相関サブクエリ**: サブクエリの中から主問合せのテーブル（`C.顧客ID`）を参照する形式。主問合せの行ごとにサブクエリが実行されるイメージです。

---
## 【問題】 ★★
各部署の売上合計と全社平均売上を比較するレポートを作成する。以下のSQL文の空欄 `【 a 】` ～ `【 e 】` に適切な語句を補充してください。

```sql
【 a 】
部署別売上 AS (
    SELECT 部署コード, SUM(売上額) AS 合計売上
    FROM 売上実績
    【 b 】 部署コード
),
全社平均 AS (
    SELECT 【 c 】(売上額) AS 平均売上 FROM 売上実績
)
SELECT
    D.部署名,
    B.合計売上,
    A.平均売上
FROM
    部署別売上 AS B
【 d 】 部署マスタ AS D ON B.部署コード = D.部署コード
【 e 】 全社平均 AS A;
```

## 【回答】
- `a`: WITH
- `b`: GROUP BY
- `c`: AVG
- `d`: JOIN
- `e`: CROSS JOIN

## 【解説】
## １　WITH句の基本構文
WITH句（共通表式）は、メインのSELECT文の前に一時的な結果セットを定義する構文です。構文は以下のとおりです。
```
WITH CTE名１ AS (SELECT文１),
     CTE名２ AS (SELECT文２)
メインのSELECT文
```
定義したCTEは、後続のクエリで通常のテーブルと同様に参照できます。

## ２　各要素の役割
### AVG関数の役割
AVG関数は、指定した列の平均値を算出する集計関数です。`NULL値は計算から除外されます`。

### CROSS JOINの役割
## 理由１　コピー装置としての役割
... JOIN 部署マスタ D ON ...
CROSS JOIN 全社平均 A;

→ Aの1行を すべての行にコピーする。
✅ まとめると
全社平均は 平均売上の1行しかない。
「部署ごと」に比較するためには、その1行（平均売上）を全ての行に「コピー」する必要がある。
`その一行の「コピー装置」`として `CROSS JOIN` が必要。

| 部署名 | 合計売上 | 平均売上 |
| --- | ---- | ---- |
| 営業部 | 300  | 250  |
| 開発部 | 300  | 250  |
| 管理部 | 400  | 250  |


## CROSS JOINがないと、平均売上のSELECTに入る権利がなくなる
SQLの基本ルール
SELECT 句に書ける項目は、FROM 句で参照した表に含まれている属性だけ。
つまり FROM に出ていない表（CTE含む）の列は参照できない。
CROSS　JOINがないと、FROM に 全社平均 AS A が出てこないので、A.平均売上 を参照する権利がない。

```sql
SELECT
    D.部署名,
    B.合計売上,
    A.平均売上   -- ← ここでエラー！
FROM 部署別売上 AS B
JOIN 部署マスタ AS D
  ON B.部署コード = D.部署コード;
  ※CROSS JOINがないので、FROMに入らない＝SELECTに入る権利なし。
```


## ２　CROSS JOINの本質的特徴
### ２－１　デカルト積の生成
CROSS JOINは、左側テーブルのすべての行と右側テーブルのすべての行を組み合わせます。数学的にはデカルト積と呼ばれる演算です。
### ２－２　結合条件の不要性
他の結合方法（INNER JOIN、LEFT JOIN等）とは異なり、ON句やWHERE句による結合条件を指定しません。

---
#### 問題 ★★
「社員」テーブルに、新しく`メールアドレス`列を追加する必要が出てきました。この列には重複した値を許可しないようにしたい。また、個人情報保護のため、人事部のユーザにのみ基本給情報を公開し、他のユーザには氏名と部署名だけを閲覧できる`社員公開ビュー`を提供したい。

```sql
-- ① 列の追加と制約の付与
【 a 】 社員
【 b 】 メールアドレス VARCHAR(255) 【 c 】;

-- ② ビューの作成
【 d 】 社員公開ビュー AS
SELECT
    氏名, 部署名
FROM
    社員 S
INNER JOIN
    部署 D ON S.部署コード = D.部署コード;
```

**【回答】**
`a`: ALTER TABLE
`b`: ADD COLUMN
`c`: UNIQUE
`d`: CREATE VIEW

**【この構文が必要な理由】**
`ALTER TABLE`は、稼働中のデータベースの構造を変更するために必要です。
`CREATE VIEW`は、複雑なクエリを単純化したり、元テーブルへのアクセスを制限してセキュリティを向上させたりするための仮想テーブル機能です。

**【構文の解説】**
*   `ALTER TABLE テーブル名 ADD COLUMN 列定義 [制約];`: 既存のテーブルに新しい列を追加します。
*   `UNIQUE制約`: 列内の値の重複を許しませんが、`NULL`は複数許容される場合があります（DBMSによる）。主キー(`PRIMARY KEY`)もユニークですが、`NULL`を許可しない点が異なります。
*   `CREATE VIEW ビュー名 AS SELECT文（サブクエリではない！！！！）;`:★ `SELECT`文の結果を名前付きのオブジェクト（ビュー）として保存します。ビューに対してクエリを実行すると、裏で定義された`SELECT`文が実行されます。


---

##### VIEWとCTEの連続定義の違い

`VIEW`と`CTE`（Common Table Expression）は、どちらもSQLクエリ内で名前付きの結果セットを作成するために使用されますが、その定義方法、特に連続して定義する際の構文に大きな違いがあります。

### 1. VIEWの定義

VIEWは、**1つの `CREATE VIEW` 文で1つのビューしか定義できません。**

#### SQL例
```sql
CREATE VIEW ビュー1 AS SELECT * FROM 社員;
CREATE VIEW ビュー2 AS SELECT * FROM 部署;
```

#### ポイント
*   `CREATE VIEW` は1文で完結します。
*   複数のビューを作成する場合、文の区切りであるセミコロン（`;`）で区切って、それぞれ独立した文として実行する必要があります。
*   構文上、1つの `CREATE VIEW` 文に複数の `SELECT` を含めることはできないため、連続定義は不可能です。
*   `その代わり、文法的には、;で区切られていることが分かるので（）は不要となるので注意`　★
---

### 2. CTEの定義

CTEは、**1つの `WITH` 句の中でカンマ（`,`）で区切ることで、複数のCTEを連続して定義できます。**

#### SQL例
```sql
WITH A AS (
    SELECT * FROM 社員
), B AS (
    SELECT * FROM 部署
)
SELECT * FROM A JOIN B ON A.部署ID = B.部署ID;
```

#### ポイント
*   1つの `WITH` 句の中で、複数のCTEを定義することが可能です。
*   各CTEの範囲（どこからどこまでが一つの定義か）を明確にするために、`AS` の後を括弧 `()` で囲むことが必須です。

---

### 3. 直感的なイメージと比較

| | VIEW | CTE |
| :--- | :--- | :--- |
| **構文** | `CREATE VIEW 1 AS SELECT ...` | `WITH A AS (SELECT ...),`<br>`     B AS (SELECT ...)` |
| **定義の単位** | 1文につき1つの定義のみ | 1文の中で複数の定義が可能 |
| **括弧の要否** | 範囲が明らかなので **不要** | 範囲を明示するために **必須** |

---

### 💡 まとめ：なぜ括弧の有無が違うのか？

括弧が必要かどうかは、 **「1つの文で複数の定義が可能かどうか」** という本質的な違いに基づいています。

*   **VIEW**: 「1文1定義」というルールがあるため、範囲を区切る必要がなく、括弧は不要です。
*   **CTE**: 「1文で複数定義可能」なため、それぞれのCTEの範囲をSQLに正確に伝えるための括弧が必須となります。




### 問題
営業部のリーダーBさんが部下の勤怠データを参照したり、遅刻理由などを追記・修正したり、新たに入力したりできるように、システム管理者が「勤怠管理テーブル」に対する必要な権限を一度に付与します。

以下のSQL文を完成させてください。

```sql
-- リーダーBさんに、「勤怠管理テーブル」への参照、追加、更新の権限を与える
GRANT 【 a 】 【 b 】 【 c 】 TO Bさん;
```

**【回答】**
`a`: `SELECT, INSERT, UPDATE`
`b`: `ON`
`c`: `勤怠管理テーブル`


**【この構文が必要な理由】**
特定のユーザの役割に応じて、データベース上の特定テーブルに対する複数の操作（参照、追加、更新など）をまとめて許可し、効率的かつ安全にデータアクセスを制御するために必要です。

**【構文の解説】**
`GRANT`文は、データベースのオブジェクト（テーブル、ビューなど）に対する操作権限をユーザに与えるための命令です。

`GRANT [権限の種類] ON [オブジェクト名`テーブル名`や`ビュー名`] TO [ユーザ名またはロール名];`

*   `GRANT`: 権限を与えることを宣言します。
*   `権限の種類`:
    *   `SELECT`: データを参照する権限。
    *   `INSERT`: 新しいデータを追加する権限。
    *   `UPDATE`: 既存のデータを更新する権限。
    *   `DELETE`: データを削除する権限。
    *   複数の権限を与える場合は、今回のようにカンマ（`,`）で区切って列挙します。
*   `ON オブジェクト名`: `ON`キーワードに続けて、権限を付与する対象の`テーブル名`や`ビュー名`を指定します。
*   `TO ユーザ名`: 権限を与えられるユーザを指定します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**:カンマが抜ける。 `GRANT SELECT UPDATE INSERT ON ...` のように、複数の権限をスペース区切りで指定してしまう。
*   **解説**: 複数の権限を一度に指定する場合は、必ずカンマ(`,`)で区切る必要があります。


#### 問題 ★
新入社員のユーザ`'user_trainee'`を作成しました。このユーザに、`社員公開ビュー`に対する参照（`SELECT`）権限を与えたい。その後、このユーザが研修を終えたため、その権限を剥奪する必要が出てきました。

```sql
-- ① 権限の付与
【 a 】 SELECT
【 b 】 社員公開ビュー
【 c 】 'user_trainee';

-- ② 権限の剥奪
【 d 】 SELECT
【 b 】 社員公開ビュー
【 e 】'user_trainee';
```
**【回答】**
`a`: GRANT
`b`: ON　★権限付与もはく奪もON
`c`: TO
`d`: REVOKE
`e`: FROM
**【この構文が必要な理由】**
`GRANT`と`REVOKE`は、データベースのセキュリティを管理する中心的な命令（DCL: Data Control Language）です。

**【構文の解説】**
*   `GRANT 権限 ON オブジェクト TO ユーザ;`: ユーザにオブジェクト（テーブル、ビューなど）に対する操作権限（`SELECT`, `INSERT`, `UPDATE`など）を与えます。
*   `REVOKE 権限 ON オブジェクト FROM ユーザ;`: ユーザから指定した権限を剥奪します。

---
### 問題
上司から「特定の社員（社員ID 'E005'）が所属する部署と、その部署より上位の階層にある部署をすべてリストアップしてほしい」と依頼されました。

社員テーブルと部署テーブルを使い、社員 'E005' が所属する「開発2部」からルートの「社長室」まで、階層を遡って表示する必要があります。このような親子関係を持つデータを再帰的に検索するには、どのSQL構文を使えばよいか。

```sql
【 a 】 部署階層(部署ID, 部署名, 上位部署ID) AS (
  SELECT 部署ID, 部署名, 上位部署ID FROM 部署マスタ
  WHERE 部署ID = (SELECT 所属部署ID FROM 社員 WHERE 社員ID = 'E005')

  【 b 】

  SELECT D.部署ID, D.部署名, D.上位部署ID
  FROM 部署マスタ D
  JOIN 部署階層 H ON D.部署ID = H.上位部署ID
)
SELECT 部署名 FROM 部署階層;
```
**【回答】**
`a`: `WITH RECURSIVE`
`b`: `UNION ALL`
**【この構文が必要な理由】**
組織図のような階層構造を持つデータに対して、ある地点から最上位（または最下位）までの全階層を一度のクエリで取得する必要があるため、自己参照を繰り返す再帰的な問い合わせ構文が不可欠です。

**【構文の解説】**
`WITH RECURSIVE <CTE名>(<列リスト>) AS ( <アンカーメンバー> UNION ALL <再帰メンバー> ) SELECT ... FROM <CTE名>;`
*   `WITH RECURSIVE`: 以降で再帰的な共通テーブル式（CTE: Common Table Expression）を定義することを宣言します。
*   **アンカーメンバー**: 再帰検索の開始点となる最初の`SELECT`文です。
*   `UNION ALL`: アンカーメンバーの結果と、後続の再帰メンバーの結果を結合します。**再帰処理では重複を気にする必要がないケースが多い** ため、パフォーマンス上有利な`UNION ALL`が主に使われます。
*   **再帰メンバー**: 直前の`SELECT`文の結果（この例では`部署階層`）を参照して、次の階層のデータを取得します。この処理が結果を返さなくなるまで繰り返されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `JOIN`を何度も繰り返せば同じことができると考えてしまう。
*   **解説**: 階層の深さが事前に分かっている（例：3階層固定）場合は、自己結合（`JOIN`）を繰り返すことでも実現可能です。しかし、階層の深さが可変であったり、不定である場合には対応できません。`WITH RECURSIVE`は、階層の深さに関わらず、終点に達するまで自動的に検索を繰り返してくれる点で根本的に異なります。

---
### 問題
 全社員の一覧を作成するにあたり、まだどの部署にも正式配属されていない研修中の社員（所属部署IDが`NULL`）もリストに含める必要があります。社員テーブルを主軸として、部署名も合わせて表示するには、どの結合方法が適切でしょうか。

```sql
SELECT
  S.氏名, D.部署名
FROM
  社員 S
【 a 】
  部署マスタ D
ON
  S.所属部署ID = D.部署ID;

```
**【回答】**
`a`: `LEFT OUTER JOIN`
**【この構文が必要な理由】**
「社員」という主軸となるテーブルのデータはすべて表示し、それに関連する「部署」の情報があれば表示し、なければ`NULL`としてでも表示したい、という要件を満たす必要があるためです。

**【構文の解説】**
`SELECT ... FROM <左テーブル> LEFT OUTER JOIN <右テーブル> ON <結合条件>;`
*   `LEFT OUTER JOIN` (または `LEFT JOIN`): 左外部結合を指示する句です。`FROM`句の直後に書かれたテーブル（左テーブル）の行をすべて残し、`ON`句の条件に一致する右テーブルの行を結合します。一致する行が右テーブルにない場合は、右テーブルの列は`NULL`として表示されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `INNER JOIN`を使ってしまう。
*   **解説**:
 `INNER JOIN`を使うと、両方のテーブルに結合キー（この場合は部署ID）が存在するレコード、つまり、いずれかの部署に所属している社員しか抽出されません。要件である「まだ配属されていない社員もリストに含める」を満たせず、データが欠落してしまいます。「～を基準に」「～はすべて表示して」といった要件がある場合は、`OUTER JOIN`を疑う必要があります。
❌ この設題で、`FULL OUTER JOIN`が不適な理由
`FULL OUTER JOIN`は「社員に対応する部署がない」だけでなく、「部署に対応する社員がいない」ケースも含めてしまいます。つまり、**部署マスタに存在するが、誰も所属していない部署も結果に含まれてしまい**、社員一覧としては不要な行が混入します。`社員がNULLも含まれる。`

### 問題
 アパレルECサイトで、取り扱う全ての色（`色マスタ`テーブル）と全てのサイズ（`サイズマスタ`テーブル）の組み合わせを網羅した商品マスタの雛形を一度に生成したい、という依頼がありました。考えられるすべての組み合わせを作成するには、どの結合方法を使用しますか。

```sql
SELECT
  C.色名, S.サイズ名
FROM
  色マスタ C
【 a 】
  サイズマスタ S;
```
**【回答】**
`a`: `CROSS JOIN`
**【この構文が必要な理由】**
2つのテーブル間に直接的な関連（キー）は無いものの、それぞれのテーブルの全レコードを総当たりで組み合わせて、考えられるすべてのパターンのリストを作成する必要があるためです。

**【構文の解説】**
`SELECT ... FROM <テーブル1> CROSS JOIN <テーブル2>;`
*   `CROSS JOIN`: 交差結合（またはデカルト積）を行うための句です。テーブル1の各行に対して、テーブル2のすべての行を組み合わせた結果を返します。**通常、`ON`句による結合条件は指定しません**。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `FROM 色マスタ, サイズマスタ` のようにカンマでテーブルを区切って記述してしまう。
*   **解説**: このカンマ区切りの記法でも多くのデータベースで`CROSS JOIN`と同じ結果が得られますが、これは古いANSI SQL-89標準の書き方です。ANSI SQL-92以降では`CROSS JOIN`というキーワードで明示的に意図を示すことが推奨されています。また、 `FROM 色マスタ, サイズマスタ`を`INNER JOIN`のつもりで`WHERE`句の結合条件を書き忘れると、意図せず`CROSS JOIN`となり、膨大な数のレコードが生成されてシステムに負荷をかける原因となるため、結合の種類を明示することが重要です。
---

### 問題
 「東京本社」と「大阪支社」に勤務する全社員の社員番号を、重複を除いて一つのリストとして表示したいと考えています。それぞれの社員リストを取得する2つの`SELECT`文の結果を、1つに統合するにはどの集合演算子を使えばよいか。

```sql
SELECT 社員番号 FROM 社員 WHERE 勤務地 = '東京本社'
【 a 】
SELECT 社員番号 FROM 社員 WHERE 勤務地 = '大阪支社';
```
**【回答】**
`a`: `UNION`
**【この構文が必要な理由】**
2つ以上の別々の条件で抽出した結果セットを、1つの結果セットとして縦に連結する必要があるためです。特に、両方の条件に合致するデータ（例：兼務者）が存在する場合でも、結果としては1件として扱いたい（重複を排除したい）という要件を満たします。

**【構文の解説】**
`SELECT ... FROM ... UNION SELECT ... FROM ...;`
*   `UNION`: 2つ以上の`SELECT`文の結果を結合するための集合演算子です。結合する際、自動的に結果セット全体から重複する行を取り除きます。
*   **注意**: `UNION`で結合する各`SELECT`文は、列の数と、対応する列のデータ型が一致している必要があります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: パフォーマンスを考えずに、常に`UNION`を使ってしまう。
*   **解説**: `UNION`は重複を排除するために、内部的にソート処理のような負荷のかかる処理を実行します。もし「重複があっても構わない、単純に結果を連結したいだけ」という要件であれば、重複排除を行わない `UNION ALL` を使うべきです。`UNION ALL`の方が高速に動作するため、要件に応じて適切に使い分けることが重要です。

---
### 問題
 ECサイトの売上ログを分析しています。4月度の売上履歴（`売上履歴_4月`テーブル）と5月度の売上履歴（`売上履歴_5月`テーブル）を連結して一つの時系列データとして扱いたいと考えています。
このような場合に、2つの`SELECT`文の結果を高速に結合するには、どの集合演算子を使えばよいか。

```sql
SELECT 注文日, 商品ID, 金額 FROM 売上履歴_4月
【 a 】
SELECT 注文日, 商品ID, 金額 FROM 売上履歴_5月;
```
**【回答】**
`a`: `UNION ALL`
**【この構文が必要な理由】**
複数のテーブルや`SELECT`文の結果を、重複排除の処理を行わずに、そのまま高速に連結したい場合に最適だからです。ログデータのように、もともと重複という概念がない（あるいは重複していても問題ない）データを単純にまとめる際に使用されます。

**【構文の解説】**
`SELECT ... FROM ... UNION ALL SELECT ... FROM ...;`
*   `UNION ALL`: 2つ以上の`SELECT`文の結果を結合するための集合演算子です。`UNION`とは異なり、重複行の排除を行わず、すべての行をそのまま返します。そのため、`UNION`よりも処理負荷が低く、高速に動作します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `UNION`と`UNION ALL`は同じものだと思い、`UNION`を使ってしまう。
*   **解説**: 「重複を排除するかしないか」という明確な違いがあります。要件が「ユニークな一覧が欲しい」のであれば`UNION`、「すべてのデータを単純に連結したい」のであれば`UNION ALL`です。
---
はい、承知いたしました。
経験豊富なSQL教育のプロフェッショナルとして、【入力データ】で与えられたSQLの穴埋め問題を、【厳格なルール】に則って高品質な応用問題に作り直します。

---

### **問題** ★★
商品カテゴリごとに売上実績を多角的に評価するため、カテゴリ内での各商品の売上ランキングと、カテゴリ全体に占める売上構成比（%）を算出する。

```sql
[ 1 ] 商品別売上 AS (
  SELECT
    p.商品カテゴリ,   p.商品名,  SUM(s.金額) AS 商品別合計売上
  FROM
    売上明細 s
  INNER JOIN
    商品マスタ p ON s.商品ID = p.商品ID
  [ 2 ]
    p.商品カテゴリ,  p.商品名
)
SELECT
  商品カテゴリ, 商品名, 商品別合計売上,
  RANK() OVER ( [ 3 ] 商品カテゴリ ORDER BY 商品別合計売上 DESC ) AS カテゴリ内順位,
  [ 4 ]
    WHEN RANK() OVER ( PARTITION BY 商品カテゴリ [ 5 ] 商品別合計売上 DESC ) <= 3 THEN 'トップ3'
    ELSE '圏外'
  END AS ランク評価,
  (商品別合計売上 * 100.0 / SUM(商品別合計売上) OVER ( [ 6 ] 商品カテゴリ )) AS 構成比率
FROM
  商品別売上
[ 7 ]
  商品カテゴリ,
  [ 8 ];
```

### **解答**
1.  `WITH`
2.  `GROUP BY`
3.  `PARTITION BY`
4.  `CASE`
5.  `ORDER BY`
6.  `PARTITION BY`★ウィンドウ関数の中で GROUP BY を使うことはありません。下、解説付けたのでよめ。
7.  `ORDER BY`　★GROUPBYを入れてミス。下、解説付けたのでよめ。
8.  `カテゴリ内順位`★なんで？これが出てくるのか分らんて。

### **解説**
このクエリは、`WITH`句、ウィンドウ関数、`CASE`式を組み合わせることで、複雑な要件に対応しています。

*   **クエリ全体の目的**
    商品カテゴリという大きな枠組みの中で、個々の商品がどのような位置づけにあるのかを「ランキング」と「構成比」という2つの指標で明らかにします。これにより、カテゴリの売上を牽引している主力商品や、貢献度の低い商品を特定できます。

*   **構文のポイント**
    1.  **`WITH`句（共通テーブル式）:**
        クエリの可読性と再利用性を高めるために使用します。最初に商品ごとの合計売上を`商品別売上`という名前で事前に集計しておくことで、メインの`SELECT`文が複雑になるのを防いでいます。

    2.  **ウィンドウ関数 (`RANK() OVER`, `SUM() OVER`)**
        `GROUP BY`句がデータを集約して行数を減らすのに対し、ウィンドウ関数は元の行数を維持したまま集計や順位付けができます。
        *   `RANK() OVER ( PARTITION BY 商品カテゴリ ... )` の部分では、`PARTITION BY`句によって商品カテゴリのグループごとに行を区切り、その中で売上順にランキングを付けています。これがカテゴリ内ランキングを実現する核心部分です。
        *   構成比率の計算でも`SUM(...) OVER ( PARTITION BY ... )` を使用し、カテゴリごとの合計売上を各行に付与しています。

    3.  **`CASE`式**
        `RANK()`関数で算出した順位を基に、「トップ3」か「圏外」かというラベルを動的に生成しています。これにより、分析結果の解釈が容易になります。

*   **初心者がつまずきやすい点**
    `GROUP BY`による集計と、`PARTITION BY`を使ったウィンドウ関数の違いを理解することが最初の関門です。
    Ⅰ `GROUP BY`は「`要約（カテゴリ別に区分け）`」、ウィンドウ関数は「`元のデータ（商品名はそのまま）への注釈付け`」とイメージすると区別しやすくなります。
    Ⅱ また、`ORDER BY`がクエリの最後に記述される通常のソートだけでなく、`ウィンドウ関数内でも順序付けのために使われる`点を理解することが重要です。
---
### Ⅰ「要約」のGROUP BY、「注釈付け」のウィンドウ関数

この2つの最大の違いは、**「元のデータの行をどう扱うか」**という点にあります。

#### 1. `GROUP BY`句：データをグループに「要約」する【重要：不可逆な変更】

`GROUP BY`は、指定した列の値が同じ行を1つのグループにまとめ、そのグループに対して1つの結果（合計、平均、件数など）を返します。結果として、**`元のデータの行数は減り【重要：不可逆な変更】`、要約された情報だけが残ります**。

**具体例：カテゴリごとの合計売上を出す**

| 商品名 | 商品カテゴリ | 金額 |
| りんご | 果物 | 100 |
| みかん | 果物 | 80 |
| キャベツ | 野菜 | 150 |
| 牛乳 | 飲料 | 200 |
| オレンジジュース | 飲料 | 120 |

このデータに `GROUP BY 商品カテゴリ` を使うと、以下のようになります。

```sql
SELECT  商品カテゴリ, SUM(金額) AS カテゴリ別合計
FROM  売上テーブル
GROUP BY  商品カテゴリ;
```
**【結果】**
| 商品カテゴリ | カテゴリ別合計 |
| 果物        | 180 |
| 野菜        | 150 |
| 飲料        | 320 |

**ポイント：**
見ての通り、元の5行のデータが3行に**要約**されました。「りんごが100円だった」という`個別の情報は消え`、「果物カテゴリの合計は180円」という集約された情報だけが残ります。これが「要約」というイメージです。

---
#### 2. ウィンドウ関数：元のデータに「注釈付け」をする

ウィンドウ関数は、`GROUP BY`のように行をまとめることはしません。**元のデータの各行はそのまま保持**し、それに対して追加の情報（`順位、グループ内合計など）を新しい列として付与`します。【なんということでしょう。知らんかった★】

`PARTITION BY`は、ウィンドウ関数が計算を行う「範囲（窓）」を指定する役割です。

**具体例：各商品の売上が、そのカテゴリ全体でいくらなのかを併記する**

先ほどと同じ元のデータを使います。

```sql
SELECT
  商品名, 商品カテゴリ, 金額, `SUM(金額) OVER (PARTITION BY 商品カテゴリ) AS カテゴリ別合計`
FROM
 売上テーブル;
```

**【結果】**
★
SELECTの中に、`SUM(金額) OVER (PARTITION BY 商品カテゴリ) AS カテゴリ別合計`が入れたことによって、「カテゴリ別集計」列ができて、かつ、カテゴリ別の集計が各行に入っている。
これが、ウィンドウ関数の力であり、「注釈」と呼ばれるゆえんである。

| 商品名 | 商品カテゴリ | 金額 | カテゴリ別合計★ |　`見ろ！これがPARTITION BYの力である！`　
| りんご | 果物 | 100 | **180** |
| みかん | 果物 | 80 | **180** |
| キャベツ | 野菜 | 150 | **150** |
| 牛乳 | 飲料 | 200 | **320** |
| オレンジジュース | 飲料 | 120 | **320** |

**ポイント：**
元の5行のデータは、1行も減っていません。`個々の商品の売上情報はすべて残っています`。その上で、`PARTITION BY`で区切られた「果物」「野菜」「飲料」の`各グループ（パーティション）の合計金額が、新しい列「カテゴリ別合計」として**注釈のように追加**`されています。これが「注釈付け」のイメージです。素晴らしい。泣きそうだ。

---
### Ⅱ `ORDER BY`の2つの顔： 「全体の整列」と「関数内の順序付け」★

`ORDER BY`は記述される場所によって、その役割が全く異なります。

#### １　クエリの最後に書く `ORDER BY`：最終結果の「全体の整列」

これは最も一般的な使い方で、`SELECT`文で得られた**最終的な結果セット全体**を、指定したルールで並べ替えるために使います。クエリの実行順序としては一番最後に行われる「仕上げ」の処理です。

```sql
-- ...（前略）...
ORDER BY
  商品カテゴリ,  -- まず商品カテゴリで並び替え
  金額 DESC;     -- カテゴリが同じなら金額の降順で並び替え
```
この`ORDER BY`は、出力される表全体の見た目を整える役割です。★よくわからん。

#### 2. ウィンドウ関数内に書く `ORDER BY`：「関数内の順序付け」

`RANK()`や`ROW_NUMBER()`のような順序付けを行うウィンドウ関数の中で使われる`ORDER BY`は、その**関数が計算を行うための順序**を定義します。「何順でランキングをつけますか？」という指示の役割です。

この`ORDER BY`は、**最終的な結果全体の表示順を決定するものではありません**。

```sql
RANK() OVER ( PARTITION BY 商品カテゴリ ORDER BY 金額 DESC ) AS カテゴリ内順位　
```

この例では、`ORDER BY 金額 DESC`は、`RANK()`関数に対して「`PARTITION BY`で区切られたカテゴリの中で、金額の大きい順に順位を計算してください」と指示しています。あくまで`RANK()`関数の計算ロジックの一部であり、これによって表全体の並び順が変わるわけではありません。

もし最終的な表示順も整えたい場合は、別途、クエリの最後に`ORDER BY`句を記述する必要があります。

---
### 問題
 社員名簿に、各社員の給与が全社内で何位にあたるのかを示す「給与ランキング」列を追加して表示したいと考えています。`GROUP BY`のように行をまとめることなく、各行に対してランキングを計算するには、どのような関数を使えばよいか。

```sql
SELECT
  氏名,
  給与,
  RANK() 【 a 】 (ORDER BY 給与 DESC) AS 給与ランキング
FROM
  社員;
```
**【回答】**
`a`: `OVER`
承知いたしました。ご提示の【入力データ】と【厳格なルール】に基づき、SQL中級者以上が応用知識を試せるよう、高品質なSQL穴埋め問題を作成します。

---

### **問題**★★
各部署内で、役職者（部長・課長）とそれ以外の一般社員を区別し、それぞれのグループ内における給与ランキングを算出してください。

### **SQLクエリ**
```sql
[ 1 ] 社員情報 AS (
  SELECT s.氏名, d.部署名, p.役職名, k.給与
  FROM  社員マスタ AS s
    [ 2 ] 部署マスタ AS d
      ON s.部署ID = d.部署ID
    INNER JOIN 給与テーブル AS k
      ON s.社員ID = k.社員ID
    [ 3 ] 役職マスタ AS p
      ON s.役職コード = p.役職コード
)
SELECT  氏名,  部署名,  役職名,  給与,
  [ 4 ]
    [ 5 ] 役職名 IN ('部長', '課長') THEN '役職者'
    ELSE '一般社員'
  END AS 役職グループ,
  RANK() OVER (
    [ 6 ] 部署名,
    CASE
      WHEN 役職名 IN ('部長', '課長') THEN '役職者'
      ELSE '一般社員'
    END
    [ 7 ] 給与 DESC
  ) AS 部署内グループランキング
[ 8 ]
  社員情報
[ 9 ]
  部署名,  部署内グループランキング;
```

### **解答**
1.  `WITH`
2.  `INNER JOIN`
3.  `INNER JOIN`
4.  `CASE`
5.  `WHEN`
6.  `PARTITION BY`
7.  `ORDER BY`
8.  `FROM`　★WITHがFROMをまとめている。FROMが無いことにも気づけ。
9.  `ORDER BY`★ ランキングという言葉があるのだから、ORDER　BYは使うということは考えよう。


### **解説**
このSQLクエリは、複数のテーブルを結合し、特定の条件でグループ分けした上でのランキングを算出する、実用的なデータ分析のシナリオを想定しています。

*   **`WITH`句（共通テーブル式）:**
    クエリの可読性と再利用性を高めるため、`WITH`句を用いて、4つのマスタテーブル（`社員マスタ`, `部署マスタ`, `給与テーブル`, `役職マスタ`）を事前に結合した仮想的なテーブル`社員情報`を作成しています。これにより、メインの`SELECT`文の記述が簡潔になります。
*   **3つ以上のテーブル`JOIN`:**
    `社員マスタ`を起点に、`部署マスタ`、`給与テーブル`、`役職マスタ`を`INNER JOIN`で結合し、社員の氏名、部署名、役職名、給与といった必要な情報を1つにまとめています。
*   **`CASE`式:**
    `CASE`式を使い、`役職名`が「部長」または「課長」であるかどうかに基づいて、「役職者」と「一般社員」という新しいカテゴリ（`役職グループ`）を動的に生成しています。 このグループ分けは、後続のウィンドウ関数でのランキング計算の単位として利用されます。
*   **`PARTITION BY`句を含むウィンドウ関数:**
    `RANK()`関数と`OVER`句を組み合わせて、ランキングを計算しています。`PARTITION BY`句に`部署名`と`CASE`式で生成した`役職グループ`の2つを指定することで、「部署ごと、かつ役職グループごと」という細かい単位でデータを分割しています。
    さらに、その中で給与の高い順（`ORDER BY 給与 DESC`）に順位付けを行っています。 これにより、単なる全体のランキングではなく、より多角的な分析が可能になります。

---
### 問題
 特定のキャンペーン対象商品（商品IDが 'A001', 'B005', 'C012' のいずれか）の情報を「商品マスタ」から一度に取得したいと考えています。

`WHERE`句で、ある列の値が指定した複数の値のリストの「中に含まれる」かどうかを判定するには、どの演算子を使えばよいか。

```sql
SELECT
  商品名,
  単価
FROM
  商品マスタ
WHERE
  商品ID 【 a 】 ('A001', 'B005', 'C012');
```
**【回答】**
`a`: `IN`
= ANYも正解ではありますが、実用上はIN演算子の方が選択するのが適切（標準的かつ可読性の点で）
**【この構文が必要な理由】**
複数の`OR`条件（`WHERE 商品ID = 'A001' OR 商品ID = 'B005' OR ...`）を記述する代わりに、より簡潔で可読性の高い形で、値の集合との比較を行う必要があるためです。

**【構文の解説】**
`WHERE <列名> IN (<値1>, <値2>, ...)`
*   `IN`: 指定した列の値が、括弧内のリストに含まれるいずれかの値と等しい場合に`TRUE`を返します。
*   括弧内には直接値を列挙するだけでなく、`SELECT`文（サブクエリ）を記述して、その結果セットをリストとして使用することも可能です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `NOT IN (サブクエリ)` を使用する際に、サブクエリの結果に`NULL`が含まれていると意図しない結果になる。
*   **解説**: `WHERE 列名 NOT IN (1, 2, NULL)` のような条件は、`列名 <> 1 AND 列名 <> 2 AND 列名 <> NULL` とほぼ等価に評価されます。SQLでは`NULL`との比較（`<> NULL`）は「不明(UNKNOWN)」となり、結果として全体の条件式が`TRUE`にならないため、1行も返ってこないという現象が起こります。`NOT IN`でサブクエリを使う場合は、サブクエリ側で`NULL`を返さないように`WHERE ... IS NOT NULL`でフィルタリングするなどの注意が必要です。

---
承知いたしました。経験豊富なSQL教育のプロフェッショナルとして、【入力データ】で与えられたSQLの穴埋め問題を、SQL中級者以上が応用知識を試せるよう、【厳格なルール】に従って高品質な問題に作り直します。

---

### 問題

**シナリオ:**
あるECサイトのデータアナリストであるあなたは、経営層から「2025年度上半期（2025年4月1日～9月30日）における高価格帯商品の売上動向を分析してほしい」という依頼を受けました。
**分析要件:**
以下の条件をすべて満たす商品のリストを、指定されたフォーマットで抽出するSQLクエリを作成してください。
1.  **分析対象:**
    *   各店舗が属する「地域」の平均単価を算出する。
    *   その地域平均単価を**上回る**単価の商品のみを「高価格帯商品」として分析対象とする。
    *   高価格帯商品の中でも、2025年度上半期の**売上総額が50万円以上**の商品に限定する。
2.  **出力項目:**
    *   地域名、商品カテゴリ、商品名、単価
    *   その商品が属する**地域の平均単価**
    *   単価と地域平均単価との**差額**
    *   2025年度上半期の**売上総額**
    *   同一地域・同一商品カテゴリ内における、売上総額に基づく**売上ランク**（売上1位がランク1となる）
**使用テーブル:**
*   `売上明細` (店舗ID, 商品ID, 数量, 販売日時)
*   `商品マスタ` (商品ID, 商品名, 商品カテゴリ, 単価)
*   `店舗マスタ` (店舗ID, 店舗名, 地域)
---
```sql
【      A      】 分析データ AS (
    SELECT
        T.地域,
        M.商品カテゴリ,
        M.商品名,
        M.単価,
        【                  B                  】 AS 売上総額
    FROM
        売上明細 AS D
        JOIN 商品マスタ AS M ON D.商品ID = M.商品ID
        JOIN 店舗マスタ AS T ON D.店舗ID = T.店舗ID
    WHERE
        D.販売日時 BETWEEN '2025-04-01' AND '2025-09-30'
    GROUP BY
        T.地域, M.商品カテゴリ, M.商品名, M.単価
),
地域平均 AS (
    SELECT
        T.地域,
        AVG(M.単価) AS 地域平均単価
    FROM
        売上明細 AS D
        JOIN 商品マスタ AS M ON D.商品ID = M.商品ID
        JOIN 店舗マスタ AS T ON D.店舗ID = T.店舗ID
    WHERE
        D.販売日時 BETWEEN '2025-04-01' AND '2025-09-30'
    GROUP BY
        【      C      】
)
SELECT
    A.地域,
    A.商品カテゴリ,
    A.商品名,
    A.単価,
    B.地域平均単価,
    【                  D                  】 AS 差額,
    A.売上総額,
    RANK() OVER (【                  E                  】 ORDER BY A.売上総額 【 F 】) AS カテゴリ内ランク
FROM
    分析データ AS A
    JOIN 地域平均 AS B 【                      G                      】
【                              H                              】
  AND A.売上総額 >= 500000;
```
---
### 解答
*   **A**: `WITH`
*   **B**: `SUM(M.単価 * D.数量)`
*   **C**: `T.地域`
*   **D**: `A.単価 - B.地域平均単価`
*   **E**: `PARTITION BY A.地域, A.商品カテゴリ`
*   **F**: `DESC`
*   **G**: `ON A.地域 = B.地域`
*   **H**: `WHERE A.単価 > B.地域平均単価`
---

### 解説
本クエリは、複雑な業務要件を複数の部品に分解し、それらを順に組み立てることで最終的な分析結果を得るという、実践的なSQLの構造と思考プロセスを体現しています。
#### **構文のポイントと設計思想**

*   **クエリの構造化 (`A: WITH`)**:
    複雑な集計を一度に行うのではなく、`WITH`句を用いて「①商品別の売上総額を計算する部分 (`分析データ`)」と「②地域別の平均単価を計算する部分 (`地域平均`)」という2つの中間テーブルを定義しています。これにより、クエリ全体の可読性が向上し、各部品の役割が明確になります。

*   **3テーブルの結合と集約**:
    `分析データ`と`地域平均`の両方で、`売上明細`・`商品マスタ`・`店舗マスタ`の3つのテーブルを結合し、`GROUP BY`句を用いて必要な単位（商品別、地域別）でデータを集計しています。

*   **中間テーブルの結合 (`G: ON A.地域 = B.地域`)**:
    作成した2つの中間テーブル`分析データ`と`地域平均`を、「地域」をキーとして結合（`JOIN`）しています。これにより、各商品のデータに、その商品が属する地域の平均単価情報を付与することができます。

*   **ウィンドウ関数によるランク付け (`E: PARTITION BY`, `F: DESC`)**:
    `RANK() OVER (...)`は、集計後の結果セットに対して順位付けを行うウィンドウ関数です。
    *   `PARTITION BY A.地域, A.商品カテゴリ` は、「地域ごと、かつ商品カテゴリごと」にランキングの計算対象を区切る（パーティションを作成する）ことを指示しています。
    *   `ORDER BY A.売上総額 DESC` は、売上総額の降順（大きいものが上位）でランク付けすることを定義しています。

#### **ビジネス要件とSQLの対応**

このクエリの核心は、提示されたビジネス要件（分析シナリオ）を、SQLの「式」や「条件」に正確に変換する点にあります。

*   **要件:**「売上総額を算出する」
    *   **実装 (`B: SUM(M.単価 * D.数量)`)**: `SUM`集約関数と算術式 `単価 * 数量` を組み合わせることで、指定された期間とグループにおける売上総額というビジネス指標を計算しています。

*   **要件:**「地域ごとの平均単価を算出する」
    *   **実装 (`C: T.地域`)**: `GROUP BY T.地域` で集計単位を地域に限定し、`AVG(M.単価)`で平均単価を計算しています。

*   **要件:**「単価と地域平均単価との差額を表示する」
    *   **実装 (`D: A.単価 - B.地域平均単価`)**: `SELECT`句の中で単純な引き算を行うことで、分析要件である「差額」という新たな指標を導出しています。

*   **要件:**「地域の平均単価を上回る商品のみを対象とする」
    *   **実装 (`H: WHERE A.単価 > B.地域平均単価`)**: この`WHERE`句の条件式が、入力データの核心ロジックであった「グループ平均との比較」を継承・応用した部分です。中間テーブル`B`から得た地域平均単価と、商品ごとの単価`A.単価`を比較し、業務要件に合致するレコードのみを抽出しています。

このクエリは、単に構文を知っているだけでなく、「**業務上の要求をいかにしてSQLクエリという設計図に落とし込むか**」という、データ分析における応用力と論理的思考力を試す問題となっています。

---

### 問題　★★
 現在の「売上明細」テーブルから、売上金額が10万円以上の高額取引のレコードだけを抽出し、既存の「高額取引履歴」テーブルに丸ごとコピー（挿入）することになりました。

`SELECT`文の実行結果を、そのまま別のテーブルに挿入するには、どのような構文を使用すればよいか。

```sql
【 a 】 高額取引履歴 (注文ID, 顧客ID, 金額, 取引日)
【 b 】
  注文ID, 顧客ID, 金額, 取引日
FROM
  売上明細
WHERE
  金額 >= 100000;
  ```




**【回答】**
`a`: `INSERT INTO`★
`b`: `SELECT`
**【この構文が必要な理由】**
あるテーブルから特定の条件で抽出したデータを、一行ずつではなく一括で効率的に別のテーブルにバックアップしたり、移し替えたりする必要があるためです。データ移行やバッチ処理などで頻繁に利用されます。

**【構文の解説】**
`INSERT INTO <テーブル名> (<列リスト>) SELECT <列リスト> FROM ...;`
*   `INSERT INTO ... SELECT ...`: `VALUES`句を使って1行ずつデータを指定する代わりに、`SELECT`文の実行結果セットをまるごと挿入データとして使用します。★
*   **注意**: `INSERT`句の列リストの列数・データ型と、`SELECT`句の列リストの列数・データ型は、一致している必要があります。

---
### 問題
 よく利用する、社員情報と部署情報を結合した結果を、毎回長い`SELECT`文を書かずに、あたかも一つのテーブルのように手軽に参照できるようにしたいと考えています。

```sql
【 a 】 社員部署一覧 (社員名, 部署名, 内線番号) AS
SELECT
  S.氏名,
  D.部署名,
  S.内線番号
FROM
  社員 S
INNER JOIN
  部署マスタ D ON S.所属部署ID = D.部署ID;
```
**【回答】**
`a`: `CREATE VIEW`
**【この構文が必要な理由】**
複雑なSQLクエリや頻繁に利用する結合結果を、データベース内に名前を付けて保存しておくことで、再利用性を高め、クエリを単純化するためです。また、元のテーブルの一部の列だけを公開することで、セキュリティを高める目的でも使用されます。

**【構文の解説】**
`CREATE VIEW <ビュー名> (<ビューの列リスト>) AS <SELECT文>;`
*   `CREATE VIEW`: 新しいビューを定義します。ビューは実データを持たず、参照されるたびに内部的に`SELECT`文が実行されます。
*   `<ビューの列リスト>`: (オプション) ビューとして公開する列に別名を付けることができます。
*   `AS <SELECT文>`: ビューの元となる`SELECT`文を定義します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: ビューは実際のデータを持っているテーブルだと勘違いする。
*   **解説**: ビューは「保存されたクエリ」であり、実体は`SELECT`文そのものです。ビューに対してクエリを実行すると、データベースシステムがビューの定義（`SELECT`文）とユーザーのクエリを組み合わせて、元の実テーブルにアクセスします。そのため、元のテーブルのデータが更新されれば、ビューから見えるデータも即座に変わります。（注意：更新できるVIEWとできないものがある。ビューの更新可能性という問題）

---
### 問題
 システム開発の初期段階で、社員情報を格納するための新しいテーブル「社員」を作成することになりました。社員を一意に識別するための「社員ID」列を主キーとして設定し、社員の「氏名」は必須入力（`NULL`を許可しない）とします。

```sql
【 a 】 社員 (
  社員ID   CHAR(5)    【 b 】,
  氏名     VARCHAR(40) 【 c 】,
  所属部署ID CHAR(4)
);
```




**【回答】**
`a`: `CREATE TABLE`
`b`: `PRIMARY KEY`
c: NOT NULL
**【この構文が必要な理由】**
データベースにデータを格納するための器である「テーブル」の構造（スキーマ）を定義するために必要です。どのような列があり、それぞれのデータ型や制約（主キー、非NULLなど）はどうなっているかを定める、データ管理の基本となる命令です。

**【構文の解説】**
`CREATE TABLE <テーブル名> ( <列名1> <データ型> <制約>, <列名2> <データ型> <制約>, ... );`
*   `CREATE TABLE`: 新しいテーブルを作成します。
*   **列定義**: 列名、データ型（`CHAR`, `VARCHAR`, `INTEGER`, `DATE`など）、そしてその列に対する制約を記述します。
*   `PRIMARY KEY`: 主キー制約。その列の値がテーブル内で一意（重複不可）であり、かつ`NULL`であってはならないことを示します。テーブルの行を特定するための最も重要なキーです。
*   `NOT NULL`: 非NULL制約。その列に`NULL`値の格納を許可しないことを示します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 主キー(`PRIMARY KEY`)とユニークキー(`UNIQUE`)の違いを混同する。
*   **解説**: どちらも「重複を許可しない」という点は共通ですが、重要な違いがあります。一つのテーブルに`PRIMARY KEY`は一つしか設定できませんが、`UNIQUE`キーは複数設定できます。また、`PRIMARY KEY`は`NULL`を許可しませんが、`UNIQUE`制約は（製品によりますが）一般的に`NULL`を許可します（ただし`NULL`の重複は許さないなど挙動に差があります）。

---

### 問題 ★★
 データベースの設計変更で、既存の「売上明細」テーブルの「商品ID」列が、「商品マスタ」テーブルの「商品ID」を必ず参照するように、整合性を保つための制約（外部キー制約）を追加することになりました。

既存のテーブルの定義を変更して、制約を追加するにはどのDDL文を使用しますか。

```sql
【 a 】 売上明細
【 b 】 FK_商品ID
  FOREIGN KEY (商品ID) REFERENCES 商品マスタ(商品ID);







```
**【回答】**
`a`: `ALTER TABLE`
`b`: `ADD CONSTRAINT`★
**【この構文が必要な理由】**
テーブルを一度作成した後で、業務要件の変更などに応じて、列を追加・削除したり、制約を追加・削除したりする必要があるためです。データベースの運用・保守において不可欠な命令です。

**【構文の解説】**
`ALTER TABLE <テーブル名> ADD CONSTRAINT <制約名> <制約定義>;`
*   `ALTER TABLE`: 既存のテーブルの構造を変更します。
*   `ADD CONSTRAINT`: テーブルに新しい制約を追加します。制約には名前（この例では`FK_商品ID`）を付けることが推奨されます。
*   `FOREIGN KEY (列名) REFERENCES <親テーブル>(列名)`: 外部キー制約を定義します。これにより、「売上明細」の「商品ID」列には、「商品マスタ」の「商品ID」列に存在する値しか登録できなくなり、データの整合性が保たれます。

---

### 問題　★〇
 ログデータが、'20240901' のような `YYYYMMDD` 形式の文字列（`VARCHAR`型）でテーブルに格納されています。このログデータから、2024年9月1日以降のレコードを日付として正しく比較・抽出したいと考えています。

文字列を日付型などの別のデータ型に明示的に変換するには、どの関数を使用すればよいか。

```sql
SELECT
  ログ本文
FROM
  アクセスログ
WHERE
  【 a 】(記録日時 AS DATE) >= '2024-09-01';
```
**【回答】**
`a`: `CAST`
**【この構文が必要な理由】**
'20240901' のような文字列のままでは、日付としての大小比較や日付関数を使った計算ができません。データを適切なデータ型に変換することで、その型が持つ本来の機能（日付の比較、数値計算など）を利用できるようにするためです。

**【構文の解説】**
`CAST(<変換する値> AS <変換後のデータ型>)`
*   `CAST`: 値のデータ型を明示的に変換するための標準SQL関数です。
*   **変換後のデータ型**: `INTEGER`, `VARCHAR(n)`, `DATE`, `TIMESTAMP`など、変換したいデータ型を指定します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 型変換をせずに、`WHERE 記録日時 >= '20240901'` のように文字列のまま比較してしまう。
*   **解説**: この例では、文字列としての辞書順比較でも偶然正しい結果が得られます。しかし、日付のフォーマットが '01/09/2024' (DD/MM/YYYY) のような場合、文字列比較では '02/08/2024' の方が大きいと誤判定されてしまいます。また、'2024-9-1' のように桁数が違うと正しく比較できません。日付や数値の比較は、必ず適切なデータ型に変換してから行うのが鉄則です。

---
### 問題★
 あるキャンペーン期間中に、商品を購入した顧客が「何人」いたのかを調べる必要があります。一人の顧客が期間中に複数回購入していても、1人と数えたいです。
「売上明細」テーブルから、重複を除いたユニークな顧客IDの数を数えるには、`COUNT`関数をどのように使えばよいか。

```sql
SELECT
  【 a 】 顧客ID) AS 購入顧客数
FROM
  売上明細
WHERE
  売上日 BETWEEN '2024-08-01' AND '2024-08-31';
```
**【回答】**
`a`: `COUNT(DISTINCT `★かっこの位置に注意。DISTINCTは、属性を修飾する。
**【この構文が必要な理由】**
単純な行数（延べ人数）ではなく、対象となるエンティティ（この場合は顧客）の純粋な数（正味人数）を把握する必要があるためです。`DISTINCT`キーワードにより、集計前に対象列から重複値を取り除くことができます。

**【構文の解説】**
`COUNT(DISTINCT <列名>)`
*   `COUNT(<列名>)`: 指定した列の`NULL`でない行の数を数えます。
*   `COUNT(*)`: `NULL`を含めたすべての行の数を数えます。
*   `DISTINCT`: `COUNT`関数と組み合わせることで、集計対象の列から重複する値を除外してから、その件数を数えます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `COUNT(*)` や `COUNT(顧客ID)` を使ってしまう。
*   **解説**: `COUNT(*)`や`COUNT(顧客ID)`を使うと、売上の「件数」（延べ購入回数）がカウントされてしまいます。例えば、Aさんが3回、Bさんが2回購入した場合、`5`という結果が返ってきます。要件である「何人いたか（購入者数）」を調べるには、AさんとBさんの2人を数える必要があるので、`COUNT(DISTINCT 顧客ID)`を使い、`2`という結果を得るのが正解です。

---

### 問題　★〇
「どの担当者が、どのカテゴリでいくら売り上げたか」を分析することにしました。
```sql
SELECT
    担当者名, カテゴリ, SUM(売上金額) AS 売上合計
FROM
    売上明細
【 a 】
    【 b 】;
```

**【回答】**
`a`: `GROUP BY`
`b`: `担当者名, カテゴリ`

**【この構文が必要な理由】**
「誰が」「何を」という2つの軸で集計を行うため、グループ化の基準（キー）としてその両方を指定する必要があるからです。`GROUP BY`は、これから行う集計計算の「切り口」を定義する重要な役割を担います。

**【構文の解説】**
`GROUP BY <列1>, <列2>, ...`
`SELECT`句に集約関数（`SUM`など）と非集約列（`担当者名`、`カテゴリ`）を混在させる場合、**すべての非集約列を`GROUP BY`句に指定しなければならない**という厳密なルールがあります。これにより、「`担当者名`と`カテゴリ`の値の組み合わせが同じ行」を一つのグループとして扱い、そのグループ内で`SUM`が計算されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `GROUP BY 担当者名` のように、非集約列の一部だけを指定してしまう。
*   **解説**: この場合、データベースは「`担当者名`でグループ化したはいいが、同じ担当者（例：佐藤さん）が複数のカテゴリ（PC、周辺機器）を売り上げている場合、`SELECT`句に表示すべき`カテゴリ`は一体どれなのか？」と混乱し、エラーを返します。`SELECT`句で表示する非集約列は、すべて集約のキーとして`GROUP BY`句に含めることで、結果の各行が一意に定まることを保証する必要があります。

---

### 問題
個々の商品の売上が、その商品が属するカテゴリ全体の平均売上と比較してどうなのかを評価し、隠れた優良商品やテコ入れが必要な商品を見つけたくなりました。`SELECT`句の中で、外側のクエリ（商品ごと）のカテゴリIDを使い、内側のクエリでそのカテゴリの平均売上を計算させるには、サブクエリ内で何を行えば「単一の値（1行1列）」を返すというルールを満たせるでしょうか。

```sql
SELECT 商品名, 売上金額,
       (SELECT AVG(売上金額)
        FROM 売上明細 S2
        WHERE 【 b 】.カテゴリID = 【 a 】.カテゴリID) AS カテゴリ平均売上
FROM 売上明細 S1;
```
---

### 【回答】

| 空欄 | 内容   | 説明                                               |
|------|--------|----------------------------------------------------|
| a    | S1     | メインクエリのテーブルエイリアス（売上明細）       |
| b    | S2     | サブクエリのテーブルエイリアス（売上明細）         |

---
**【この構文が必要な理由】**
`SELECT`句に埋め込むサブクエリ（スカラサブクエリ）は、外側のクエリの各行に対して「一つの値」を返さなければならないという制約があるためです。集約関数（`AVG`, `MAX`等）を使うことで、サブクエリが返しうる複数行のデータを、ルールに適合する単一の値に集約できます。

**【構文の解説】**
`SELECT`句や`WHERE`句の比較演算子の右辺で使われる、単一の値を返すサブクエリを「スカラサブクエリ」と呼びます。外側のクエリの行（ここでは`S1`の各行）の値を、内側のサブクエリ（`S2`）の条件に使うものを特に「相関サブクエリ」と言います。この組み合わせにより、各商品の行ごとに、その商品が属するカテゴリの平均売上を動的に計算して横に並べることが可能になります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 集約関数を忘れ、平均ではなく個々の売上を返そうとしてしまう。
    ```sql
    -- エラーになる例
    (SELECT 売上金額 FROM 売上明細 S2 WHERE S2.カテゴリID = S1.カテゴリID)
    ```
*   **解説**: このサブクエリは、ある商品と同じカテゴリに属する**すべての**売上金額を返そうとします。通常、カテゴリには複数の売上記録があるため、サブクエリは複数行を返そうとして「サブクエリが複数の値を返しました」というエラーを引き起こします。**各行に対して単一の「カテゴリ平均売上」という値を得るためには、`AVG()`関数で複数行のデータを集約し、必ず1行1列の結果を返す**ように保証する必要があります。

---

### **問題1：階層型データの集計と再帰クエリ**★
**シナリオ**: ある社員（社員番号 'S005'）とその配下の全組織（部下、部下の部下...）に所属する社員の人数と、給与の合計および平均を算出してください。組織構造は自己参照型の社員マスタ（各社員が`上司社員番号`を持つ）で定義されています。
```sql
【 a 】 配下組織 (社員番号, 氏名, 上司社員番号, レベル) AS (
  -- 再帰の起点（アンカーメンバー）
  SELECT 社員番号, 氏名, 上司社員番号, 0 AS レベル
  FROM 社員マスタ
  WHERE 社員番号 = 'S005'
  【 b 】
  -- 再帰処理（再帰メンバー）
  SELECT S.社員番号, S.氏名, S.上司社員番号, H.レベル + 1
  FROM 社員マスタ AS S
  INNER JOIN 配下組織 AS H
    ON S.【 c 】 = H.【 d 】
)
SELECT
  COUNT(*) AS 対象人数,
  SUM(K.給与) AS 合計給与,
  AVG(K.給与) AS 平均給与
FROM
  配下組織 AS H
INNER JOIN
  給与テーブル AS K ON H.社員番号 = K.社員ID;
```
**【回答】**
`a`: WITH RECURSIVE
`b`: UNION ALL
`c`: 上司社員番号　★
`d`: 社員番号

**【この構文が必要な理由】**
社員と上司のような階層構造（木構造）を持つデータを、階層の深さが不特定な状態で末端まで辿るには、自身の問い合わせ結果を再度参照する「再帰クエリ」が必要不可欠なため。

**【構文の解説】**
*   **`WITH RECURSIVE <CTE名> AS ( ... )`**: 共通テーブル式（CTE）で再帰的な問い合わせを定義します。この構文は大きく2つの部分から構成されます。
    1.  **アンカーメンバー**: 再帰の起点となる最初のSELECT文です。ここでは`社員番号 = 'S005'`の社員をレベル0として抽出します。
    2.  **`UNION ALL`**: アンカーメンバーの結果セットと、後続の再帰メンバーの結果セットを結合します。
    3.  **再帰メンバー**: 直前のステップで得られた結果（`配下組織`）を参照して、次の階層のデータを取得するSELECT文です。`S.上司社員番号 = H.社員番号`という条件で、前のステップで見つかった社員（H）を上司に持つ社員（S）を次々と見つけ出し、結果セットが空になるまでこの処理を繰り返します。

---

### **問題2：ウィンドウ関数による移動平均の算出**★★
**シナリオ**: 店舗ごと、月ごとの売上実績から、当月を含む過去3ヶ月間の「移動平均売上」を算出してください。売上データが存在しない月も計算対象に含める必要があります。
```sql
SELECT
  店舗ID,  売上年月,  月次売上,
  AVG(月次売上) 【 a 】 (
    【 b 】 店舗ID
    【 c 】 売上年月
    【 d 】 2 PRECEDING AND CURRENT ROW
  ) AS "3ヶ月移動平均"
FROM
  月次売上ビュー;
```





**【回答】**
`a`: OVER
`b`: PARTITION BY
`c`: ORDER BY
`d`: ROWS BETWEEN

**【この構文が必要な理由】**
行をグループに集約することなく、「`店舗ごと`」という単位で区切られたデータセット（パーティション）に対し、「時系列順」に並べた上で、「`現在行と先行する2行」という動的な範囲`（フレーム）を指定して集計を行うという、高度な分析を実現するためにウィンドウ関数が必要なため。

**【構文の解説】**
*   **`AVG() OVER ( ... )`**: `OVER`句は、`AVG`関数が集計関数ではなくウィンドウ関数として動作することを示します。
    *   **`PARTITION BY 店舗ID`**: 計算対象のレコードを`店舗ID`で分割します。これにより、移動平均の計算が店舗をまたがって行われることを防ぎます。
    *   **`ORDER BY 売上年月`**: パーティション内のデータの順序を`売上年月`の昇順で定義します。これにより、「過去」のデータを正しく特定できます。
    *   **`ROWS BETWEEN 2 PRECEDING AND CURRENT ROW`**: これは「フレーム句」と呼ばれ、ウィンドウ関数が実際に計算を行う範囲を現在行からの相対位置で指定します。`2 PRECEDING`は「先行する2行」、`CURRENT ROW`は「現在の行」を意味し、これらを組み合わせることで「過去2行＋現在行」の計3行を計算対象フレームとします。

---

### **問題3：外部結合と集計結果に対する条件指定**
**シナリオ**: 全ての部署について、取引成立件数が10件未満の営業担当者の一覧を作成してください。一度も取引を成立させたことがない営業担当者もリストに含める必要があります。
```sql
SELECT
    B.部署名, S.氏名, 【 a 】(T.取引ID) AS 取引成立件数
FROM
    社員マスタ AS S
INNER JOIN
    部署マスタ AS B ON S.部署ID = B.部署ID
【 b 】
    取引テーブル AS T ON S.社員ID = T.担当社員ID
WHERE
    S.役職 = '営業'
【 c 】
    S.社員ID, B.部署名, S.氏名
【 d 】
    COUNT(T.取引ID) < 10;
```




**【回答】**
`a`: COUNT ★　　件数を数えるならCOUNT
`b`: LEFT JOIN　★　条件に「ない」が含まれている。
`c`: GROUP BY
`d`: HAVING

**【この構文が必要な理由】**
「一度も取引がない社員も含む」という要件を満たすために、社員マスタを基準とする`LEFT JOIN`が必要です。さらに、社員ごとに集計した「取引成立件数」という集計後の値に対して「10件未満」という条件を適用するためには、`WHERE`句ではなく`HAVING`句を使用する必要があるためです。

**【構文の解説】**
*   **`LEFT JOIN`**: 左テーブル（`社員マスタ`）の全行を結果に含め、右テーブル（`取引テーブル`）に一致するレコードがない場合はNULLとして結合します。これにより、取引実績のない営業担当者も抽出対象となります。
### LEFT JOIN が必要な理由

#### 1. **取引がない営業社員も表示したい**
- `INNER JOIN` を使うと、`取引テーブル` に対応する `取引ID` が存在する社員だけが抽出されます。
- つまり、**1件も取引していない営業社員は結果に含まれません**。
- 一方、`LEFT JOIN` を使えば、`社員マスタ` に存在する営業社員はすべて対象になり、たとえ `取引テーブル` に対応する取引がなくても `NULL` として扱われ、**取引件数0として集計可能**です。

#### 2. **COUNT(T.取引ID) < 10 の条件が意味を持つ**
- `LEFT JOIN` によって、取引がない社員も `COUNT(T.取引ID)` が 0 となり、`< 10` の条件に合致します。
- `INNER JOIN` では `COUNT(T.取引ID)` が**取引件数0の社員は除外されてしまいます**。



| JOINの種類 | 取引がない営業社員 | COUNT結果 | 表示されるか |
|------------|------------------|------------|--------------|
| INNER JOIN | 含まれない        | NULL（除外）| ❌ 表示されない |
| LEFT JOIN  | 含まれる          | 0           | ✅ 表示される |

---

*   **`COUNT(T.取引ID)`**: `COUNT`関数は通常、NULLでない値の個数を数えます。`LEFT JOIN`で取引のない社員は`T.取引ID`がNULLになるため、`COUNT(T.取引ID)`の結果は正しく0件となります。
*   **`GROUP BY`**: `S.社員ID`などでグループ化し、社員一人ひとりの取引件数を集計する単位を作ります。`SELECT`句にある非集計列は、原則として`GROUP BY`句にも含める必要があります。
*   **`HAVING`**: `GROUP BY`による集計が完了した後の結果セットに対して条件を指定します。`WHERE`句はDBがテーブルからレコードを読み込む際（集計前）のフィルタリング条件であり、`HAVING`句は集計後のフィルタリング条件である、という役割の違いを明確に理解することが重要です。



### **問題1　★
 営業担当者について、個人の売上実績が「所属する部署の平均売上」を上回っており、かつ、「全社売上ランキング」で上位10%以内に入る優秀な社員を抽出してください。さらに、抽出した社員には、その個人の売上額が部署平均を何パーセント上回っているかを示す「部署平均比」も付与してください。
```sql
【 a 】 部署別集計 (部署ID, 部署名, 部署平均売上) AS (
  SELECT
    d.部署ID, d.部署名, 【 b 】(s.売上額)
  FROM
    売上実績 AS s
    INNER JOIN 社員マスタ AS e ON s.社員ID = e.社員ID
    INNER JOIN 部署マスタ AS d ON e.部署ID = d.部署ID
  【 c 】
    d.部署ID, d.部署名
),
全社ランキング AS (
  SELECT
    社員ID, 売上額,【 d 】() 【 e 】 (【 f 】 売上額 DESC) AS 売上順位,
    COUNT(*) OVER () AS 全社員数
  FROM
    売上実績
)
SELECT
  e.氏名,  d.部署名,  s.売上額,  r.売上順位,
  (s.売上額 * 100.0 / d.部署平均売上) AS 部署平均比
FROM
  売上実績 AS s
  INNER JOIN 社員マスタ AS e ON s.社員ID = e.社員ID
  【 g 】 部署別集計 AS d ON e.部署ID = d.部署ID
  【 h 】 全社ランキング AS r ON s.社員ID = r.社員ID
【 i 】
  s.売上額 > d.部署平均売上
  【 j 】 r.売上順位 <= (r.全社員数 * 0.1);　★
```





**【回答】**
`a`: WITH
`b`: AVG
`c`: GROUP BY
`d`: RANK
`e`: OVER
`f`: ORDER BY
`g`: INNER JOIN
`h`: INNER JOIN
`i`: WHERE
`j`: AND ★

**【この構文が必要な理由】**
複雑な要件を「部署ごとの集計」「全社的な順位付け」「最終的な条件抽出」という3つの論理的なステップに分解し、クエリ全体の可読性と保守性を劇的に向上させるために`WITH`句（共通テーブル式）が不可欠だからです。また、全社員を対象としたランキング計算には、集約を行わないウィンドウ関数が最適であり、これらの独立した中間結果を最終的に結合して絞り込むという、高度なデータマート構築の思考が求められるためです。

**【構文の解説】**
*   **`WITH`句によるステップワイズな設計**: このSQLは、まず`WITH`句を用いて`部署別集計`と`全社ランキング`という2つの仮想的な中間テーブル（CTE）を作成します。
    *   `部署別集計`: `GROUP BY`を使い、各部署の平均売上という「集計値」を算出します。これは後で個々の社員の売上と比較するための基準値となります。
    *   `全社ランキング`: ウィンドウ関数`RANK()`と`COUNT()`を使用します。`RANK() OVER (ORDER BY 売上額 DESC)`で、全社員を対象に売上順位を付けます。`COUNT(*) OVER ()`は、`PARTITION BY`を省略することでウィンドウを全行とし、総社員数を各行に付与するテクニックです。これにより、後続の`WHERE`句で「上位10%」という相対的な条件判定が可能になります。
*   **メインクエリでの統合**: 最後に、メインの`SELECT`文で`売上実績`テーブルを主軸に、作成した2つのCTEを`INNER JOIN`で結合します。これにより、各社員の行に「自部署の平均売上」「自身の全社順位」「総社員数」といった分析に必要な情報がすべて揃います。
*   **`WHERE`句での最終絞り込み**: 結合して拡張されたテーブルに対し、`WHERE`句で`「個人の売上が部署平均を上回る」かつ「順位が全社員数の10%以内」という2つの条件を適用`し、最終的な優秀社員リストを抽出します。これは、まず必要な情報をすべて集めてから最後にフィルタリングするという、データ分析クエリの典型的な王道パターンです。

---

### **問題2　★
**シナリオ**: 2024年以降、一度も商品を購入していないが、それ以前（2023年12月31日以前）には最低一度は購入履歴がある「長期休眠顧客」を特定し、その顧客が最後に行った購入の年月日と購入金額を報告してください。
```sql
SELECT
    k.顧客ID,  k.氏名,
    (
        SELECT 【 a 】(ch.購入日)
        FROM 購入履歴 AS ch
        WHERE ch.顧客ID = k.顧客ID
    ) AS 最終購入日,
    (
        SELECT sh.購入金額
        FROM 購入履歴 AS sh
        WHERE sh.顧客ID = k.顧客ID
        【 b 】 sh.購入日 DESC
        【 c 】 1　　　★
    ) AS 最終購入金額
FROM
    顧客マスタ AS k
WHERE
    【 d 】 ( -- 2023年以前の購入履歴が存在する
        SELECT 1 FROM 購入履歴 AS old
        WHERE old.顧客ID = k.顧客ID AND old.購入日 < '2024-01-01'
    )
    AND
    【 e 】 ( -- 2024年以降の購入履歴が存在しない
        SELECT 1 FROM 購入履歴 AS new
        WHERE new.顧客ID = k.顧客ID AND new.購入日 >= '2024-01-01'
    );

```
**【回答】**
`a`: MAX
`b`: ORDER BY
`c`: LIMIT ★
`d`: EXISTS
`e`: NOT EXISTS

**【この構文が必要な理由】**
「Aという条件のデータが存在し、かつ、Bという条件のデータは存在しない」という、集合の存在有無に関する複雑な条件を判定するためには、`EXISTS`と`NOT EXISTS`を組み合わせた相関副問合せが最も直感的かつ効率的だからです。さらに、`SELECT`句の中で特定の1レコードから単一の値を取得（スカラ副問合せ）するという、本質的に異なる目的の副問合せも同時に利用する応用力が試されます。

**【構文の解説】**
*   **`WHERE`句の相関副問合せ**:
    *   **`EXISTS ( ... )`**: この副問合せは、外側の`顧客マスタ`の各行（`k`）について、「`k.顧客ID`と一致し、かつ2024年より前の購入履歴」を検索します。該当レコードが1件でも見つかれば`TRUE`を返します。`EXISTS`は存在を検知した時点で検索を打ち切るため、`COUNT(*)>0`よりも効率的です。
    *   **`NOT EXISTS ( ... )`**: 同様に、「`k.顧客ID`と一致し、かつ2024年以降の購入履歴」を検索し、該当レコードが1件も見つからなかった場合に`TRUE`を返します。この2つの条件を`AND`で結ぶことで、「過去に実績があり、現在は休眠している」顧客を正確に絞り込みます。
*   **`SELECT`句のスカラ副問合せ**:
    *   `WHERE`句で絞り込んだ顧客に対し、`SELECT`句の中でさらに副問合せを実行して追加情報を取得しています。
    *   `最終購入日`: `MAX()`集計関数を使い、その顧客の購入履歴の中から最大の購入日（＝最終購入日）を取得します。
    *   `最終購入金額`: こちらは`MAX()`では取得できません。`ORDER BY 購入日 DESC LIMIT 1`（またはDBMSにより`FETCH FIRST 1 ROW ONLY`や`TOP 1`）という定型句を使い、「購入日で降順ソートした結果の先頭行」の購入金額を取得することで、最終購入時の金額を正確に特定します。これは非常に実践的なテクニックです。　★

## LIMITの構文
`LIMIT` は SQL で **結果の件数を制限するための句**です。特に大量のデータから一部だけを取り出したいときに使います。
## 🧠 基本構文

```sql
SELECT 列名 FROM テーブル名
LIMIT 件数;
```
- `LIMIT 5` → 上位5件だけ取得
- `LIMIT 1` → 最初の1件だけ取得

## 🔁 OFFSET と組み合わせる

```sql
SELECT 列名 FROM テーブル名
LIMIT 5 OFFSET 10;
```

- これは「11件目から15件目まで」を取得します。
- `OFFSET` は「何件スキップするか」を指定します。

## 📊 ORDER BY と併用する例

```sql
SELECT 氏名, 売上額
FROM 社員マスタ
ORDER BY 売上額 DESC
LIMIT 3;
```
- 売上額が高い順に`並べて`、**上位3人の社員**を取得します。
---
## 🧪 実用例：営業社員の取引件数が少ない順に並べて、上位5人を取得

```sql
SELECT S.氏名, COUNT(T.取引ID) AS 取引件数
FROM 社員マスタ AS S
LEFT JOIN 取引テーブル AS T ON S.社員ID = T.担当社員ID
WHERE S.役職 = '営業'
GROUP BY S.氏名
ORDER BY 取引件数 ASC
LIMIT 5;
```


## ✅ LIMIT を使う場面

| 目的 | 使い方 |
|------|--------|
| 上位N件だけ取得 | `LIMIT N` |
| ページネーション | `LIMIT N OFFSET M` |
| ランダムに1件取得 | `ORDER BY RAND() LIMIT 1`（MySQLの場合） |

---



---

### **問題1
**シナリオ**: `貸与`テーブルには、一つのデバイスに対する過去の全貸与記録が蓄積されています。システムのパフォーマンス維持のため、各デバイスについて**最新の1件**の貸与記録のみをアクティブな`貸与`テーブルに残し、それより古い全ての貸与記録を`貸与履歴`テーブルに移動（コピー＆削除）するバッチ処理を実装してください。
```sql
-- ステップ1: アーカイブ対象の特定とデータ移動
【 a 】 貸与履歴 (貸与ID, デバイスID, 社員番号, 貸与日, 返却日)
【 b 】
  SELECT
    T1.貸与ID, T1.デバイスID, T1.社員番号, T1.貸与日, T1.返却日
  FROM
    貸与 AS T1
    【 c 】 貸与 AS T2
      ON T1.【 d 】 = T2.【 d 】 AND T1.【 e 】 < T2.【 e 】
  WHERE
    -- ここには、T1より新しいレコード(T2)が「存在する」レコード、
    -- つまりT1が最新ではないレコードを抽出するための条件が入るが、
    -- JOIN句の工夫によりWHERE句での絞り込みは不要となっている。
    -- このJOINは実質的に「自身より新しいレコードを探す」操作である。
    EXISTS (
        SELECT 1 FROM 貸与 AS T_newer
        WHERE T_newer.デバイスID = T1.デバイスID
        AND T_newer.貸与日 > T1.貸与日
    );

-- ステップ2: 移動済みデータの削除
【 f 】 【 g 】 貸与
WHERE
  貸与ID 【 h 】 (SELECT 貸与ID FROM 貸与履歴);
```









**【回答】**
`a`: INSERT INTO
`b`: SELECT ★　INSERT INTOには、そのままSELECTでいい。なったって、インサートだから。
`c`: LEFT JOIN　★
`d`: デバイスID　★
`e`: 貸与日
`f`: DELETE
`g`: FROM
`h`: IN　　★

**【この構文が必要な理由】**
この問題は、「各グループ（デバイスIDごと）における最新以外の全レコード」という非常に複雑な対象を特定し、それに対して`INSERT`と`DELETE`という2つの異なるDML（データ操作言語）を正しく実行する、高度なデータメンテナンス能力を要求するためです。特に、対象レコードを特定するために**`貸与`テーブルを自己結合（Self-Join）し、レコードの時間的な新旧関係を比較する**という、AP試験頻出のテクニックが核心となります。

**【構文の解説】**
*   **ステップ1: データ移動 (`INSERT INTO ... SELECT ...`)**
    *   **`INSERT INTO ... SELECT ...`**: `SELECT`文の実行結果を、そのまま別のテーブルに挿入するための構文です。データのバックアップや移動、集計結果の格納など、実務で多用されます。
    *   **アーカイブ対象を特定する`SELECT`文のロジック**:
        *   **`FROM 貸与 AS T1 LEFT JOIN 貸与 AS T2 ON T1.デバイスID = T2.デバイスID AND T1.貸与日 < T2.貸与日`**: ここがこのSQLの心臓部です。同じ`貸与`テーブルを`T1`と`T2`という2つの名前で扱っています（自己結合）。`デバイスID`が同じで、かつ`T1`の貸与日が`T2`の貸与日よりも古いレコードを結合しようと試みています。
        *   この結果、`T1`のレコードが**もし最新であれば**、`T1.貸与日 < T2.貸与日`という条件に合致する`T2`のレコードは存在しないため、`T2`の列は`NULL`になります。
        *   逆に、`T1`のレコードが**最新でなければ**（＝それより新しいレコードが存在すれば）、その新しいレコードが`T2`として結合されます。
        *   設問では`EXISTS`句を用いていますが、この自己結合の考え方を発展させ、`WHERE T2.デバイスID IS NOT NULL`のような条件で「最新ではないレコード」を絞り込むことが可能です。`EXISTS`句は、相関副問合せを用いて「T1のデバイスIDと一致し、かつT1より新しい貸与日を持つレコードが存在するか」を各行について判定しており、これもまたアーカイブ対象を特定する正攻法です。
*   **【別解：ウィンドウ関数を用いたアプローチ】**
    より近代的なSQLでは、この対象特定はウィンドウ関数`ROW_NUMBER()`を使うと、より直感的かつ効率的に記述できます。
    ```sql
    WITH RankedLoans AS (
      SELECT
        貸与ID,
        ROW_NUMBER() OVER (PARTITION BY デバイスID ORDER BY 貸与日 DESC) as rn
      FROM 貸与
    )
    -- INSERT INTO 貸与履歴 SELECT ... FROM 貸与 WHERE 貸与ID IN (SELECT 貸与ID FROM RankedLoans WHERE rn > 1);
    -- DELETE FROM 貸与 WHERE 貸与ID IN (SELECT 貸与ID FROM RankedLoans WHERE rn > 1);
    ```
    この`ROW_NUMBER()`を使う方法は、`PARTITION BY`でデバイスごとに連番を振り、`ORDER BY ... DESC`で新しいものから順位付けするため、`rn > 1`のレコードが「最新以外」となり、非常に明快です。AP試験では、このウィンドウ関数による解法と、自己結合による古典的な解法の両方を理解しておくことが極めて重要です。

*   **ステップ2: データ削除 (`DELETE ... WHERE IN ...`)**
    *   ステップ1で`貸与履歴`テーブルに移動したレコードの`貸与ID`を副問合せで取得し、`IN`句を使って`貸与`テーブルから該当するレコードを一括で削除します。これにより、データの移動が完了し、`貸与`テーブルには各デバイスの最新レコードのみが残ります。

---

### **【問題】★
**シナリオ**: `注文明細`、`商品マスタ`、`社員マスタ`の3つのテーブルを結合し、「どの社員が、どの商品を、いくつ注文したか」を一覧表示します。`注文明細`と`商品マスタ`の結合キーは`商品コード`という同名の列です。`注文明細`と`社員マスタ`の結合キーは、それぞれ`担当社員ID`と`社員番号`という異なる名前の列です。この条件に最適な`JOIN`構文を使い分けてください。
```sql
SELECT
    E.氏名, P.商品名, D.注文数量
FROM
    注文明細 AS D
    INNER JOIN 商品マスタ AS P 【 a 】 (【 b 】)
    INNER JOIN 社員マスタ AS E 【 c 】 D.【 d 】 = E.【 e 】;
```
**【回答】**
`a`: USING
`b`: 商品コード
`c`: ON
`d`: 担当社員ID　★
`e`: 社員番号　　★

**【この構文が必要な理由】**
SQLの`JOIN`句には、結合条件を記述する方法として`ON`句と`USING`句の2種類があり、それぞれの特性を理解し、状況に応じて適切に使い分ける能力を問うためです。

**【構文の解説】**
*   **`JOIN ... USING (列名)`**:
    *   この構文は、**結合する2つのテーブルで、結合キーとなる列名が全く同じである場合**に使用できます。
    *   `USING (商品コード)`と記述するだけで、内部的に`ON D.商品コード = P.商品コード`と解釈されます。
    *   **利点**: 記述が簡潔になります。また、`SELECT *`を実行した場合、結合キー列（`商品コード`）は結果に1つしか現れないため、冗長性が排除されます（`ON`句の場合は両方のテーブルから同じ名前の列が2つ選択されてしまう）。
*   **`JOIN ... ON 条件式`**:
    *   こちらは、より一般的で汎用的な構文です。**結合キーの列名が異なる場合**（例: `担当社員ID` と `社員番号`）や、等価結合以外の複雑な条件（例: `A.値 > B.値`）で結合する場合に**必須**となります。
    *   `ON D.担当社員ID = E.社員番号`のように、どのテーブルのどの列を結合するのかを明示的に記述します。
*   **AP試験における位置づけ**: 【資料】として提示された過去問の解説では、一貫して`ON`句が使用されています。これは、`ON`句の方がより汎用性が高く、結合条件を明示できるため、可読性や保守性の観点から推奨されることが多いからです。しかし、`USING`句もSQLの標準機能であり、知識として知っておくことで、より洗練されたコードを理解・記述する一助となります。この使い分けを理解していることは、あなたの深い知識レベルを証明するものとなるでしょう。

---

了解です、Mackさん。以下に、**LIMIT / LAG / LEAD / PRECEDING** をすべて含むSQL穴埋め問題を新たに作成しました。文脈は「営業社員の売上推移と部署内順位を分析し、過去との比較や部署内のトップを抽出する」という実務的なシナリオです。

---

### **問題2　★★**
営業社員の売上推移を分析し、以下の条件を満たす社員を抽出してください：

- 各社員の「前月売上」「次月売上」を表示する。
- 部署ごとの売上順位を付ける。
- 直近3ヶ月の売上合計を算出する。
- 部署内順位が3位以内の社員のみを抽出する。
- その中からさらに、上位5件だけを表示してください。

```sql
【 a 】 売上分析 AS (
  SELECT
    s.社員ID, e.氏名, d.部署名, s.月, s.売上額,
    【 b 】(s.売上額) OVER (PARTITION BY s.社員ID ORDER BY s.月) AS 前月売上,
    【 c 】(s.売上額) OVER (PARTITION BY s.社員ID ORDER BY s.月) AS 次月売上,
    【 d 】() OVER (PARTITION BY d.部署ID ORDER BY s.売上額 DESC) AS 部署内順位,
    SUM(s.売上額) OVER (
      PARTITION BY s.社員ID
      ORDER BY s.月
      ROWS BETWEEN 2 【 e 】 AND CURRENT ROW
    ) AS 直近3ヶ月売上
  FROM
    売上実績 AS s
    INNER JOIN 社員マスタ AS e ON s.社員ID = e.社員ID
    INNER JOIN 部署マスタ AS d ON e.部署ID = d.部署ID
)
SELECT
  氏名, 部署名, 月, 売上額, 前月売上, 次月売上, 部署内順位, 直近3ヶ月売上
FROM
  売上分析
【 f 】 部署内順位 <= 3
【 g 】 5;
```

---

















### **【回答】**

| 空欄 | 構文       | 解説 |
|------|------------|------|
| a    | WITH       | 共通テーブル式で分析ロジックを分離 |
| b    | LAG        | 前月の売上を取得 |
| c    | LEAD       | 次月の売上を取得 |
| d    | RANK       | 部署内順位を付ける |
| e    | PRECEDING  | ウィンドウ関数の範囲指定（過去2ヶ月） |
| f    | WHERE      | 部署内順位による絞り込み |
| g    | LIMIT      | 上位5件だけ表示 |

---

### 🔍 構文の活用ポイント

- `LAG` / `LEAD` → 時系列比較で売上推移を可視化。
- `RANK OVER (PARTITION BY 部署)` → 部署内での相対評価。
- `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW` → 直近3ヶ月の売上合計。
- `LIMIT` → 最終的な表示件数を制限。

