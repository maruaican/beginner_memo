```markdown
# 応用情報技術者試験（AP）午後試験対策資料：データベース分野

## 令和6年秋期 午後問6：トレーディングカードの個人売買サイトの構築

### ［設問］1
(1) a. ウ（主キー）、b. ア（外部キー）
(2) 取引（会員ID, 出品ID, 購入日時, 購入者評価, 出品者評価）
(3) d. 0..1、e. 1..*

### ［解説］
・技術的背景：
(1) a: `出品`表の`出品ID`は、各出品を一意に識別するための主キーです。b: `取引`表の`会員ID`は、`会員`表の`会員ID`を参照する外部キーとして、購入者を示します。
(2) `取引`表は、どの会員がどの出品を購入したかの情報を記録します。主キーは、取引を一意に特定できる`会員ID`と`出品ID`の複合キーとなります。購入日時や評価などの属性も含まれます。
(3) ER図のカーディナリティ（多重度）に関する問題です。一つの出品に対して取引は0または1回（売れない場合もあるため0を含む）なので`d`は`0..1`です。一つの会員は複数の出品を行うことができるため`e`は`1..*`となります。

---
### ［設問］2
(1) f. エ（`JOIN 取引 t ON u.出品ID = t.出品ID`）
(2) g. イ（`GROUP BY u.会員ID`）、h. ウ（`HAVING COUNT(t.出品ID) >= 10`）

### ［解説］
・技術的背景：
(1) `出品`表と`取引`表を`出品ID`で結合し、売買が成立した取引を抽出します。
(2) `会員ID`ごとに出品数を集計するために`GROUP BY`句を使用します。`WHERE`句は集計前のレコードに対する条件指定ですが、ここでは集計後の結果（取引成立件数）に対して10件以上という条件を適用するため、`HAVING`句を使用する必要があります。

---
### ［設問］3
(1) i. ア（`FOR UPDATE`）
(2) 分離レベル（トランザクション分離レベル）
(3) j. ファントムリード（Phantom Read）

### ［解説］
・用語：
トランザクション分離レベル（Transaction Isolation Level）： データベースのトランザクションが複数同時に実行された場合に、互いにどの程度影響しあうかを決定する設定です。SQL標準で4つのレベル（READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE）が定義されています。
ファントムリード（Phantom Read）： あるトランザクションが一定の範囲のデータを複数回読み取る間に、別のトランザクションがその範囲内に新たな行を挿入（または削除）することで、後続の読み取りで以前は存在しなかった（または存在した）行が見えてしまう現象です。

・技術的背景：
(1) `SELECT ... FOR UPDATE`文は、読み取った行に対してロック（排他ロック）をかけることで、他のトランザクションによる更新や削除を防ぎます。これにより、在庫数の確認から更新までの間に他のトランザクションが割り込むことを防ぎ、データの一貫性を保証します。
(2) 設問の現象はトランザクションの分離レベルが低い場合に発生する問題です。
(3) 設問で説明されている「範囲指定の問合せで、1回目にはなかったレコードが2回目には現れる」という現象は、ファントムリードの典型的な例です。

## 令和6年春期 午後問6：人事評価システムの設計と実装

### ［設問］1
(1) a. 上司評価、b. 自己評価
(2) c. `評価(評価ID, 評価年月, 被評価者ID, 評価者ID, 評価種別, 総合評価)`
(3) d. `評価項目評価(評価ID, 評価項目ID, 評価)`

### ［解説］
・技術的背景：
(1) 問題文の記述から、評価には上司による評価と、社員自身による自己評価の2種類があることがわかります。
(2) `評価`表は、誰が誰をいつ、どの種別で評価したかの基本情報を格納します。`評価ID`を主キーとすることで、各評価を一意に識別できます。`被評価者ID`と`評価者ID`は`社員`表への外部キーとなります。
(3) `評価項目評価`表は、一つの評価（`評価ID`で識別）における各評価項目（`評価項目ID`で識別）の具体的な評価点を格納します。`評価ID`と`評価項目ID`の複合キーが主キーとなります。

---
### ［設問］2
(1) f. `JOIN 社員 e ON d.被評価者ID = e.社員ID`、g. `JOIN 社員 m ON e.上司ID = m.社員ID`
(2) h. イ（`AVG(d.総合評価)`）、i. ア（`COUNT(d.評価ID)`）

### ［解説］
・技術的背景：
(1) `評価`表の`被評価者ID`を使って`社員`表を結合し（f）、さらにその社員の`上司ID`を使って再度`社員`表を結合する（g）ことで、被評価者の情報と、その上司の情報を同一行で扱うことができます。自己結合（self-join）の一種です。
(2) `GROUP BY`句で部署ごとに集計しているため、`AVG`関数で総合評価の平均値を、`COUNT`関数で評価の件数を計算します。

---
### ［設問］3
(1) j. 外部結合（LEFT JOINまたはLEFT OUTER JOIN）
(2) k. `COALESCE(h.平均評価, 0)`

### ［解説］
・用語：
外部結合（Outer Join）： 2つのテーブルを結合する際に、一方のテーブルにしか存在しない行も結果に含める結合方法です。`LEFT JOIN`、`RIGHT JOIN`、`FULL OUTER JOIN`があります。
COALESCE関数： 引数リストの中で最初に見つかった非NULL値を返す関数です。`COALESCE(a, b, c)`は、aがNULLでなければaを、aがNULLでbがNULLでなければbを、といった形で値を返します。

・技術的背景：
(1) 評価が存在しない社員（評価対象者ではあるが未評価）も結果に含める必要があるため、社員表を主テーブルとして、評価履歴のビュー（`評価履歴V`）を外部結合する必要があります。
(2) 外部結合の結果、評価が存在しない社員の平均評価はNULLになります。これを0として表示するために、`COALESCE`関数（または`CASE`式や`IFNULL`などDBMS固有の関数）を使用します。

## 令和5年秋期 午後問6：在庫管理システム

### ［設問］1
(1) a. `製品(製品番号, 製品名, 製品仕様)`、b. `構成部品(製品番号, 部品番号, 数量)`
(2) c. `DELETE`、d. `CASCADE`

### ［解説］
・技術的背景：
(1) `製品`表は製品そのものの情報を管理し、`構成部品`表はどの製品がどの部品をいくつ必要とするかという多対多の関連を表現します。この構成部品表の主キーは、`製品番号`と`部品番号`の複合キーになります。
(2) `DELETE CASCADE`は、参照整合性制約の一つです。親表（`製品`表）の行が削除されたときに、それに関連する子表（`構成部品`表）の行も自動的に削除するよう定義するものです。これにより、存在しない製品の構成部品情報が残ってしまうことを防ぎます。

---
### ［設問］2
(1) f. `P.製品番号`、g. `P.部品番号`、h. `I.在庫数量`
(2) i. `P.数量 * 50`
(3) j. `GROUP BY P.製品番号`、k. `HAVING MIN(I.在庫数量 / P.数量) >= 50`

### ［解説］
・技術的背景：
(1) SQL文の`WITH`句で定義された共通表式`必要部品`（P）と`部品在庫`（I）を結合し、各製品の製造に必要な各部品の在庫状況を計算しています。
(2) `必要部品`（P）には製品1個当たりの部品数量が、`部品在庫`（I）には現在の在庫数量が格納されています。製品を50個製造するために必要な部品の最低在庫数を求めるため、各部品の必要数（`P.数量`）に50を掛けます。
(3) `GROUP BY`で製品ごとに集計し、`HAVING`句で製造可能性を判定します。各構成部品について「現在の在庫数 ÷ 製品1個当たりの必要数」を計算し、その最小値が製造目標数（50）以上であれば、その製品は製造可能と判断できます。

---
### ［設問］3
(1) l. デッドロック（Deadlock）
(2) m. トランザクションのタイムアウト値を設定し、一方を強制的に終了させ、ロールバックする。
(3) n. `FOR UPDATE`

### ［解説］
・用語：
デッドロック（Deadlock）： 2つ以上のトランザクションが、互いに相手が確保しているリソース（ロック）の解放を待ち、処理が進まなくなる状態です。

・技術的背景：
(1) トランザクション1が部品Aをロックし部品Bのロックを待つ、同時にトランザクション2が部品Bをロックし部品Aのロックを待つ、という状況が発生するとデッドロックに陥ります。
(2) デッドロックを解消するための一般的な方法として、DBMSがデッドロックを検知し、一方のトランザクションをエラーとして強制終了（ロールバック）させる方法があります。アプリケーション側でタイムアウトを設定することも有効です。
(3) `SELECT ... FOR UPDATE`句を使い、更新対象となる行を読み込むと同時に排他ロックをかけることで、他のトランザクションによる参照や更新を防ぎ、一連の処理（読み込みから更新まで）の原子性を保証できます。

## 令和5年春期 午後問6：KPI達成状況集計システムの開発

### ［設問］1
(1) a. `LEFT`
(2) b. ウ（`COALESCE(M.売上額, 0)`）
(3) 202301, A01, 1000, 1
202301, B02, 500, 2
202302, A01, 0, 0

### ［解説］
・技術的背景：
(1) `店舗`表を基準とし、売上がない店舗も結果に含める必要があるため、`店舗`表の全行が残るように`LEFT JOIN`（左外部結合）を使用します。
(2) `LEFT JOIN`の結果、`月次売上`表に対応するレコードがない場合、`売上額`はNULLになります。`COALESCE`関数（または`IFNULL`, `NVL`など）を使い、NULLを0に変換して計算や表示を行います。
(3) ビューの定義に従って、各店舗の各月の売上データとランクを求めます。2023年2月の店舗A01は売上データが存在しないため、`LEFT JOIN`と`COALESCE`によって売上額は0、ランクも0となります。

---
### ［設問］2
(1) c. `PARTITION BY T.店舗ID ORDER BY T.売上年月`
(2) d. `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW`

### ［解説］
・用語：
ウィンドウ関数（Window Function）： `GROUP BY`句のように行を集約するのではなく、レコードの集合（ウィンドウ）に対して計算を行い、各行にその結果を返す関数です。`OVER`句と組み合わせて使用します。
`PARTITION BY`： ウィンドウ関数が適用される行の集合（パーティション）を定義します。`GROUP BY`に似ていますが、行を集約しません。
`ORDER BY`： パーティション内の行の順序を定義します。
`ROWS BETWEEN ...`： フレーム句と呼ばれ、ウィンドウ関数が計算対象とする範囲（フレーム）をパーティション内の現在行からの相対位置で指定します。

・技術的背景：
(1) 店舗ごと（`PARTITION BY T.店舗ID`）に、売上年月の昇順（`ORDER BY T.売上年月`）で、移動平均を計算するよう指定します。
(2) `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW`は、「先行する2行と現在の行」の合計3行を計算フレームとすることを意味します。これにより、当月を含む過去3か月の移動平均を計算できます。

---
### ［設問］3
(1) マテリアライズドビュー（Materialized View）
(2) e. `UNION ALL`
(3) f. `GROUPING`

### ［解説］
・用語：
マテリアライズドビュー（Materialized View）： ビューの定義に基づく問合せ結果を、実体のあるテーブルとして物理的に格納するオブジェクトです。通常のビューが参照されるたびに問合せを実行するのに対し、マテリアライズドビューは実データを保持しているため、集計などの重い処理を高速化できます。ただし、元テーブルのデータが更新されても自動では反映されず、定期的なリフレッシュ（再計算）が必要です。
`GROUPING`関数： `ROLLUP`や`CUBE`などの`GROUP BY`拡張によって生成された集計行（小計や総計の行）かどうかを判定する関数です。集計によって生成されたNULLの場合は1を、元のデータがNULLの場合は0を返します。

・技術的背景：
(1) 設問にある「問合せの結果を実体として保持する」という特徴は、マテリアライズドビューのものです。
(2) `ROLLUP`は、指定した列の組み合わせで小計や総計を段階的に計算します。`GROUP BY ROLLUP(店舗ID, 年度)`は、「店舗IDと年度ごとの集計」「店舗IDごとの集計（年度の小計）」「全体の集計（総計）」の3つのレベルの集計結果を生成し、それらを`UNION ALL`で結合したのと同じ結果を返します。
(3) `ROLLUP`によって生成される小計・総計行では、集計の対象となった列（例：総計行における店舗IDや年度）の値がNULLになります。`GROUPING`関数を使うことで、このNULLが元のデータ由来のNULLなのか、集計によって生成されたNULLなのかを区別できます。

## 令和4年秋期 午後問6：スマートデバイス管理システムのデータベース設計

### ［設問］1
(1) a. `貸与(デバイスID, 社員番号, 貸与日, 返却予定日)`
(2) b. 参照整合性制約
(3) c. `CHECK (貸与日 <= 返却予定日)`

### ［解説］
・技術的背景：
(1) どのデバイスが、いつからいつまで、誰に貸与されているかを管理するためのテーブルです。`デバイスID`を主キーとし、`社員番号`は`社員`表への外部キーとなります。
(2) 外部キー制約は、子表（`貸与`表）の外部キー（`社員番号`）の値が、必ず親表（`社員`表）の主キー（`社員番号`）に存在することを保証する制約であり、参照整合性制約と呼ばれます。
(3) `CHECK`制約は、列の値が満たすべき条件を定義するものです。`貸与日`が`返却予定日`より後になるという不正なデータ入力を防ぐために、`貸与日 <= 返却予定日`という条件を指定します。

---
### ［設問］2
(1) d. `D.デバイスID`
(2) e. `L.デバイスID IS NULL`

### ［解説］
・技術的背景：
(1) `デバイス`表（別名D）と`貸与`表（別名L）を結合し、貸与中でないデバイスを探すSQLです。`デバイス`表の主キーである`デバイスID`で結合します。
(2) 未貸与のデバイスを抽出するには、`デバイス`表を主テーブルとして`貸与`表を外部結合（LEFT JOIN）し、`貸与`表側の対応するレコードが存在しない行（この場合、`L.デバイスID`がNULLになる行）を`WHERE`句で絞り込みます。

---
### ［設問］3
(1) f. `WITH RECURSIVE`
(2) g. `UNION ALL`
(3) h. `N.社員番号 = M.上司社員番号`

### ［解説］
・用語：
再帰問合せ（Recursive Query）： `WITH`句を用いて、自身の結果を再帰的に参照する共通表式（CTE）を定義し、階層構造を持つデータを処理するためのSQL機能です。`WITH RECURSIVE`という構文で記述します。

・技術的背景：
(1) `WITH RECURSIVE`は、再帰的な問合せを開始することを示すキーワードです。
(2) 再帰問合せは、①初期化問合せ（再帰の起点となるベースの行セットを定義）と、②再帰問合せ（直前のステップの結果を使って次の階層の行セットを生成）の2つの部分から構成され、この2つを`UNION ALL`（または`UNION`）で結合します。
(3) 再帰部分では、前のステップで得られた部下の集合（N）と`社員`表（M）を結合します。結合条件は、Nの`社員番号`とMの`上司社員番号`が一致することです。これにより、部下のさらに部下、というように階層を一段ずつ下っていくことができます。

---
### ［設問］4
(1) NoSQLデータベース
(2) i. キー、j. バリュー

### ［解説］
・用語：
NoSQLデータベース： "Not Only SQL"の略。リレーショナルデータベース（RDB）以外のデータベース管理システムの総称です。スキーマレスで柔軟なデータ構造、スケーラビリティの高さなどを特徴とし、キーバリュー型、ドキュメント指向型、カラム指向型、グラフ型などの種類があります。

・技術的背景：
(1) 設問で示されている、スキーマが柔軟で、JSONのような階層的なデータをそのまま格納できるデータベースは、NoSQLデータベース（特にドキュメント指向データベース）の特徴です。
(2) キーバリューストア（KVS）は、NoSQLデータベースの最もシンプルな形式で、一意の「キー」とそれに対応する「バリュー（値）」のペアでデータを格納します。

## 令和4年春期 午後問7：クーポン発行サービス

### ［設問］1
(1) a. `会員ID`、b. `クーポンID`
(2) c. `PRIMARY KEY (会員ID, クーポンID)`、d. `FOREIGN KEY (クーポンID) REFERENCES クーポン(クーポンID)`

### ［解説］
・技術的背景：
(1) `会員クーポン`表は、どの会員がどのクーポンを保有しているかという多対多の関係を管理する中間表（連関エンティティ）です。したがって、`会員`表の主キー`会員ID`と、`クーポン`表の主キー`クーポンID`を外部キーとして持ち、この2つの組み合わせが`会員クーポン`表の主キーとなります。
(2) c: `会員クーポン`表の行を一意に特定するため、`会員ID`と`クーポンID`の複合主キーを設定します。d: `クーポン`表に存在しないクーポンが登録されることを防ぐため、`会員クーポン`表の`クーポンID`が`クーポン`表の`クーポンID`を必ず参照するよう、外部キー制約（参照整合性制約）を設定します。

---
### ［設問］2
e. `U.会員ID = C.会員ID`、f. `U.クーポンID = C.クーポンID`

### ［解説］
・技術的背景：
このSQLは、特定の会員（'M001'）が保有しているクーポンのうち、まだ利用していないものを抽出するものです。主問合せで`会員クーポン`表（C）から'M001'のクーポンを抽出し、`NOT EXISTS`句を用いた副問合せで、そのクーポンが`利用`表（U）に存在しないことを確認します。
副問合せが主問合せの各行と関連付けられるように（相関副問合せ）、`WHERE`句で`会員ID`（e）と`クーポンID`（f）が一致するという条件を指定する必要があります。これにより、「Cの行の会員IDとクーポンIDの組み合わせが、利用表Uに存在しない」という判定が可能になります。

---
### ［設問］3
(1) g. `FOR EACH ROW`
(2) h. `NEW.会員ID`、i. `NEW.クーポンID`

### ［解説］
・用語：
トリガ（Trigger）： テーブルに対する特定の操作（INSERT, UPDATE, DELETE）が実行されたことをきっかけに、自動的に実行される一連の処理（プロシージャ）です。
`FOR EACH ROW`： 行トリガを定義する際に使用する句で、操作によって影響を受けた行ごとにトリガの処理を実行することを示します。対義語は文トリガ（`FOR EACH STATEMENT`）で、操作全体に対して1回だけ実行されます。
`NEW`： INSERT操作やUPDATE操作のトリガ内で使用できる擬似的なレコード変数で、挿入後または更新後の行の値を参照できます。

・技術的背景：
(1) `利用`表にレコードが1行挿入されるたびに、ポイントを更新する処理を実行する必要があるため、行単位で動作するトリガ（行トリガ）を`FOR EACH ROW`で定義します。
(2) トリガの処理内では、どの会員がどのクーポンを利用したかを知る必要があります。`利用`表へのINSERT操作によって起動されたトリガなので、`NEW`という特別な変数を使って、挿入されたばかりの行の値を参照できます。`NEW.会員ID`で利用者（h）を、`NEW.クーポンID`で利用されたクーポン（i）を特定し、`クーポン`表から付与ポイント数を検索して`会員`表を更新します。

## 令和3年秋期 午後問6：企業向け電子書籍サービスの追加設計と実装

### ［設問］1
(1) a. 契約開始日、b. 契約終了日
(2) c. `契約ID`、d. `書籍ID`
(3) e. 1..\*、f. 0..\*

### ［解説］
・技術的背景：
(1) E-R図の`契約`エンティティには、契約期間を管理するための`契約開始日`と`契約終了日`の属性が必要です。
(2) `契約書籍`表は、`契約`と`書籍`の多対多の関係を表現する中間表です。したがって、その主キーは`契約`表の主キー`契約ID`（c）と`書籍`表の主キー`書籍ID`（d）から成る複合キーとなります。
(3) カーディナリティ（多重度）の定義です。一つの契約（`契約`エンティティのインスタンス）には、必ず1冊以上の書籍が含まれるため`e`は`1..*`です。一方、一つの書籍（`書籍`エンティティのインスタンス）は、どの契約にも含まれない場合もあるため`f`は`0..*`となります。

---
### ［設問］2
g. `K.契約終了日 < CURRENT_DATE`
h. `GROUP BY K.契約ID`

### ［解説］
・技術的背景：
このSQLは、契約が終了していて、かつ契約書籍数が100冊以上である契約を抽出するものです。
g: `WHERE`句で契約終了日を判定します。`契約`表（K）の`契約終了日`がシステム上の現在日付（`CURRENT_DATE`）より前であれば、契約が終了していると判断できます。
h: 契約ごとに書籍数を集計するため、`契約ID`でグループ化する必要があります。`GROUP BY`句で`K.契約ID`を指定し、`HAVING`句でそのグループの書籍数（`COUNT(*)`）が100以上という条件を指定します。

---
### ［設問］3
i. `契約`
j. `SET 契約終了日`
k. `契約終了日 + INTERVAL '1 year'`
l. `WHERE 契約ID IN (SELECT 契約ID FROM 契約書籍 WHERE 書籍ID = 'B001')`

### ［解説］
・技術的背景：
このSQLは、特定の書籍（'B001'）を含む全ての契約について、契約終了日を1年間延長する`UPDATE`文です。
i: 更新対象のテーブルは`契約`表です。
j: 更新する列は`契約終了日`なので、`SET 契約終了日 = ...`と記述します。
k: 契約終了日を1年延長するには、現在の日付に1年を加算します。多くのSQL方言では`INTERVAL`句を用いて`契約終了日 + INTERVAL '1 year'`のように記述できます。（DBMSによっては`DATE_ADD`関数などを使用します）
l: 更新対象の行を絞り込む`WHERE`句です。`契約書籍`表から`書籍ID`が'B001'であるレコードの`契約ID`を副問合せで全て抽出し、その`契約ID`に合致する`契約`表の行を更新対象とします。

## 令和3年春期 午後問6：経営分析システムのためのデータベース設計

### ［設問］1
(1) a. 店舗、b. 商品
(2) c. 売上、d. 対象

### ［解説］
・技術的背景：
(1) 問題文の「店舗別、商品別に売上分析を行う」という記述から、分析の軸となる`店舗`と`商品`がエンティティとして必要であることがわかります。
(2) `日次売上`は、`店舗`と`商品`の間の関係（リレーションシップ）から生まれるイベント（トランザクション）を表現するエンティティです。したがって、`店舗`と`日次売上`の間には「売上」のような関係（c）が、`商品`と`日次売上`の間には「対象」となるような関係（d）が存在します。

---
### ［設問］2
(1) e. `店舗コード`、f. `商品コード`
(2) g. `CHECK (売上数量 > 0)`

### ［解説］
・技術的背景：
(1) `日次売上`テーブルは、どの店舗で、どの商品が売れたかを記録するため、`店舗`テーブルの主キーである`店舗コード`（e）と、`商品`テーブルの主キーである`商品コード`（f）を外部キーとして保持する必要があります。
(2) `CHECK`制約は、レコードの挿入時や更新時に、列の値が特定の条件を満たすことを保証する制約です。売上数量が0やマイナスになることは業務上ありえないため、`売上数量 > 0`という制約をかけることでデータの整合性を高めます。

---
### ［設問］3
(1) h. `FROM 日次売上`
(2) i. `FROM 売上実績`、j. `売上日 = '2021-04-01'`

### ［解説］
・技術的背景：
(1) `DELETE`文の構文は`DELETE FROM テーブル名 WHERE 条件`です。`日次売上`テーブルからデータを削除するため、`FROM 日次売上`と指定します。
(2) `INSERT INTO ... SELECT ...`文は、`SELECT`文の実行結果を別のテーブルに挿入する構文です。ここでは`売上実績`テーブル（i）からデータを抽出し、`日次売上`テーブルに挿入します。特定の売上日のデータを対象とするため、`WHERE`句で`売上日`を'2021-04-01'に指定（j）します。

---
### ［設問］4
(1) k. `ON 日次売上 (店舗コード, 売上日)`
(2) l. インデックススキャン（インデックス範囲スキャン）

### ［解説］
・用語：
インデックス（Index）： データベースのテーブルの特定の列に対して作成される、検索を高速化するための索引データです。
インデックススキャン（Index Scan）： `WHERE`句などで指定された条件に合致する行を、インデックスを使って効率的に検索する操作です。テーブルの全行を読み込むフルテーブルスキャンに比べて高速です。

・技術的背景：
(1) SQL文の`WHERE`句で`店舗コード`と`売上日`が頻繁に条件として使われるため、この2つの列を組み合わせた複合インデックスを`日次売上`テーブルに作成することで、検索処理を大幅に高速化できます。構文は`CREATE INDEX インデックス名 ON テーブル名 (列1, 列2, ...)`です。
(2) インデックスが作成されている場合、データベースのオプティマイザは、テーブル全体を走査するのではなく、まずインデックスを参照して目的のデータが格納されている行のアドレス（位置）を特定し、その行に直接アクセスします。この効率的な検索方法をインデックススキャンと呼びます。

## 令和2年秋期 午後問6：宿泊施設の予約を行うシステム

### ［設問］1
(1) a. `会員番号`、b. `部屋番号`
(2) c. `CHECK (チェックイン日 < チェックアウト日)`
(3) 表明（アサーション）

### ［解説］
・用語：
表明（Assertion）： SQL標準で定められている制約の一種で、特定のテーブルだけでなく、データベース全体の状態が満たすべき条件を定義できます。例えば、「全社員の給与総額は、会社の総予算を超えてはならない」といった、複数のテーブルや行にまたがる複雑なビジネスルールを記述できます。ただし、多くの主要なDBMSでは実装されていないか、機能が制限されています。

・技術的背景：
(1) `予約`テーブルは、どの`会員`がどの`部屋`を予約したかを関連付けるため、それぞれの主キーである`会員番号`と`部屋番号`を外部キーとして保持する必要があります。
(2) `CHECK`制約を利用して、データの論理的な整合性を保証します。予約において、チェックイン日がチェックアウト日以降になることはあり得ないため、`チェックイン日 < チェックアウト日`という条件を設定し、不正なデータの入力を防ぎます。
(3) 問題文にある「複数の部屋にまたがる予約の重複を許さない」という制約は、単一の行やテーブルへの`CHECK`制約では実現が困難です。このようなデータベース全体にわたる制約を定義する仕組みが表明（アサーション）です。

---
### ［設問］2
(1) d. `R.部屋番号`
(2) e. `NOT EXISTS`
(3) f. `Y.部屋番号 = R.部屋番号`、g. `AND '2020-10-26' < Y.チェックアウト日 AND Y.チェックイン日 < '2020-10-27'`

### ［解説］
・技術的背景：
指定された期間（2020年10月26日から1泊）に空いている部屋を検索するSQLです。
(1) `部屋`テーブル（別名R）を主テーブルとして`部屋番号`（d）を選択します。
(2) `NOT EXISTS`句（e）を使い、指定した期間に予約が存在しない部屋を絞り込みます。`NOT EXISTS`は、相関副問合せが1行も返さない場合に真（TRUE）を返します。
(3) 相関副問合せの中で、`部屋`テーブルと`予約`テーブルを`部屋番号`で関連付け（f）、予約期間と希望期間が重なっているレコードを検索します（g）。期間の重複は、「一方の終了日 > 他方の開始日」かつ「一方の開始日 < 他方の終了日」という条件で判定できます。この条件に合致する予約が存在しない部屋が、空室であると判断されます。

---
### ［設問］3
(1) h. 更新消失（ロストアップデート）
(2) i. `SELECT ... FOR UPDATE`

### ［解説］
・用語：
更新消失（Lost Update）： 複数のトランザクションが同じデータを読み込み、それぞれの計算結果に基づいて更新を行う場合に、先に完了したトランザクションの更新が、後から完了したトランザクションの更新によって上書きされ、失われてしまう現象です。トランザクションの分離レベルが低い場合に発生します。

・技術的背景：
(1) 設問のシナリオでは、二人の担当者がほぼ同時に同じ部屋の予約状況を読み取り、それぞれが「空いている」と判断して予約処理を進めています。先に行った担当者の予約登録（UPDATE）が、後から来た担当者の予約登録によって上書きされてしまう可能性があり、これは更新消失の典型例です。
(2) `SELECT ... FOR UPDATE`文は、データを読み込むと同時に、その行に対して排他ロックをかける機能です。これにより、他のトランザクションは、ロックが解放される（コミットまたはロールバックされる）まで、その行を更新できなくなります。予約処理の最初にこの文で部屋の行をロックすることで、後続のトランザクションは待たされるため、更新消失を防ぐことができます。

## 令和元年秋期 午後問6：健康応援システムの構築

### ［設問］1
(1) a. `会員ID`、b. `活動ID`
(2) c. `UNIQUE (会員ID, 実施日)`
(3) d. `INTEGER`

### ［解説］
・技術的背景：
(1) `活動実績`テーブルは、どの`会員`が、どの`活動メニュー`（活動IDで識別）をいつ実施したかを記録するテーブルです。そのため、`会員`テーブルの主キーである`会員ID`（a）と、`活動メニュー`テーブルの主キーである`活動ID`（b）を外部キーとして持ちます。
(2) 「会員は、1日に1回だけ活動を登録できる」という制約を実現するためには、`会員ID`と`実施日`の組み合わせが重複しないようにする必要があります。これをデータベースの制約で保証するのが`UNIQUE`制約です。
(3) `歩数`は整数値であるため、データ型としては`INTEGER`（または`INT`）が適切です。

---
### ［設問］2
(1) e. `J.会員ID`
(2) f. `J.活動ID = M.活動ID`
(3) g. `GROUP BY M.会員ID, M.会員名`

### ［解説］
・技術的背景：
このSQLは、会員ごとに月間の合計付与ポイントを計算するものです。
(1) `会員`テーブルと`活動実績`テーブルを`会員ID`で結合します（e）。
(2) さらに`活動実績`テーブルと`活動メニュー`テーブルを`活動ID`で結合し（f）、活動実績に対応する付与ポイントを取得します。
(3) 会員ごとにポイントを集計するため、`会員ID`と`会員名`でグループ化します（g）。`SELECT`句で非集計列（`M.会員名`）を指定しているため、`GROUP BY`句にも同じ列を含める必要があります。

---
### ［設問］3
(1) h. `RANK`、i. `OVER`
(2) j. `ORDER BY 合計ポイント DESC`

### ［解説］
・用語：
ウィンドウ関数（Window Function）： `GROUP BY`句のように行を集約するのではなく、現在の行に関連する行の集合（ウィンドウ）に対して順位計算や集計を行う関数です。`OVER`句を使ってウィンドウの定義（どの範囲で、どの順序で計算するか）を指定します。`RANK()`、`DENSE_RANK()`、`ROW_NUMBER()`、`SUM() OVER (...)`などが代表的です。

・技術的背景：
(1) `RANK()`は、順序付けられた行の集合の中で、各行の順位を計算するウィンドウ関数です。`OVER`句（i）は、ウィンドウ関数であることを示し、その後の括弧内で計算の対象範囲や順序を指定します。
(2) `ORDER BY 合計ポイント DESC`（j）は、`OVER`句の中で、順位付けの基準を指定する部分です。`合計ポイント`の降順（`DESC`）で順位を付けるよう指示しています。これにより、ポイントが高い会員ほど順位が高くなります。`RANK()`関数は、同点の場合に同じ順位を付け、次の順位は同点者の人数分だけ飛ばします（例：1位, 2位, 2位, 4位）。

## 平成31年春期 午後問6：薬剤管理システムの再構築

### ［設問］1
(1) a. `薬品コード`、b. `使用量`
(2) c. `薬品コード`、d. `数量`
(3) e. `DELETE`、f. `CASCADE`

### ［解説］
・技術的背景：
(1) `処方`テーブルは、どの患者にどの薬品をどれだけ処方したかを記録します。処方される薬品を特定するために`薬品`テーブルの主キーである`薬品コード`（a）を外部キーとして持ち、その`使用量`（b）を属性として持ちます。
(2) `在庫`テーブルは、どの薬品がどれだけ在庫にあるかを管理します。薬品を特定するための`薬品コード`（c）と、その`数量`（d）を持ちます。
(3) 参照整合性制約の一つである`ON DELETE CASCADE`を指定すると、親テーブル（`薬品`テーブル）の行が削除されたときに、それを参照している子テーブル（`処方`テーブル、`在庫`テーブル）の関連する行も自動的に削除されます。これにより、マスタに存在しない薬品の処方履歴や在庫情報が残ることを防ぎます。

---
### ［設問］2
g. `Z.薬品コード = Y.薬品コード`
h. `AND Z.数量 > Y.合計使用量`

### ［解説］
・技術的背景：
このSQLは、在庫数量が合計使用量を上回っている（つまり、まだ余裕がある）薬品を抽出するためのものです。`WITH`句で定義された2つの共通表式（`在庫`ビューZと`合計使用量`ビューY）を`薬品コード`で結合し（g）、各薬品について在庫数と使用量を比較します。`WHERE`句の条件（h）で、`在庫`ビューの数量（`Z.数量`）が`合計使用量`ビューの数量（`Y.合計使用量`）よりも大きい薬品のみを抽出します。

---
### ［設問］3
(1) i. `COALESCE`
(2) j. `Y.合計使用量`、k. `0`

### ［解説］
・用語：
`COALESCE`関数： 引数リストの中で、最初に見つかった非NULL値を返す関数です。`COALESCE(expression1, expression2, ...)`のように使用し、`expression1`がNULLでなければその値を、NULLであれば`expression2`を評価し、というように続けます。`CASE`文の短縮形として、また、DBMS間で互換性の高いNULL値の置換方法としてよく利用されます。

・技術的背景：
設問2のSQLでは、`INNER JOIN`を使用しているため、一度も処方されたことのない薬品（`合計使用量`ビューYに存在しない薬品）は結果に含まれません。一度も使用されていない薬品の在庫も表示するためには、`在庫`ビューZを主テーブルとして`合計使用量`ビューYを`LEFT JOIN`（左外部結合）する必要があります。
(1) `LEFT JOIN`の結果、一度も使用されていない薬品の`合計使用量`はNULLになります。このNULLを計算や表示のために0に置き換える必要があります。そのために`COALESCE`関数（i）を使用します。
(2) `COALESCE(Y.合計使用量, 0)`（j, k）と記述することで、`Y.合計使用量`がNULLでない場合はその値を、NULLである場合は0を返すようにできます。

## 平成30年秋期 午後問6：入室管理システムの設計

### ［設問］1
(1) a. `社員番号`、b. `カードID`
(2) c. `NOT NULL`
(3) d. `部屋(部屋番号, 部屋名)`、e. `入退室(入退室ID, 社員番号, 部屋番号, 入室時刻, 退室時刻)`

### ［解説］
・技術的背景：
(1) `ICカード`テーブルは、どのカードがどの社員に割り当てられているかを管理します。そのため、`社員`テーブルの主キーである`社員番号`（a）を外部キーとして持ちます。このテーブルの主キーは`カードID`（b）です。
(2) 社員には必ずICカードが割り当てられるというルールがあるため、`社員`テーブルの`カードID`列にはNULL値を許可しない`NOT NULL`制約を付加します。
(3) d: `部屋`の情報を管理するための`部屋`テーブルを作成します。e: `入退室`の記録は、誰が（`社員番号`）、どの部屋に（`部屋番号`）、いつ入室し、いつ退室したかを記録するテーブルで管理します。各記録を一意に識別するための代理キー`入退室ID`を主キーとします。

---
### ［設問］2
f. `S.社員番号, S.氏名, K.部屋番号`
g. `WHERE N.退室時刻 IS NULL`

### ［解説］
・技術的背景：
このSQLは、現在入室中の社員を一覧表示するためのビューを定義するものです。
f: `SELECT`句には、ビューの列となる社員番号、氏名、部屋番号を指定します。これらは`社員`テーブル（S）と`入退室`テーブル（N）から取得します。
g: 「現在入室中」とは、入室記録はあるが、まだ退室記録がない状態を指します。したがって、`入退室`テーブルの`退室時刻`列がNULLであるレコードを`WHERE`句で抽出します。

---
### ［設問］3
(1) h. `INSERT`
(2) `NEW`
(3) i. `OLD.退室時刻 IS NOT NULL`

### ［解説］
・用語：
`OLD`, `NEW`： トリガ内で使用できる擬似的なレコード変数です。`INSERT`トリガでは`NEW`（挿入された行）のみ、`DELETE`トリガでは`OLD`（削除された行）のみ、`UPDATE`トリガでは`OLD`（更新前の行）と`NEW`（更新後の行）の両方が使えます。

・技術的背景：
(1) このトリガは、`入退室`テーブルのレコードが更新されたとき、特に`退室時刻`が追記されたときに起動され、その履歴を`入退室履歴`テーブルに`INSERT`（h）するものです。
(2) `INSERT`文の`VALUES`句では、`入退室`テーブルから更新された行の値を指定する必要があります。更新後の行の値を参照できるのは`NEW`レコードです。
(3) `退室時刻`がNULLから具体的な時刻に更新された場合のみ履歴を記録し、他の列の更新ではトリガが動作しないように条件を指定します。`UPDATE`トリガでは更新前の値を`OLD`で参照できるため、「更新前の`退室時刻`がNULLであり、かつ更新後の`退室時刻`がNULLでない」という条件が理想ですが、設問の空欄に合うのは「更新前の`退室時刻`がNULLではない」（i）という条件の否定、つまり「更新前の`退室時刻`がNULLである」状態を想定した記述の一部となります。

## 平成30年春期 午後問6：備品購買システムの設計と実装

### ［設問］1
(1) a. `部署`、b. `社員`
(2) c. `注文`、d. `注文明細`
(3) e. 0..\*、f. 1..\*

### ［解説］
・技術的背景：
(1) E-R図において、社員は必ずいずれかの部署に所属するため、`部署`（a）と`社員`（b）はエンティティとなります。
(2) `注文`（c）は購買活動のヘッダ情報（いつ、誰が）を管理し、`注文明細`（d）はその詳細（どの商品を、いくつ）を管理します。これは一般的な販売管理システムにおけるヘッダ・明細モデルです。
(3) カーディナリティ（多重度）の定義です。e: 一人の社員は一度も注文しない可能性もあるため、`社員`と`注文`の関係は`0..*`です。f: 一つの注文には、必ず一つ以上の品目（注文明細）が含まれるため、`注文`と`注文明細`の関係は`1..*`です。

---
### ［設問］2
(1) g. `D.部署名`、h. `S.氏名`
(2) i. `SUM(M.単価 * M.数量)`
(3) j. `GROUP BY C.注文日, D.部署名, S.氏名`

### ［解説］
・技術的背景：
このSQLは、注文日、部署名、社員名ごとに合計金額を集計するものです。
(1) 部署名（g）は`部署`テーブル（D）、氏名（h）は`社員`テーブル（S）から取得します。
(2) 合計金額は、`注文明細`テーブル（M）の各行について、`単価`と`数量`を掛け合わせた金額を、`SUM`関数を使って合計することで求めます（i）。
(3) `SELECT`句で指定した非集計列（`C.注文日`, `D.部署名`, `S.氏名`）は、すべて`GROUP BY`句に含める必要があります（j）。これにより、これらの列の値が同じレコードがグループ化され、そのグループ内で合計金額が計算されます。

---
### ［設問］3
(1) k. `CURRENT_DATE`、l. `S.社員番号`
(2) m. `INSERT`、n. `INTO`、o. `VALUES`

### ［解説］
・技術的背景：
購買依頼を登録する一連の手続きをストアドプロシージャとして定義しています。
(1) `注文`テーブルにレコードを挿入する際、`注文日`にはシステム上の現在日付を取得する`CURRENT_DATE`（k）を、`社員番号`にはプロシージャの引数として渡された社員番号（`S.社員番号`）（l）を指定します。
(2) `注文明細`テーブルにレコードを追加するためのSQL文の穴埋めです。基本的な`INSERT`文の構文は `INSERT INTO テーブル名 (列リスト) VALUES (値リスト)` です。空欄m, n, oにはそれぞれ `INSERT`, `INTO`, `VALUES` が入ります。

## 平成29年秋期 午後問6：青果卸売業の取引システム改修

### ［設問］1
(1) a. `取引(取引ID, 取引日, 店舗ID)`
(2) b. `取引明細(取引ID, 商品ID, 数量, 単価)`

### ［解説］
・技術的背景：
(1) `取引`テーブル（a）は、取引のヘッダ情報（いつ、どの店舗と取引したか）を管理します。各取引を一意に識別するための主キー`取引ID`を持ち、`店舗ID`を外部キーとして持ちます。
(2) `取引明細`テーブル（b）は、一つの取引に含まれる商品の詳細情報を管理します。どの取引の明細かを示す`取引ID`と、どの商品かを示す`商品ID`の複合キーを主キーとし、これらはそれぞれ`取引`テーブルと`商品`テーブルへの外部キーです。数量や単価といった属性を持ちます。

---
### ［設問］2
(1) c. `CASE WHEN T.区分 = 'U' THEN M.単価 * M.数量 ELSE 0 END`
(2) d. `CASE WHEN T.区分 = 'S' THEN M.単価 * M.数量 ELSE 0 END`

### ［解説］
・技術的背景：
このSQLは、商品ごとに売上（U: 売）と仕入（S: 買）の合計金額を一つの問合せで集計するものです。
(1) `CASE`式を使って、条件によって値を振り分けます。`取引`テーブルの`区分`が'U'（売）であれば`単価 * 数量`を計算し、そうでなければ0を返します。これを`SUM`することで売上合計が求まります（c）。
(2) 同様に、`区分`が'S'（仕入）であれば`単価 * 数量`を計算し、そうでなければ0を返します。これを`SUM`することで仕入合計が求まります（d）。

---
### ［設問］3
(1) e. `TIMESTAMP`
(2) f. `OLD`
(3) g. `NEW`

### ［解説］
・用語：
`TIMESTAMP`データ型： 日付と時刻の両方の情報を持つデータ型です。多くの場合、タイムゾーン情報も含むことができます。操作の履歴を正確に記録する際に利用されます。

・技術的背景：
この設問は、`取引明細`テーブルのデータが変更されたときに、その変更履歴を`取引明細更新履歴`テーブルに記録するトリガに関するものです。
(1) `更新日時`には、日付と時刻の両方を記録する必要があるため、`TIMESTAMP`データ型（e）が適切です。
(2) 更新前のレコードの値を履歴テーブルに保存するため、トリガ内で更新前の値を保持している擬似レコード変数`OLD`（f）を参照します。`OLD.単価`で更新前の単価が取得できます。
(3) 同様に、更新後の値は`NEW`（g）で参照できます。`NEW.単価`で更新後の単価が取得できます。

## 平成29年春期 午後問6：稟議申請システム

### ［設問］1
a. `社員番号`、b. `申請部門`
c. `承認(申請番号, 承認順, 承認者社員番号, 承認日, コメント)`

### ［解説］
・技術的背景：
a, b: `申請`テーブルには、誰が（`社員番号`）、どの部署から（`申請部門`）申請したかの情報が必要です。
c: `承認`テーブルは、一つの申請に対して複数の承認者が、決まった順番で承認を行うことを表現します。どの申請（`申請番号`）の、何番目の承認（`承認順`）かを特定する必要があるため、この2つが複合主キーとなります。誰が承認したか（`承認者社員番号`）、いつ承認したか（`承認日`）などの情報を持ちます。

---
### ［設問］2
d. `S.申請番号, S.申請日, S.申請者社員番号, S.件名`
e. `WHERE N.承認日 IS NULL`
f. `AND N.承認順 = (SELECT MIN(承認順) FROM 承認 WHERE 申請番号 = S.申請番号 AND 承認日 IS NULL)`

### ［解説］
・技術的背景：
このSQLは、ある社員（'E001'）が次に承認すべき稟議の一覧を取得するものです。
d: 最終的に表示する稟議の情報を`申請`テーブル（S）から選択します。
e: 承認待ちの稟議は、`承認`テーブル（N）の`承認日`がまだ記録されていない（NULLである）ものです。
f: さらに、「自分が承認する番である」という条件を追加する必要があります。これは、`承認`テーブルから、同じ申請番号でまだ承認日がNULLであるレコードのうち、`承認順`が最小のものである、という条件で表現できます。相関副問合せを使って、`承認`テーブルから最小の`承認順`を取得し、現在の行の`承認順`と比較します。

---
### ［設問］3
g. `IN`
h. `(SELECT 申請番号 FROM 承認 WHERE 承認者社員番号 = 'E001')`
i. `AND 最終承認日 IS NOT NULL`

### ［解説］
・技術的背景：
このSQLは、過去に自分が関与した（承認した）稟議のうち、既に承認が完了しているものを検索するものです。
g, h: 「自分が関与した」という条件は、`承認`テーブルに自分の社員番号（'E001'）が含まれる申請をリストアップすることで実現できます。`WHERE 申請番号 IN (...)`（g）という構文と、副問合せ（h）を使って、自分が承認者となっている`申請番号`のリストを作成し、そのリストに含まれる申請を抽出します。
i: 「承認が完了している」という条件は、`申請`テーブルの`最終承認日`に日付が記録されている（`IS NOT NULL`）かどうかで判定できます。

## 平成28年秋期 午後問6：ネットショップの会員管理

### ［設問］1
(1) a. `性別`
(2) b. `FOREIGN KEY`、c. `REFERENCES`
(3) d. `ON UPDATE CASCADE`

### ［解説］
・技術的背景：
(1) E-R図の`会員`エンティティの属性として、会員の性別を管理するための`性別`（a）が必要です。
(2) `注文`テーブルの`会員番号`列が、`会員`テーブルの`会員番号`列を外部キーとして参照することを示すためのSQL構文です。`FOREIGN KEY (列名) REFERENCES 親テーブル名(親テーブルの列名)`（b, c）と記述することで、参照整合性制約を定義します。
(3) `ON UPDATE CASCADE`（d）は参照整合性制約のオプションの一つです。親テーブル（`会員`テーブル）の主キー（`会員番号`）が更新された場合に、子テーブル（`注文`テーブル）の対応する外部キー（`会員番号`）も自動的に同じ値に更新されるようにする設定です。これにより、会員番号が変更されても注文履歴との関連が維持されます。

---
### ［設問］2
(1) e. `会員番号, 氏名`
(2) f. `HAVING COUNT(C.注文番号) = 0`

### ［解説］
・技術的背景：
このSQLは、一度も商品を注文したことがない会員を抽出するものです。
(1) `SELECT`句で表示する列（`会員番号`、`氏名`）は、`GROUP BY`句でも指定する必要があります（e）。
(2) `会員`テーブルと`注文`テーブルを外部結合（LEFT JOIN）し、会員ごとに注文数を`COUNT(C.注文番号)`で集計します。注文が一回もない会員は、`COUNT`の結果が0になります。`GROUP BY`句で集計した結果に対して条件を指定するには、`WHERE`句ではなく`HAVING`句を使用します（f）。

---
### ［設問］3
(1) ビュー（VIEW）
(2) g. `WHERE M.退会年月日 IS NULL`
(3) h. `M.会員番号 = P.会員番号`

### ［解説］
・用語：
ビュー（VIEW）： 1つ以上のテーブルから特定のデータを選択し、あたかも実在するテーブルのように見せる仮想的なテーブルです。ビューに対して問合せを行うと、データベースシステムがビューの定義に基づいて実テーブルにアクセスし、結果を返します。複雑なSQLを単純化したり、特定のユーザーに見せるデータを制限したりする目的で利用されます。

・技術的背景：
(1) 設問にある「実体のない仮想的な表」はビューの説明です。
(2) 有効な会員（現在、会員である人）のみをビューの対象とするため、`会員`テーブル（M）の`退会年月日`が記録されていない（NULLである）レコードに絞り込む`WHERE`句（g）が必要です。
(3) `ポイント`テーブル（P）を集計した副問合せと`会員`テーブル（M）を結合するための条件です。両テーブルに共通する`会員番号`列で結合します（h）。

## 平成28年春期 午後問6：コンビニエンスストアにおけるデータウェアハウス構築及び分析

### ［設問］1
a. `店舗`、b. `時間`
c. `売上`
d. `商品`

### ［解説］
・用語：
スタースキーマ： データウェアハウスで用いられる多次元分析に適したデータベース設計モデルの一つです。中心に売上などの数値データを持つファクトテーブルを配置し、その周囲に分析の切り口となる次元（ディメンション）を持つディメンションテーブルを配置します。その形が星（スター）のように見えることから名付けられました。

・技術的背景：
スタースキーマの設計に関する問題です。
c: 売上数量や売上金額などの数値データ（メジャー）を持つ`売上`がファクトテーブルの中心となります。
a, b, d: 「いつ」「どこで」「何が」売れたかという分析の軸を提供する`店舗`、`時間`、`商品`がディメンションテーブルとなります。

---
### ［設問］2
(1) e. `ドリルダウン（Drill down）`
(2) f. `スライシング（Slicing）`、g. `ダイシング（Dicing）`

### ［解説］
・用語：
OLAP（Online Analytical Processing）： 多次元データベースに蓄積されたデータを、様々な角度から対話的に分析・集計する技術です。
ドリルダウン（Drill down）： 集計レベルを一段階下げて、より詳細なデータに掘り下げていく操作です。（例：「年別売上」→「月別売上」→「日別売上」）
ドリルアップ（Roll up）： ドリルダウンの逆で、集計レベルを上げて、より要約されたデータを見ていく操作です。
スライシング（Slicing）： 多次元データの中から、特定の次元の値を一つに固定して、断面（スライス）を切り出して分析する操作です。（例：「商品カテゴリ」を「飲料」に固定して売上を見る）
ダイシング（Dicing）： 多次元データの中から、複数の次元で値の範囲を指定して、部分的な立方体（ダイス）を切り出して分析する操作です。（例：「商品カテゴリ」が「飲料」で、「地域」が「関東」の売上を見る）

・技術的背景：
OLAPにおける基本的な分析操作に関する問題です。
(1) 「月→日」のように、データの集計単位をより詳細なレベルに掘り下げる操作はドリルダウンです。
(2) 「商品カテゴリが弁当」のように、一つの次元を固定して分析するのがスライシング（f）、「時間帯が夜間、かつ、顧客の性別が女性」のように、複数の次元で範囲を絞って分析するのがダイシング（g）です。

---
### ［設問］3
h. `GROUP BY`
i. `ROLLUP`
j. `(店舗ID, 商品ID)`

### ［解説］
・用語：
`ROLLUP`： `GROUP BY`句の拡張機能の一つで、指定された列の組み合わせに対して、小計や総計を自動的に計算します。`GROUP BY ROLLUP(A, B)`は、(A, B)での集計、(A)での集計（Bの小計）、全体での集計（総計）の3つのレベルの集計結果を一度に生成します。

・技術的背景：
このSQLは、`ROLLUP`句を用いて、店舗ごと、商品ごとの売上集計と、店舗ごとの小計、および全体の総計を一度に計算するものです。
h, i, j: `GROUP BY ROLLUP (店舗ID, 商品ID)` と記述することで、指定した2つの列の組み合わせで集計が行われます。具体的には、①(`店舗ID`, `商品ID`)ごとの集計、②(`店舗ID`)ごとの集計（①の小計）、③全体の集計（総計）が計算され、結果として返されます。

## 平成27年秋期 午後問6：人事情報のデータ構造

### ［設問］1
(1) a. `従業員番号`、b. `所属部門コード`
(2) c. `従業員`、d. `部門`
(3) e. `発令日`

### ［解説］
・技術的背景：
(1) `異動履歴`テーブルは、どの従業員（`従業員番号`）が、どの部門へ（`所属部門コード`）異動したかの記録です。したがって、この2つを外部キーとして持ちます。
(2) `従業員番号`は`従業員`テーブル（c）の主キーを、`所属部門コード`は`部門`テーブル（d）の主キーをそれぞれ参照します。
(3) 異動の履歴を管理するためには、いつその異動が行われたかを示す`発令日`（e）が不可欠です。`従業員番号`と`発令日`を複合主キーとすることで、一人の従業員の異動履歴を一意に管理できます。

---
### ［設問］2
f. `I.従業員番号 = J.従業員番号`
g. `AND I.発令日 > J.発令日`

### ［解説］
・技術的背景：
このSQLは、各従業員の最新の所属部門を取得するために、`異動履歴`テーブルを自己結合（self-join）しています。
f: 2つの`異動履歴`テーブル（別名IとJ）を`従業員番号`で結合し、同じ従業員の履歴同士を比較します。
g: Iの`発令日`がJの`発令日`よりも大きい、という条件を追加します。これにより、IのレコードはJのレコードよりも新しい異動履歴であることが保証されます。この自己結合の結果を外部結合（LEFT JOIN）し、`J.発令日 IS NULL` となる行を抽出することで、Iのレコードがその従業員にとって最新（それより新しいJのレコードが存在しない）であると判定できます。

---
### ［設問］3
(1) h. `PARTITION BY`
(2) i. `ORDER BY 発令日 DESC`
(3) j. `FETCH FIRST 1 ROW ONLY`

### ［解説］
・用語：
ウィンドウ関数： `OVER`句と共に使用し、行の集合に対して計算を行う関数です。
`PARTITION BY`： ウィンドウ関数を適用する行のグループ（パーティション）を指定します。`GROUP BY`と似ていますが、行を集約しません。
`ROW_NUMBER()`： パーティション内で、指定された順序に基づいて各行に一意の連番を振ります。
`FETCH FIRST n ROWS ONLY`： SQL:2008で標準化された構文で、問合せ結果の最初のn行だけを返します。`LIMIT`句と同様の機能です。

・技術的背景：
このSQLは、ウィンドウ関数を用いて各従業員の最新の異動履歴を効率的に取得するものです。
(1) `ROW_NUMBER() OVER (PARTITION BY 従業員番号 ...)`（h）と記述することで、`従業員番号`ごとにパーティションを作成し、その中で連番を振ります。
(2) `ORDER BY 発令日 DESC`（i）は、パーティション内の行を`発令日`の降順（新しいものが先頭）に並べ替えることを指示します。これにより、各従業員の最新の履歴が連番1になります。
(3) 副問合せで連番を振った後、主問合せでその連番が1の行のみを抽出するのが一つの方法ですが、設問では`WITH TIES`句と組み合わせて使われる`FETCH FIRST`句が問われています。しかし、より一般的な解法としては、副問合せで順位をつけた結果から`WHERE ranking = 1`とする方法があります。設問の空欄jは、もしSQL:2008の構文を想定するなら、`FETCH FIRST 1 ROW ONLY`（j）が該当しますが、これは`ORDER BY`句と組み合わせて、全体でソートした結果の先頭行を取る構文であり、従業員ごとの最新行を取るこの文脈とは少し異なります。

## 平成27年春期 午後問6：アクセスログ監視システムの構築

### ［設問］1
(1) a. `NOT NULL`、b. `DEFAULT`
(2) c. `CHECK (終了時刻 > 開始時刻)`
(3) d. `CREATE INDEX インデックス名 ON アクセスログ (利用PC名)`

### ［解説］
・技術的背景：
(1) `登録日時`列には必ず値が入るように`NOT NULL`制約（a）をかけます。また、`DEFAULT CURRENT_TIMESTAMP`（b）のようにデフォルト値を設定することで、INSERT時に値を指定しなくても自動的に現在の日時が記録されるようにできます。
(2) `CHECK`制約（c）は、データの整合性を保つために列の値が満たすべき条件を定義します。ログデータとして、アクセスの`終了時刻`が`開始時刻`より後であることは当然の条件です。
(3) `利用PC名`を検索条件として頻繁に利用する場合、この列にインデックスを作成することで検索を高速化できます（d）。

---
### ［設問］2
e. `アクセスログ`
f. `利用PC名, DATE(開始時刻)`
g. `GROUP BY`
h. `利用PC名, DATE(開始時刻)`

### ［解説］
・技術的背景：
このSQLは、`アクセスログ`テーブル（e）のデータを、PC名と利用日（`DATE(開始時刻)`で日付部分のみを抽出）ごとに集計するものです。
f, h: `利用PC名`と`DATE(開始時刻)`という2つのキーでデータをグループ化するため、`SELECT`句（f）と`GROUP BY`句（g, h）の両方に同じ列を指定します。
`COUNT(*)`でログの件数を、`SUM(TIMESTAMPDIFF(SECOND, 開始時刻, 終了時刻))`で合計利用時間を秒単位で計算しています。

---
### ［設問］3
(1) i. `HAVING`
(2) j. `COUNT(*) >= 100`
(3) k. `SUM(TIMESTAMPDIFF(SECOND, 開始時刻, 終了時刻)) > 3600`

### ［解説］
・技術的背景：
このSQLは、設問2で集計した結果から、さらに特定の条件（不正アクセスの可能性があるもの）を満たすものだけを抽出するものです。
(1) `GROUP BY`句で集計した結果に対して条件を指定するには、`WHERE`句ではなく`HAVING`句（i）を使います。
(2) 条件1「1日のアクセス件数が100件以上」は、`COUNT(*)`の結果が100以上であること、つまり `COUNT(*) >= 100`（j）と表現できます。
(3) 条件2「1日の合計アクセス時間が3,600秒を超える」は、`SUM`で計算した合計秒数が3600より大きいこと、つまり `SUM(...) > 3600`（k）と表現できます。
これらの条件を`OR`で kết hợp し て `HAVING` 句 で 指定 し ます。

## 平成26年秋期 午後問6：分散トランザクション

### ［設問］1
(1) a. `COMMIT`、b. `ROLLBACK`
(2) c. C（Consistency）：一貫性
(3) d. D（Durability）：耐久性

### ［解説］
・用語：
ACID特性： トランザクション処理システムが持つべきとされる4つの性質。
- **A (Atomicity): 原子性** - トランザクション内の処理がすべて実行されるか、全く実行されないかのどちらかであることが保証される性質。
- **C (Consistency): 一貫性** - トランザクションの前後で、データベースの状態が予め定められた制約（整合性制約）を満たしていることが保証される性質。
- **I (Isolation): 独立性（隔離性）** - 複数のトランザクションを同時に実行した場合でも、それぞれのトランザクションは他のトランザクションの影響を受けず、あたかも一つずつ順番に実行されているかのように見える性質。
- **D (Durability): 耐久性** - 正常に完了したトランザクションの結果は、システム障害が発生しても失われないことが保証される性質。

・技術的背景：
(1) トランザクションは、一連の処理が全て成功した場合に`COMMIT`（a）で変更を確定させ、途中で失敗した場合には`ROLLBACK`（b）で処理開始前の状態に戻します。
(2) 「処理の実行後も，DBは矛盾のない状態が保たれている」という説明は、一貫性（Consistency）のものです。
(3) 「正常終了したトランザクションの結果は，障害が発生してもDBから消失しない」という説明は、耐久性（Durability）のものです。

---
### ［設問］2
(1) e. 2相コミット（Two-Phase Commit）
(2) f. 準備、g. 確定
(3) h. コミット、i. ロールバック

### ［解説］
・用語：
2相コミット（Two-Phase Commit Protocol）： 複数のデータベースにまたがる分散トランザクションを、全体としてコミットするかロールバックするかのいずれかに統一するためのプロトコル。トランザクションの調整役（コーディネータ）と、各データベース（参加者）の間でやり取りを行います。
- **第1相（準備フェーズ）**: コーディネータが全参加者にコミット可能かどうかの問い合わせ（`PREPARE`）を送信する。各参加者は、処理を実行し、結果を永続化できる状態になったら`OK`を、できなければ`NG`を返す。
- **第2相（コミットフェーズ）**: コーディネータが全参加者から`OK`を受け取った場合、全参加者にコミット（`COMMIT`）を指示する。一人でも`NG`を返した場合、全参加者にロールバック（`ROLLBACK`）を指示する。

・技術的背景：
(1) 複数のサイト（データベース）にまたがるトランザクションの原子性を保証する仕組みが2相コミットです（e）。
(2) プロトコルは、第1相の準備フェーズ（f）と、第2相の確定フェーズ（g）から構成されます。
(3) 全てのサイトが準備完了であれば、トランザクション全体をコミット（h）します。一つでも準備に失敗したサイトがあれば、トランザクション全体をロールバック（i）します。

---
### ［設問］3
j. `COMMIT`
k. `A`、l. `ROLLBACK`

### ［解説］
・技術的背景：
2相コミットの障害シナリオに関する問題です。
j: サイトBは第1相でコミット準備完了の応答を返しているため、サイトAからの指示を待っている状態です。通信が回復し、サイトAからコミット指示を受け取った場合、サイトBはそれに従って`COMMIT`を実行します。
k, l: サイトBからの応答がタイムアウトした場合、サイトA（コーディネータ）はトランザクション全体を成功させることができないと判断します。そのため、サイトA（k）自身は`ROLLBACK`（l）し、通信が回復した際にサイトBにもロールバックを指示します。これにより、トランザクションの原子性が保たれます。

## 平成26年春期 午後問6：旅客船Web予約システムの構築

### ［設問］1
(1) a. `便(便名, 出発港, 到着港, 出発時刻, 到着時刻)`
(2) b. `予約(予約番号, 会員ID, 乗船日, 人数)`
(3) c. `予約明細(予約番号, 便名, 等級)`

### ［解説］
・技術的背景：
(1) 旅客船の便の情報を管理するための`便`テーブル（a）を作成します。
(2) `予約`テーブル（b）は、予約のヘッダ情報（誰が、いつ、何人で）を管理します。予約を一意に識別するための`予約番号`を主キーとし、`会員ID`を外部キーとして持ちます。
(3) `予約明細`テーブル（c）は、どの予約がどの便のどの等級に対応するかを管理する中間テーブルです。`予約番号`と`便名`の複合キーを主キーとします。

---
### ［設問］2
(1) d. `LEFT`
(2) e. `Y.予約番号 IS NULL`

### ［解説］
・技術的背景：
このSQLは、指定した乗船日・便において、まだ予約がない（空席がある）等級を検索するものです。
(1) `便`テーブルと`等級`テーブルをクロス結合して全ての組み合わせを作成したものを主テーブルとし、そこに`予約`テーブル（Y）を外部結合（`LEFT JOIN`）（d）します。
(2) 予約が存在しない組み合わせは、外部結合の結果、`予約`テーブル側の列がNULLになります。したがって、`WHERE`句で `Y.予約番号 IS NULL` （e）という条件を指定することで、予約がない等級、つまり空席がある等級を抽出できます。

---
### ［設問］3
(1) f. `INSERT`
(2) g. `VALUES (CURRENT_DATE, 'T001', ...)`
(3) h. `LAST_INSERT_ID()`

### ［解説］
・用語：
`LAST_INSERT_ID()`： MySQLやMariaDBなどで使用できる関数で、直前の`INSERT`文によって自動採番（`AUTO_INCREMENT`）されたIDを取得します。他のDBMSでは`SCOPE_IDENTITY()` (SQL Server), `RETURNING`句 (PostgreSQL, Oracle) など、同等の機能を持つ仕組みがあります。

・技術的背景：
予約手続きをストアドプロシージャで実装する際のSQL文の穴埋めです。
(1) `予約`テーブルに新しい予約レコードを追加するため、`INSERT`文（f）を使用します。
(2) `VALUES`句（g）で、挿入する具体的な値を指定します。乗船日や会員IDはプロシージャの引数から、予約日はシステム日付から取得します。
(3) `予約`テーブルにレコードを挿入した際に自動採番された`予約番号`を、続く`予約明細`テーブルへの`INSERT`文で利用する必要があります。そのために`LAST_INSERT_ID()`関数（h）を呼び出し、直前に生成されたIDを取得します。

## 平成25年秋期 午後問5：レンタルビデオ管理システム

### ［設問］1
(1) a. `会員番号`、b. `貸出日`
(2) c. `ON DELETE RESTRICT`
(3) d. `貸出中`、e. `返却済`

### ［解説］
・技術的背景：
(1) `貸出`テーブルの主キーは、どのビデオ（`ビデオID`）が、いつ貸し出されたかを一意に識別する必要があります。したがって`ビデオID`と`貸出日`の複合主キーが考えられます。また、誰が借りたかを示すために`会員`テーブルの主キーである`会員番号`（a）を外部キーとして持ちます。`返却予定日`は`貸出日`（b）に貸出期間を加算して計算されます。
(2) `ON DELETE RESTRICT`は参照整合性制約のオプションで、子テーブル（`貸出`テーブル）に参照しているレコードが存在する場合には、親テーブル（`会員`テーブル）のレコードの削除を禁止するものです。貸出中の会員を誤って削除するのを防ぎます。
(3) 貸出状況を管理するために、状態を示す列（例えば`状態`列）を設けることが考えられます。その列には'貸出中'（d）や'返却済'（e）といった値が入ります。あるいは、`返却日`がNULLかどうかで判定する方法もあります。

---
### ［設問］2
(1) f. `WHERE`
(2) g. `C.返却日 IS NULL`
(3) h. `AND C.返却予定日 < CURRENT_DATE`

### ［解説］
・技術的背景：
このSQLは、返却予定日を過ぎてもまだ返却されていない、延滞中の貸出情報を検索するものです。
(1) `SELECT`文で条件を指定するためには`WHERE`句（f）を使います。
(2) 「まだ返却されていない」という条件は、`貸出`テーブル（C）の`返却日`列が記録されていない、つまり`IS NULL`であることで表現できます（g）。
(3) 「返却予定日を過ぎて」いるという条件は、`返却予定日`がシステム上の現在日付（`CURRENT_DATE`）よりも前である、という条件で表現できます（h）。

---
### ［設問］3
(1) カーソル（Cursor）
(2) i. `FETCH`、j. `INTO`
(3) k. `UPDATE`、l. `SET`

### ［解説］
・用語：
カーソル（Cursor）： `SELECT`文によって得られた複数行の結果セットを、1行ずつ順番に処理するための仕組みです。ストアドプロシージャやバッチ処理などで、結果セットの各行に対して複雑な処理を行いたい場合に使用します。`DECLARE`（宣言）、`OPEN`（オープン）、`FETCH`（行の取得）、`CLOSE`（クローズ）といった一連の命令で操作します。

・技術的背景：
(1) 設問にある「問合せ結果を1行ずつ取り出して処理を進める」仕組みはカーソルです。
(2) `FETCH`命令（i）はカーソルから次の1行を読み込み、`INTO`句（j）で指定された変数にその行の値を格納します。
(3) 読み込んだデータに基づいて`在庫`テーブルの`在庫数`を増やす処理を行います。テーブルのデータを更新するには`UPDATE`文（k）を使い、`SET`句（l）で更新する列と値を指定します（`SET 在庫数 = 在庫数 + 1`）。

## 平成25年春期 午後問6：テキストマイニングツールを活用したシステムへの機能追加における設計と実装

### ［設問］1
a. `文書ID`
b. `出現単語`
c. `(文書ID, 出現単語, 出現位置)`

### ［解説］
・技術的背景：
テキストマイニングの前処理として、文書内の単語とその出現位置をデータベースに格納するテーブル設計です。
a: どの文書に関する情報かを示すため、`文書`テーブルの主キーである`文書ID`を外部キーとして持ちます。
b: 抽出された単語そのものを`出現単語`として格納します。
c: このテーブル`単語出現位置`は、どの文書の、どの単語が、どこに出現したかを記録します。`文書ID`と`出現単語`だけでは、同じ単語が複数回出現した場合を区別できないため、`出現位置`も含めた3つの列で複合主キーを構成するのが適切です。

---
### ［設問］2
(1) d. `T1.出現単語 = 'B'`
(2) e. `T1.文書ID = T2.文書ID`
(3) f. `T1.出現位置 < T2.出現位置`

### ［解説］
・技術的背景：
このSQLは、`単語出現位置`テーブルを自己結合して、単語'A'と単語'B'がこの順で出現する文書を検索するものです。
(1) テーブルT1を単語'B'の出現情報に絞り込むため、`WHERE`句で`T1.出現単語 = 'B'`とします（d）。（問題文のSQLではT2が'A'なので、T1は'B'になります）
(2) 同じ文書内での出現を調べるため、2つのテーブルT1とT2を`文書ID`で結合します（e）。
(3) 単語'A'の後に単語'B'が出現するという順序を保証するため、T1（単語'B'）の`出現位置`が、T2（単語'A'）の`出現位置`よりも大きい（後である）という条件を指定します。設問の空欄の形に合わせると `T1.出現位置 < T2.出現位置` の否定、つまり `T2.出現位置 < T1.出現位置` となります（f）。

---
### ［設問］3
(1) g. `COUNT(DISTINCT T1.文書ID)`
(2) h. `COUNT(DISTINCT T2.文書ID)`

### ［解説］
・技術的背景：
このSQLは、共起度（単語Aと単語Bが両方出現する文書の割合）を計算するものです。
(1) `COUNT(DISTINCT 文書ID)`は、`文書ID`のユニークな件数、つまり文書の総数を数えます。分子は、2つの単語が共に出現する文書の数を数えるため、自己結合した結果の`文書ID`のユニーク件数を数えます（g）。
(2) 分母は、単語A（'A'）が出現する文書の総数です。`単語出現位置`テーブルから`出現単語`が'A'であるレコードに絞り込み、その`文書ID`のユニーク件数を数えます（h）。

## 平成24年秋期 午後問6：スーパーマーケットの販売管理システム

### ［設問］1
a. `会員`
b. `商品`
c. `店舗`
d. `時間`

### ［解説］
・用語：
ディメンション： データウェアハウスにおいて、売上などの分析対象となる数値データ（ファクト）を、どのような切り口で分析するかを定義するものです。「いつ（時間）」「どこで（店舗）」「誰が（会員）」「何を（商品）」といった分析軸がディメンションにあたります。

・技術的背景：
POSデータ分析のためのデータモデル（スタースキーマ）設計に関する問題です。分析対象のファクトは「売上」であり、それを分析するための切り口として、`会員`（a）、`商品`（b）、`店舗`（c）、`時間`（d）がディメンションとなります。

---
### ［設問］2
(1) e. `販売`、f. `商品`
(2) g. `GROUP BY`
(3) h. `P.商品名, P.単価`
(4) i. `ORDER BY`、j. `DESC`

### ［解説］
・技術的背景：
このSQLは、商品別の売上数量合計を計算し、売上の多い順に並べるものです。
(1) `販売`テーブル（e）と`商品`テーブル（f）を`商品コード`で結合し、どの商品が売れたかの情報を取得します。
(2), (3) 商品ごとに売上数量を集計するため、`GROUP BY`句（g）を使用します。`SELECT`句で指定している非集計列である`商品名`と`単価`（h）は、`GROUP BY`句にも含める必要があります。
(4) `ORDER BY`句（i）で、結果の表示順を制御します。`SUM(H.販売数量)`（売上数量合計）の降順（多い順）に並べるため、`DESC`（j）を指定します。

---
### ［設問］3
(1) k. `CREATE`、l. `VIEW`
(2) m. `AS`
(3) n. `FROM`

### ［解説］
・技術的背景：
この設問は、ビュー（VIEW）を作成するDDL（データ定義言語）文の穴埋めです。ビューは、複雑なSELECT文を一つの仮想的なテーブルとして定義するもので、問合せを単純化する目的で使われます。
(1), (2), (3), (4) ビューの基本的な作成構文は `CREATE VIEW ビュー名 (列リスト) AS SELECT ... FROM ...` です。空欄にはそれぞれ `CREATE`（k）、`VIEW`（l）、`AS`（m）、`FROM`（n）が入ります。

## 平成24年春期 午後問6：複数の図書館の検索システムの統合

### ［設問］1
(1) a. `ISBN`
(2) b. `図書館ID`
(3) c. `(ISBN, 図書館ID, 冊数)`
(4) d. `図書館(図書館ID, 図書館名, 住所)`

### ［解説］
・技術的背景：
(1) `ISBN`（International Standard Book Number）は、国際的に書籍を特定するために用いられる一意の番号であり、`図書`テーブルの主キーとして適しています。
(2) 各図書館を識別するために`図書館ID`（b）を導入します。
(3) `蔵書`テーブルは、どの図書館に（`図書館ID`）、どの図書が（`ISBN`）、何冊あるか（`冊数`）を管理します。`ISBN`と`図書館ID`の複合キーが主キーとなります。
(4) 図書館自体の情報（名称、住所など）を管理するための`図書館`マスタテーブル（d）を作成します。

---
### ［設問］2
e. `T.ISBN = Z.ISBN`
f. `AND Z.図書館ID = 'L01'`

### ［解説］
・技術的背景：
このSQLは、ある図書館（'L01'）に所蔵されていない図書を検索するものです。
e: `図書`テーブル（T）と`蔵書`テーブル（Z）を`ISBN`で関連付けます。
f: `NOT EXISTS`句を用いた相関副問合せの中で、図書館IDが'L01'である蔵書レコードが存在するかどうかをチェックします（f）。副問合せが1行も返さない（つまり、図書館'L01'にはそのISBNの蔵書が存在しない）場合に、主問合せの`WHERE`句の条件が真となり、その図書が結果として選択されます。

---
### ［設問］3
(1) g. `UNION`
(2) h. `ISBN, 書名, 出版社`
(3) i. `IN`

### ［解説］
・技術的背景：
このSQLは、キーワード（'情報処理'）を書名または出版社に含む図書を検索するものです。
(1) 書名にキーワードを含む図書の集合と、出版社にキーワードを含む図書の集合を結合するために`UNION`演算子（g）を使います。`UNION`は重複する行を排除して結果を返します。
(2) `UNION`で結合する複数の`SELECT`文は、列の数とデータ型が一致している必要があります。両方の`SELECT`文で、`ISBN`, `書名`, `出版社`（h）を選択します。
(3) `IN`演算子（i）は、値がリストの中に存在するかどうかを判定します。`WHERE 図書館ID IN ('L01', 'L02')` のように使い、複数の図書館を指定して蔵書を検索する場合に便利です。

## 平成23年秋期 午後問6：旅費交通費精算のシステム化

### ［設問］1
(1) a. `社員番号`
(2) b. `申請(申請ID, 申請日, 社員番号, 精算月)`
(3) c. `明細(申請ID, 明細番号, 日付, 利用区間, 金額, ...)`

### ［解説］
・技術的背景：
(1) 誰が申請したかを明確にするため、`申請`テーブルは`社員`テーブルの主キーである`社員番号`（a）を外部キーとして持ちます。
(2) `申請`テーブル（b）は、申請全体のヘッダ情報を管理します。各申請を一意に識別するための`申請ID`を主キーとします。
(3) `明細`テーブル（c）は、一つの申請に含まれる個々の経費項目を管理します。どの申請の明細かを示す`申請ID`と、申請内での一意性を示す`明細番号`の複合キーを主キーとします。

---
### ［設問］2
(1) d. `精算月`、e. `社員番号`
(2) f. `JOIN 明細 M ON S.申請ID = M.申請ID`
(3) g. `GROUP BY S.精算月, S.社員番号`

### ［解説］
・技術的背景：
このSQLは、精算月ごと、社員ごとに交通費の合計金額を計算するものです。
(1) `SELECT`句で表示する項目として、`精算月`（d）と`社員番号`（e）を指定します。
(2) `申請`テーブル（S）と`明細`テーブル（M）を`申請ID`で内部結合（`JOIN`）し、申請とその明細を関連付けます（f）。
(3) 精算月と社員番号の組み合わせで集計するため、`GROUP BY`句にこの2つの列を指定します（g）。`SUM(M.金額)`で、グループ化された明細の合計金額を計算します。

---
### ［設問］3
h. `EXISTS`
i. `(SELECT * FROM 承認 WHERE 申請ID = S.申請ID AND 承認フラグ = '1')`

### ［解説］
・技術的背景：
このSQLは、まだ承認されていない申請（未承認の申請）を検索するものです。
h: `NOT EXISTS`句（h）は、相関副問合せの結果が1行も返されない場合に真（TRUE）を返す演算子です。これを利用して、「承認レコードが存在しない」という条件を表現します。
i: 相関副問合せ（i）では、主問合せの`申請`テーブル（S）の各行について、その`申請ID`に対応するレコードが`承認`テーブルに存在し、かつ`承認フラグ`が'1'（承認済み）であるものを検索します。この副問合せが1行も結果を返さない申請、つまり未承認の申請が、最終的な結果として選択されます。

## 平成23年特別 午後問6：データベースの設計と実装

### ［設問］1
(1) a. `受注(受注番号, 受注日, 顧客ID)`
(2) b. `受注明細(受注番号, 商品ID, 数量)`

### ［解説］
・技術的背景：
これは典型的な販売管理システムのヘッダ・明細モデルです。
(1) `受注`テーブル（a）は、受注のヘッダ情報（いつ、どの顧客からの受注か）を管理します。`受注番号`を主キーとし、`顧客ID`を外部キーとして持ちます。
(2) `受注明細`テーブル（b）は、一つの受注に含まれる商品の詳細情報を管理します。どの受注の明細かを示す`受注番号`と、どの商品かを示す`商品ID`の複合キーを主キーとします。

---
### ［設問］2
c. `第3正規形`
d. `関数従属`
e. `主キー`

### ［解説］
・用語：
正規化（Normalization）： データベース設計において、データの冗長性を排除し、更新時等の不整合（更新異常）を防ぐために、テーブルを適切に分割していくプロセスです。第1正規形、第2正規形、第3正規形などがあります。
- 第1正規形： テーブルの各列の値が単一値（スカラ値）である状態。
- 第2正規形： 第1正規形であり、かつ、部分関数従属が存在しない状態。複合主キーの一部だけで一意に決まる非キー属性がないこと。
- 第3正規形： 第2正規形であり、かつ、推移的関数従属が存在しない状態。主キー以外の列に関数従属する非キー属性がないこと。
関数従属（Functional Dependency）： ある属性の値が決まると、別の属性の値が一意に決まる関係のこと。`X → Y`と表記し、「XがYを関数的に決定する」と読みます。

・技術的背景：
正規化の定義に関する問題です。
c: 問題文の「主キー以外の属性に部分関数従属も推移的関数従属も存在しない」という状態は、第3正規形の定義そのものです。
d, e: 推移的関数従属とは、「A→B」かつ「B→C」という関係があるときに、「A→C」という関係が成立することです（ただしBは主キーではない）。つまり、主キー（e）以外の属性（B）に、他の属性（C）が関数従属（d）している状態を指します。これを解消するのが第3正規化です。

---
### ［設問］3
f. `トリガ（Trigger）`
g. `INSERT`
h. `NEW`

### ［解説］
・技術的背景：
(f) データベースに対する特定の操作（INSERT, UPDATE, DELETE）をきっかけに、自動的に実行される一連の処理をトリガと呼びます。
このトリガは、`受注明細`テーブルに新しいレコードが挿入（`INSERT`）（g）されたときに起動します。トリガの処理内容（`商品`テーブルの`在庫数`を更新する）では、挿入された`受注明細`の`商品ID`と`数量`を知る必要があります。トリガ内では、挿入された行の値を`NEW`（h）という特別な変数で参照できます。したがって、`NEW.数量`で注文された数量を取得し、`商品`テーブルの在庫数を減算する`UPDATE`文を実行します。

## 平成22年秋期 午後問6：販売管理システム

### ［設問］1
(1) a. `顧客ID`
(2) b. `受注(受注番号, 受注日, 顧客ID, ...)`
(3) c. `受注明細(受注番号, 商品番号, 受注数量, 販売単価)`
(4) d. `CASCADE`

### ［解説］
・技術的背景：
(1) `受注`テーブルは、どの`顧客`からの注文かを記録するため、`顧客`テーブルの主キーである`顧客ID`（a）を外部キーとして持ちます。
(2), (3) 典型的な販売管理のE-Rモデルです。`受注`（b）がヘッダ、`受注明細`（c）が明細となり、多対多の関係を解決します。`受注明細`の主キーは`受注番号`と`商品番号`の複合キーです。
(4) 参照整合性制約の`ON DELETE CASCADE`（d）を設定すると、親である`受注`テーブルのレコードが削除された際に、子である`受注明細`テーブルの関連レコードも自動的に削除されます。受注取消処理などでデータの整合性を保つのに役立ちます。

---
### ［設問］2
(1) e. `SELECT`、f. `FROM`
(2) g. `WHERE`
(3) h. `HAVING COUNT(*) >= 10`

### ［解説］
・技術的背景：
このSQLは、10件以上の受注がある顧客を抽出するものです。
(1) SQLの基本構文`SELECT ... FROM ...`（e, f）です。
(2) `GROUP BY`句でグループ化する前にレコードを絞り込む場合は`WHERE`句（g）を使います。
(3) `GROUP BY`で集計した結果に対して条件を指定する場合は`HAVING`句を使います。ここでは、受注件数（`COUNT(*)`）が10件以上という条件を`HAVING`句で指定します（h）。

---
### ［設問］3
(1) i. `排他`
(2) j. `デッドロック`

### ［解説］
・用語：
ロック（Lock）： データベースにおいて、複数のトランザクションが同時に同じデータにアクセスする際に、データの一貫性を保つための仕組みです。他のトランザクションからのアクセスを制限します。
- **共有ロック（Shared Lock）**: データの読み取り時にかけるロック。他のトランザクションも共有ロックをかけて読み取ることはできるが、排他ロックをかけて更新することはできない。
- **排他ロック（Exclusive Lock）**: データの更新（書き込み）時にかけるロック。排他ロックがかかっている間、他のトランザクションは共有ロックも排他ロックもかけることができず、読み取りも書き込みも待たされる。
デッドロック（Deadlock）： 2つ以上のトランザクションが、互いに相手が確保しているリソース（ロック）の解放を待ち続け、永遠に処理が進まなくなる状態。

・技術的背景：
(1) あるトランザクションがデータを更新している間、他のトランザクションにそのデータを更新させないようにかけるロックを排他ロック（i）と呼びます。
(2) 設問のシナリオのように、トランザクションAが資源Xをロックして資源Yを待ち、トランザクションBが資源Yをロックして資源Xを待つという状況は、デッドロック（j）の典型例です。

## 平成22年春期 午後問6：販売管理システムで使用するSQL文の検証

### ［設問］1
(1) a. `DISTINCT`
(2) b. `顧客名`
(3) c. `ORDER BY`

### ［解説］
・技術的背景：
(1) `SELECT DISTINCT`（a）は、重複する行を排除して、一意な値の組み合わせのみを結果として返すための構文です。
(2) このSQLは、`受注`テーブルと`顧客`テーブルを結合し、一度でも受注のあった顧客の情報を表示するものです。`顧客`テーブルの`顧客名`（b）を表示します。
(3) `ORDER BY`句（c）は、結果セットを指定した列の値に基づいて並べ替えるために使用します。

---
### ［設問］2
(1) d. `OUTER`
(2) e. `J.顧客ID IS NULL`

### ［解説］
・技術的背景：
このSQLは、一度も受注したことのない顧客を検索するものです。
(1) `顧客`テーブルを基準（主テーブル）として、`受注`テーブルを外部結合（`LEFT OUTER JOIN`）（d）します。外部結合により、`受注`テーブルに対応するレコードがない`顧客`（つまり、一度も受注のない顧客）も結果に含まれます。
(2) 一度も受注のない顧客は、外部結合の結果、`受注`テーブル（J）側の列がすべてNULLになります。したがって、`WHERE`句で`J.顧客ID IS NULL`（e）のような条件を指定することで、目的の顧客を抽出できます。

---
### ［設問］3
(1) 相関副問合せ（相関サブクエリ）
(2) f. `EXISTS`
(3) g. `J.顧客ID = K.顧客ID`

### ［解説］
・用語：
相関副問合せ（Correlated Subquery）： 副問合せ（内側の`SELECT`文）が、主問合せ（外側の`SELECT`文）で現在処理中の行の値を参照して実行されるタイプの副問合せです。主問合せの行ごとに繰り返し実行されるため、パフォーマンスに影響を与えることがあります。

・技術的背景：
(1) 設問のSQLのように、副問合せの`WHERE`句で主問合せのテーブル（K）を参照しているものを相関副問合せと呼びます。
(2) `EXISTS`演算子（f）は、副問合せが1行以上の結果を返す場合に真（TRUE）を返します。ここでは「受注が存在する顧客」を検索するために使われています。
(3) 副問合せが主問合せの現在の行と関連付けられるように、`WHERE`句で主問合せの`顧客ID`（`K.顧客ID`）と副問合せの`顧客ID`（`J.顧客ID`）が一致するという条件（g）を指定します。

## 平成21年秋期 午後問6：旅行業務用データベースの設計

### ［設問］1
a. `顧客(顧客ID, 氏名, 住所, 電話番号, ...)`
b. `ツアー(ツアーID, ツアー名, 出発日, 日数, 金額)`
c. `申込(申込ID, 顧客ID, ツアーID, 申込日, 人数)`

### ［解説］
・技術的背景：
旅行の申込を管理するための基本的なE-Rモデルです。
a: `顧客`の情報を管理するマスタテーブルです。
b: `ツアー`の情報を管理するマスタテーブルです。
c: どの`顧客`が、どの`ツアー`に申し込んだかを管理するトランザクションテーブルです。`顧客`と`ツアー`の多対多の関係を解決する中間テーブル（連関エンティティ）の役割を果たします。各申込を一意に識別する`申込ID`を主キーとし、`顧客ID`と`ツアーID`を外部キーとして持ちます。

---
### ［設問］2
d. `COUNT(M.顧客ID)`
e. `GROUP BY T.ツアーID, T.ツアー名`
f. `HAVING COUNT(M.顧客ID) < 10`

### ［解説］
・技術的背景：
このSQLは、申込者数が10人未満のツアーを検索するものです。
d: 申込者数を数えるため、`申込`テーブル（M）の`顧客ID`（または`申込ID`など）を`COUNT`関数で集計します。
e: ツアーごとに集計するため、`ツアーID`と`ツアー名`で`GROUP BY`句を使ってグループ化します。
f: `GROUP BY`で集計した結果（申込者数）に対して、「10人未満」という条件を指定するため、`HAVING`句を使います。

---
### ［設問］3
(1) g. `JOIN`、h. `ON`
(2) i. `WHERE`
(3) j. `IN`

### ［解説］
・技術的背景：
SQLの基本的な結合構文と条件指定に関する問題です。
(1) `JOIN`句（g）でテーブルを結合し、`ON`句（h）で結合条件を指定するのが標準的なSQLの構文です。
(2) `WHERE`句（i）は、`FROM`句で得られた結果セットから、条件に合致する行を絞り込むために使います。
(3) `IN`演算子（j）は、`WHERE`句などで、列の値が指定されたリストの中に含まれるかどうかを判定するために使います。（例: `WHERE ツアーID IN ('T001', 'T002')`）

## 平成21年春期 午後問6：注文管理システムの設計と実装

### ［設問］1
(1) a. `注文番号`、b. `商品コード`
(2) c. `UNIQUE (顧客ID, 注文日)`
(3) d. `CHECK (注文数量 > 0)`

### ［解説］
・技術的背景：
(1) `注文明細`テーブルは、どの`注文`（`注文番号`）に、どの`商品`（`商品コード`）が含まれているかを記録します。したがって、この2つを外部キーとして持ち、複合主キーを構成します。
(2) 「同じ顧客が同じ日に2回以上注文できない」という業務ルールをデータベースの制約で実現するには、`注文`テーブルの`顧客ID`と`注文日`の組み合わせが重複しないようにする`UNIQUE`制約（c）を設定します。
(3) `注文数量`が0やマイナスになるという不正なデータを防ぐため、`CHECK`制約（d）を使って値が正の整数であることを保証します。

---
### ［設問］2
(1) e. `FROM`
(2) f. `GROUP BY`
(3) g. `C.顧客ID`
(4) h. `SUM(M.注文数量 * S.単価)`

### ［解説］
・技術的背景：
このSQLは、顧客ごとの合計注文金額を計算するものです。
(1), (2), (3) 顧客ごとに集計するため、`GROUP BY C.顧客ID`（f, g）と記述します。`FROM`句（e）で必要なテーブル（`注文`, `注文明細`, `商品`）を指定し、結合します。
(4) 合計金額は、`注文明細`の各行について`注文数量`と`商品`マスタの`単価`を掛け合わせ、それを`SUM`関数で顧客ごとに合計して求めます（h）。

---
### ［設問］3
(1) ストアドプロシージャ（Stored Procedure）
(2) i. `BEGIN`、j. `END`
(3) k. `COMMIT`、l. `ROLLBACK`

### ［解説］
・用語：
ストアドプロシージャ： データベースに対する一連の処理を一つのプログラムとしてまとめ、データベース管理システム（DBMS）内に保存したものです。アプリケーションはプロシージャ名を指定して呼び出すだけで、一連の処理を実行できます。ネットワークトラフィックの削減や処理の共通化、セキュリティ向上などのメリットがあります。

・技術的背景：
(1) 設問にある「一連の処理を一つの手続きとしてDBMSに登録しておく」仕組みはストアドプロシージャです。
(2) 多くの手続き型SQL（PL/SQL, T-SQLなど）では、処理のブロックを`BEGIN`（i）と`END`（j）で囲んで記述します。
(3) 一連の処理がすべて成功した場合は`COMMIT`（k）でトランザクションを確定し、途中でエラーが発生した場合は`ROLLBACK`（l）ですべての処理を取り消し、データベースを処理開始前の状態に戻します。これにより、処理の原子性（Atomicity）が保証されます。
```