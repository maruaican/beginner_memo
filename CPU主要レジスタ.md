
---

### CPU主要レジスタに関する演習問題

---

**【問1】**
CPUがプログラムを実行する際、次にどの命令を実行すべきかを常に把握している必要があります。この「次に行うべきことの道しるべ」としての役割を担うレジスタの名称と、それが保持する情報の種類を答えてください。

---
**【解答】**
レジスタの名称は「プログラムカウンタ（PC）」であり、保持している情報は「次に実行する命令が格納されている主記憶装置（メモリ）のアドレス」です。

---
**【解説】**
プログラムカウンタ、通称 **PC (Program Counter)** は、CPUの命令実行サイクルにおいて最も基本的な役割を担うレジスタです。Counter（数えるもの）という名前の通り、通常は命令を1つ実行するごとに自動的にインクリメント（値が増加）され、プログラムの命令が格納されているメモリ上のアドレスを順番に指し示していきます。これにより、プログラムの逐次実行が実現されます。分岐命令やジャンプ命令が実行されると、PCには次に実行すべき命令の飛び先アドレスが直接設定され、プログラムの制御フローが変化します。

---
**【初心者が勘違いしやすい点】**
「プログラムカウンタは、現在実行中の命令を保持する」という誤解が非常に多いです。現在実行中の命令そのものを保持するのは、後述する**命令レジスタ（IR）**の役割です。PCはあくまで「**次**の命令の**アドレス**」を保持する、と正確に区別して覚えましょう。料理のレシピに例えるなら、PCは「次に見るべき手順が書かれたページ番号」を指している指、IRは「今まさに読んでいる手順そのもの」と言えます。

---
**【問2】**
CPUがメモリから命令を読み出した後、その命令を解読（デコード）して実行に移すために、一時的に命令そのもの（機械語コード）を格納しておく専用のレジスタは何ですか。

---
**【解答】**
命令レジスタ（IR: Instruction Register）です。

---
**【解説】**
命令レジスタ、通称 **IR (Instruction Register)** は、主記憶装置からフェッチ（読み出し）された命令コードを、CPUが実行完了するまで保持しておくためのレジスタです。*Instruction* は「指示」「命令」、*Register* は「記録器」を意味します。
IRに格納された命令は、CPU内部の**命令デコーダ**によって解読され、どのような演算をどのデータに対して行うべきかが判断されます。その結果に基づき、CPUの各装置（演算装置、制御装置など）に対して具体的な制御信号が送られ、命令が実行されます。

---
**【初心者が勘違いしやすい点】**
命令レジスタ（IR）は「命令そのもの」を保持し、プログラムカウンタ（PC）は「命令のアドレス」を保持します。この「実体」と「場所」の違いは、試験で頻繁に問われる重要ポイントです。IRはデコーダが解読するための「設計図」そのものを保持する場所、PCはその設計図が保管されている棚の「番地」を指す場所、とイメージすると良いでしょう。

---
**【問3】**
プログラムカウンタ（PC）と命令レジスタ（IR）は、CPUの命令実行サイクルの「命令フェッチ」段階で密接に連携します。この2つのレジスタの役割の違いを、「誰が」「何を」「どこから」という観点を含めて明確に説明してください。

---
**【解答】**
プログラムカウンタ（PC）は、「次に」実行すべき命令が格納されている「メモリ上のアドレス」を指し示します。一方、命令レジスタ（IR）は、そのPCが指し示したアドレスから「メモリから」読み出された「現在実行中」の命令そのものを保持します。

---
**【解説】**
CPUの命令実行は、以下の流れで進みます。
1.  **フェッチ（Fetch）**: CPUは、まず**PC**が指しているメモリアドレスにアクセスします。
2.  **読み出し**: そのアドレスから命令コードを読み出し、**IR**に格納します。
3.  **PCの更新**: CPUは、次の命令に備えて**PC**の値をインクリメントします（通常は命令長分だけ加算）。
4.  **デコードと実行**: **IR**に格納された命令を解読し、実行します。

このように、PCは「これから取りに行く命令の場所」を示し、IRは「今から実行する命令そのもの」を保持するという、明確な役割分担があります。この一連の流れを理解することが、CPUの動作原理を掴む鍵となります。

---
**【初心者が勘違いしやすい点】**
この2つの連携を時系列で理解していないと、「PCが命令を保持する」「IRが次のアドレスを計算する」といった混乱を招きます。常に「**①PCで場所を指定 → ②IRに命令を格納**」という順番を徹底してください。この順序が逆になることは絶対にありません。

---
**【問4】**
サブルーチン呼び出しや割り込み処理において、実行中のプログラムを一時中断し、処理後に元の場所へ正確に戻る仕組みは不可欠です。この「元の場所へ戻る」という処理を実現するために中心的な役割を果たすレジスタは何ですか。また、そのレジスタが指し示すメモリ領域のデータ構造的な特徴を答えてください。

---
**【解答】**
中心的な役割を果たすレジスタは「スタックポインタ（SP）」です。それが指し示すメモリ領域は、「後入れ先出し（LIFO: Last-In, First-Out）」という特徴を持つスタック構造となっています。

---
**【解説】**
スタックポインタ、通称 **SP (Stack Pointer)** は、メモリ上に確保された**スタック領域**の最上段（Top of Stack）のアドレスを常に指し示すレジスタです。*Stack* は「積み重ねた山」、*Pointer* は「指し示すもの」を意味します。
サブルーチンを呼び出す際、CPUは「戻るべきアドレス（現在のPCの値）」をスタックに**Push（プッシュ：積み上げ）**します。そしてサブルーチンの処理が終わると、スタックからそのアドレスを**Pop（ポップ：取り出し）**してPCに戻します。この一連の操作により、プログラムは中断した場所から正確に処理を再開できるのです。
スタックは後入れ先出し（LIFO）構造のため、関数が入れ子（ネスト）で呼び出された場合でも、呼び出されたのと逆の順序で正しく戻ってくることができます。

---
**【初心者が勘違いしやすい点】**
「SPは戻り先アドレスそのものを保持する」という誤解があります。SPが保持するのは、あくまで戻り先アドレスなどが格納されている**スタック領域の先頭アドレス**です。SPはデータそのものではなく、データの「置き場所」を管理している、という点を明確に理解してください。

---
**【問5】**
プログラムカウンタ（PC）とスタックポインタ（SP）は、どちらもメモリ上の「アドレス」を保持する点で共通していますが、その目的と役割は全く異なります。この2つのレジスタが指し示す「アドレス」の目的の違いを、「プログラムの流れ」と「データの一時退避」というキーワードを用いて説明してください。

---
**【解答】**
プログラムカウンタ（PC）が指すアドレスは、次に実行する命令が格納されている場所を示し、「プログラムの流れ」そのものを制御することが目的です。一方、スタックポインタ（SP）が指すアドレスは、サブルーチンからの戻り先アドレスや局所変数といったデータを「一時退避」させる場所を示し、プログラムの実行を補助することが目的です。

---
**【解説】**
この2つの違いは、応用情報技術者試験で頻出のひっかけポイントです。
*   **PC (Program Counter)**: 主役の実行フローを司る「司令官」。命令の実行順序という、プログラムの根幹を制御します。
*   **SP (Stack Pointer)**: 主役を支える「舞台裏のスタッフ」。サブルーチン呼び出しや割り込みといった特別なイベントが発生した際に、現在の状態（PCの値など）を一時的に保管し、後で復元するための場所を管理します。

PCは命令の流れを前に進めるためのレジスタ、SPはその流れが脇道にそれたときに、元の道に戻るための目印を置いておく場所を管理するレジスタ、と覚えると良いでしょう。

---
**【初心者が勘違いしやすい点】**
「どちらもアドレスを指すから似たようなものだろう」と安易に考えてしまうのが最大の罠です。PCが指す先は**コードセグメント**（命令が置かれている領域）、SPが指す先は**スタックセグメント**（データの一時退避領域）と、メモリ上の役割が異なる領域を指していることを理解することが、混同を避けるための鍵となります。

---
**【問6】**
CPUがある演算（例：加算、減算）を実行した後、その結果が「ゼロになった」「桁あふれ（オーバーフロー）が発生した」といった状態を記録しておくレジスタは何ですか。また、その情報は主にどのような処理で利用されますか。

---
**【解答】**
レジスタの名称は「ステータスレジスタ（PSW）」です。この情報は、主に「条件分岐」処理で利用されます。

---
**【解説】**
ステータスレジスタ、または **PSW (Program Status Word)** は、CPUの現在の状態や、直前の演算結果に関する情報（フラグ）を保持するレジスタです。*Status* は「状態」、*Word* はコンピュータが一度に処理するデータの単位を指します。
PSWには複数の**フラグ**（1ビットの情報）が含まれており、代表的なものに以下があります。
*   **ゼロフラグ (ZF)**: 演算結果がゼロになった場合に1になる。
*   **キャリーフラグ (CF)**: 桁あふれが発生した場合に1になる。
*   **サインフラグ (SF)**: 演算結果が負になった場合に1になる。

例えば、「2つの値を比較し、等しければ処理Aへ、等しくなければ処理Bへ進む」という条件分岐は、内部的には「2つの値の差を計算し（減算）、結果がゼロなら（ZF=1）、処理Aへジャンプする」という形で実現されています。

---
**【初心者が勘気に違いしやすい点】**
PSWを単に「演算結果を保持するレジスタ」と覚えてしまうと、演算データそのものを保持する汎用レジスタ（GPR）と混同しがちです。PSWが保持するのは、あくまで演算結果の「値」そのものではなく、その「**状態（Status）**」である、という点を強調して覚えてください。「答えは3です」ではなく、「答えはプラスでした」「答えはゼロではありませんでした」といったメタ情報を記録するのがPSWの役割です。

---
**【問7】**
サブルーチン内で定義された変数、いわゆる「局所変数」は、そのサブルーチンの実行中だけメモリ上に存在すれば十分です。このような一時的な変数のためのメモリ領域を、効率的に確保・解放するために利用されるレジスタは何ですか。

---
**【解答】**
スタックポインタ（SP）です。

---
**【解説】**
サブルーチンが呼び出されると、その中で使われる局所変数や引数のための領域がスタック上に確保されます。この確保は、**SP**の値を必要な分だけずらす（増減させる）ことで実現されます。そして、サブルーチンの処理が終了すると、SPの値を呼び出し前の位置に戻すことで、確保した領域がまとめて解放されます。
この仕組みにより、メモリ領域を動的かつ効率的に管理できます。特に、再帰呼び出し（自分自身を呼び出す関数）のように、同じサブルーチンが同時に複数実行されるような状況でも、それぞれの呼び出しごとに独立した変数領域をスタック上に確保できるため、プログラムが正しく動作します。

---
**【初心者が勘違いしやすい点】**
「変数はすべてメモリの決まった場所に確保される」と考えてしまうのは、静的変数のイメージに引きずられた誤解です。プログラム実行中に動的に生成・破棄される局所変数は、スタックという柔軟なメモリ管理機構によって支えられており、その中心にいるのがスタックポインタ（SP）である、と理解することが重要です。

---
**【問8】**
CPU内部には、演算対象のデータや計算途中の値を一時的に保持するために、プログラマが比較的自由に使えるレジスタ群が存在します。これらのレジスタの総称は何ですか。

---
**【解答】**
汎用レジスタ（GPR: General Purpose Register）です。

---
**【解説】**
汎用レジスタ、通称 **GPR (General Purpose Register)** は、その名の通り、特定の用途に限定されず、様々な目的で利用できるレジスタです。*General Purpose* は「汎用の」「多目的な」という意味です。
アセンブリ言語でプログラミングを行う際、メモリから読み出したデータを一時的に保持したり、演算装置（ALU）での計算結果を格納したりと、データ処理の中心的な役割を果たします。CPUアーキテクチャによって個数やビット幅は異なりますが、現代のCPUは多数の汎用レジスタを備えています。メモリへのアクセスは比較的低速なため、頻繁に利用するデータを高速なGPR上に保持しておくことで、プログラムの実行速度を大幅に向上させることができます。

---
**【初心者が勘違いしやすい点】**
他のレジスタ（PC, SPなど）が特定の役割を持つ「専用レジスタ」であるのに対し、GPRは「何でも屋」です。そのため、「汎用レジスタの役割は何か」と問われると答えに詰まることがあります。「演算対象のデータやアドレスを一時的に格納する、プログラムの作業台」と理解しておくと良いでしょう。

---
**【問9】**
割り込み処理が発生した際、CPUは現在実行しているプログラムを安全に中断し、割り込み処理ルーチンを実行した後に、何事もなかったかのように元のプログラムを再開する必要があります。この「安全な中断と再開」を実現するために、最低限スタックに退避させておくべき2つの重要なレジスタは何ですか。

---
**【解答】**
プログラムカウンタ（PC）とステータスレジスタ（PSW）です。

---
**【解説】**
割り込みが発生すると、CPUは以下の処理を自動的に（ハードウェア的に）行います。
1.  **PCの退避**: 割り込みから復帰した際に、どこから処理を再開すればよいかを示す「戻り先アドレス」、つまり現在のPCの値をスタックに退避させます。
2.  **PSWの退避**: 演算結果の状態（フラグ）や割り込み許可状態など、プログラムの実行状態を示すPSWの内容をスタックに退避させます。これを退避しないと、割り込み処理ルーチン内での演算によってフラグが書き換わり、元のプログラムの条件分岐などが正しく動作しなくなる恐れがあります。

この2つをスタックに退避させた後、PCに割り込み処理ルーチンの開始アドレスをセットして、割り込み処理を実行します。処理完了後、スタックからPSWとPCを元のレジスタに復元することで、プログラムは中断されたまさにその瞬間から、状態を完全に再現して実行を再開できます。

---
**【初心者が勘違いしやすい点】**
「なぜ汎用レジスタ（GPR）も退避しないのか」と疑問に思うかもしれません。GPRの退避は、ソフトウェア（OSやプログラマ）の責任で行うのが一般的です。割り込み処理ルーチンがどのGPRを書き換えるかによって、退避が必要なGPRは変わるためです。しかし、PCとPSWはプログラムの制御フローと状態の根幹であり、これをハードウェアレベルで自動退避させることが、システムの安定性を保証する上で極めて重要となります。

---
**【問10】**
あるCPUの命令実行サイクルは「フェッチ」「デコード」「実行」の3段階で構成されます。この一連のプロセスにおいて、プログラムカウンタ（PC）、命令レジスタ（IR）、汎用レジスタ（GPR）、ステータスレジスタ（PSW）が主に関与する段階を、それぞれ答えてください。

---
**【解答】**
*   **プログラムカウンタ（PC）**: フェッチ段階
*   **命令レジスタ（IR）**: フェッチ段階とデコード段階
*   **汎用レジスタ（GPR）**: 実行段階
*   **ステータスレジスタ（PSW）**: 実行段階

---
**【解説】**
命令実行サイクルにおける各レジスタの役割を時系列で整理しましょう。
1.  **フェッチ段階**: **PC**が指すアドレスから命令を読み出し、**IR**に格納します。PCの値もこの段階で更新されます。
2.  **デコード段階**: **IR**に格納された命令が解読され、どのような操作かが決定されます。
3.  **実行段階**: デコード結果に基づき、演算装置（ALU）が**GPR**からデータを読み出して演算を行い、結果を再び**GPR**に書き戻します。この演算結果に応じて**PSW**のフラグが更新されます。

このように、各レジスタはリレー走者のように、それぞれの持ち場で役割を果たしながら命令実行という一つのゴールに向かっています。

---
**【初心者が勘違いしやすい点】**
スタックポインタ（SP）がこのサイクルに登場しないことを不思議に思うかもしれません。SPが関与するのは、CALL命令（サブルーチン呼び出し）や割り込みといった、プログラムの制御フローを大きく変える特別な命令・イベントが発生した場合のみです。通常の加算やデータ転送などの命令サイクルでは、SPは直接的には関与しません。

---
**【問11】**
ステータスレジスタ（PSW）は、ゼロフラグやキャリーフラグといった「演算結果の状態」を保持するだけでなく、CPUの動作モードや割り込みの許可／禁止といった「CPU自体の状態」も管理します。後者の「CPU自体の状態」を管理する機能がなぜ重要なのか、その理由を説明してください。

---
**【解答】】**
OSなどのシステムプログラムが、ハードウェアを直接制御したり、複数のタスクの実行を管理したりする上で不可欠だからです。例えば、「割り込み禁止状態」に設定することで、OSがカーネルの重要な処理（タスク切り替えなど）を実行している最中に、他の割り込みによって処理が妨害されるのを防ぎ、システムの整合性を保つことができます。

---
**【解説】**
PSWが保持するCPUの状態情報には、以下のようなものがあります。
*   **割り込み許可フラグ (Interrupt Enable Flag)**: これがセットされていると、外部からの割り込みを受け付けます。OSは、クリティカルな処理を行う際にこのフラグをクリアし、一時的に割り込みをマスク（禁止）します。
*   **スーパーバイザ／ユーザモードフラグ**: CPUの動作モードを示します。OSカーネルは特権的な命令を実行できる**スーパーバイザモード**で動作し、一般のアプリケーションは制限された**ユーザモード**で動作します。この切り替えもPSWによって管理され、システムの安全性を確保します。

このように、PSWは単なる演算結果の記録係ではなく、OSがコンピュータシステム全体を安全かつ効率的に管理するための「制御盤」のような役割も担っているのです。

---
**【初心者が勘違いしやすい点】**
PSWの役割を演算結果のフラグだけに限定して理解してしまうと、OSや割り込みに関する問題で応用が利きません。「PSW = 演算結果の状態 ＋ CPUの制御状態」という、2つの側面を持つことをしっかり覚えておきましょう。

---
**【問12】**
関数Aが関数Bを呼び出し、さらにその関数Bが関数Cを呼び出す、という入れ子（ネスト）構造のプログラムを考えます。関数Cの処理が完了した後、プログラムが正しく関数Bの呼び出し元に戻り、さらに関数Bの完了後に関数Aの呼び出し元へ戻れるのはなぜですか。スタックの「LIFO」という特性とスタックポインタの働きを用いて説明してください。

---
**【解答】**
関数呼び出しのたびに、戻り先アドレスがスタックにPush（積まれる）されるためです。スタックは後入れ先出し（LIFO）構造なので、最も後で呼び出された関数Cの戻り先アドレスがスタックの一番上に積まれています。関数Cが終了すると、そのアドレスがPop（取り出され）て関数Bに戻ります。次にスタックの一番上にあるのは関数Bの戻り先アドレスなので、関数Bが終了するとそれがPopされて関数Aに戻ることができます。スタックポインタは、常にこの「一番上」のアドレスを指し示すことで、この一連の操作を正しく管理しています。

---
**【解説】**
このプロセスを具体的に見てみましょう。
1.  **A → Bを呼び出し**: Aの戻り先アドレス `Ret_A` をスタックにPush。
2.  **B → Cを呼び出し**: Bの戻り先アドレス `Ret_B` をスタックにPush。
    *   この時点でスタックは下から `[Ret_A], [Ret_B]` の順で積まれています。SPは `Ret_B` を指しています。
3.  **Cが終了**: スタックから `Ret_B` をPopしてPCにセット。Bに戻ります。
    *   スタックには `[Ret_A]` だけが残ります。SPは `Ret_A` を指しています。
4.  **Bが終了**: スタックから `Ret_A` をPopしてPCにセット。Aに戻ります。
    *   スタックは空になります。

このように、LIFO構造のおかげで、どれだけ深く関数がネストされても、呼び出しと逆の順序で正確に復帰することが可能になります。これは、スタックというデータ構造がプログラム実行においていかに強力であるかを示す好例です。

---
**【初心者が勘違いしやすい点】**
スタックの動きを頭の中だけで追うと混乱しがちです。上記のように、簡単な図や箇条書きでスタックに何が積まれ、SPがどこを指しているのかを実際に書き出してみることが、理解への一番の近道です。

---
**【問13】**
「スタックポインタは、サブルーチン呼び出し時に戻り先アドレスを格納するレジスタである」という説明は、厳密には不正確です。この説明のどこが誤っているのかを指摘し、より正確な説明に修正してください。

---
**【解答】**
誤っている点は、「戻り先アドレスを格納する**レジスタ**である」という部分です。
正確な説明は、「スタックポインタは、サブルーチン呼び出し時に戻り先アドレスなどが格納される**メモリ上のスタック領域のアドレス**を指し示すレジスタである」となります。

---
**【解説】**
この問題は、レジスタの役割に関する理解の解像度を問うものです。
*   **不正確な理解**: SPという「箱」の中に、戻り先アドレスという「データ」が入っている。
*   **正確な理解**: 戻り先アドレスという「データ」は、メモリ上のスタックという「倉庫」に置かれる。SPというレジスタは、その倉庫の「どこに」データが置かれているかを示す「住所録」の役割を持つ。

SP自体がデータを保持するわけではない、という点が極めて重要です。SPはあくまで「ポインタ（Pointer）」、つまりメモリ上の一点を指し示す役割に徹しています。

---
**【初心者が勘違いしやすい点】**
この違いを軽視すると、ポインタや間接アドレッシングといった、より高度なコンピュータアーキテクチャの概念を理解する上での妨げになります。「レジスタ」と「メモリ」の役割分担、そしてSPがその橋渡し役であることを、この機会に明確に区別しておきましょう。

---
**【問14】**
命令レジスタ（IR）とステータスレジスタ（PSW）は、どちらもCPU内部の状態を反映する点で似ているように見えますが、その情報の性質と目的は対照的です。この2つのレジスタの役割を、「CPUへの入力」と「CPUからの出力」という観点から対比して説明してください。

---
**【解答】**
命令レジスタ（IR）は、プログラムがCPUに対して「次に何をしてほしいか」を伝える**入力（指示書）**としての役割を持ちます。一方、ステータスレジスタ（PSW）は、CPUが命令を実行した結果、「どのような状態になったか」をプログラム側にフィードバックする**出力（報告書）**としての役割を持ちます。

---
**【解説】**
この比喩で考えると、2つのレジスタの違いが明確になります。
*   **IR (Instruction Register) は「To Doリスト」**: メモリから持ってきた「～を足しなさい」「～を移動させなさい」といった命令（指示）そのものが書かれており、CPUはこれを見て次の行動を決めます。
*   **PSW (Program Status Word) は「業務日報」**: 「加算した結果、桁あふれが発生しました」「減算した結果、答えがゼロになりました」といった、実行後の結果や状態が記録されます。プログラム（特に条件分岐命令）は、この日報を読んで次の判断を下します。

CPUという実行主体を真ん中に置いたとき、IRはプログラムからの入力、PSWはプログラムへの出力という、情報の流れの方向が真逆であると理解すると、混同を防ぐことができます。

---
**【初心者が勘違いしやすい点】**
試験問題では、この2つの説明文を入れ替えた選択肢が頻出します。「IRは演算結果の状態を保持する」「PSWは実行すべき命令を保持する」といった選択肢は典型的な誤りです。「Instruction（命令）→IR」、「Status（状態）→PSW」という英語の本来の意味に立ち返ることが、最も確実な対策となります。

---
**【問15】**
CPUのレジスタは、主記憶装置（メインメモリ）と比較してアクセス速度が桁違いに高速です。では、なぜコンピュータは全てのデータをレジスタに格納せず、大容量の主記憶装置を併用するのでしょうか。「速度」「容量」「コスト」の3つの観点から説明してください。

---
**【解答】**
レジスタは「速度」は非常に高速ですが、物理的なサイズが大きく製造「コスト」が高いため、CPU内に搭載できる「容量」が極めて小さいという特性があります。一方、主記憶装置は速度では劣るものの、ビットあたりのコストが安く、大容量化が容易です。そのため、両者の長所を活かし、頻繁に使うデータを高速なレジスタに、それ以外の大量のデータを大容量の主記憶装置に配置するという階層構造をとることで、システム全体の性能とコストのバランスを取っています。

---
**【解説】**
これはコンピュータの記憶階層の基本原則に関する問題です。
*   **レジスタ**: CPUコアと同じ半導体プロセスで作られるSRAM（Static RAM）ベースの記憶素子。高速だが、1ビットあたりの回路が複雑で高価。
*   **主記憶装置 (DRAM)**: コンデンサに電荷を蓄えることで情報を記憶するDRAM（Dynamic RAM）。回路が単純で高集積化しやすく安価だが、リフレッシュ動作が必要でアクセス速度はレジスタに劣る。

もし全てのデータをレジスタで構成しようとすれば、コンピュータは天文学的な価格になり、消費電力や発熱も甚大になります。現実的なコストで高性能なシステムを実現するため、この「適材適所」の考え方が採用されています。

---
**【初心者が勘違いしやすい点】**
「速いものが優れているのだから、全部レジスタにすれば良いのに」という素朴な疑問は、多くの初学者が抱くものです。しかし、コンピュータシステムは常に性能、容量、コストのトレードオフの上に成り立っています。このトレードオフの視点を持つことが、技術の本質を理解する上で非常に重要です。

---
**【問16】**
スタック領域に対してデータを追加するPush操作と、データを取り出すPop操作では、スタックポインタ（SP）が保持するアドレス値はどのように変化しますか。スタックがメモリの大きいアドレスから小さいアドレスに向かって伸長する（グロースダウン）一般的なアーキテクチャを前提として答えてください。

---
**【解答】**
*   **Push操作**: データをスタックに積むため、スタックポインタ（SP）の値は**減少**します。
*   **Pop操作**: スタックからデータを取り出すため、スタックポインタ（SP）の値は**増加**します。

---
**【解説】**
多くのCPUアーキテクチャ（x86など）では、スタックはメモリ空間の末尾（大きいアドレス）から先頭（小さいアドレス）に向かって成長します。これを空港の手荷物カートに例えてみましょう。
*   カートの初期位置（SPの初期値）が `0x1000` だとします。
*   **Push（荷物を積む）**: 新しい荷物を積むために、カートを少し手前（小さいアドレス側）に引きます。SPの値は `0x0FFC` のように**減少**し、その場所に荷物を置きます。
*   **Pop（荷物を降ろす）**: 一番上の荷物を降ろした後、カートを元の位置（大きいアドレス側）に戻します。SPの値は `0x1000` のように**増加**します。

このように、スタックがどちらの方向に伸びるかによってSPの値の増減は逆になりますが、試験で問われる一般的なモデルでは「Pushで減少し、Popで増加する」と覚えておくと良いでしょう。

---
**【初心者が勘違いしやすい点】**
直感的には「追加するのだからアドレスは増えるはず」と考えてしまいがちです。しかし、スタックの成長方向という前提条件を理解していないと、この問題には正しく答えられません。これは単なる暗記ではなく、メモリ空間におけるスタックの振る舞いをイメージできるかが問われる、一歩進んだ問題です。

---
**【問17】**
「プログラムカウンタは、次に実行する命令のアドレスを保持する」とされますが、命令の実行が完了した瞬間に、PCが指しているアドレスはどこですか。厳密に答えてください。

---
**【解答】**
現在実行が完了した命令の、**さらに次の**命令のアドレスを指しています。

---
**【解説】**
CPUの命令フェッチサイクルを思い出してください。
1.  **PCが指すアドレスから命令をフェッチする。**
2.  **フェッチ直後に、PCの値を次の命令のアドレスに更新（インクリメント）する。**
3.  フェッチした命令をデコードし、実行する。

つまり、ある命令を実行している最中、あるいは実行が完了した時点では、PCはすでに未来を指し示しているのです。これにより、現在の命令の実行が完了次第、間髪入れずに次の命令のフェッチに移ることができ、処理のパイプライン化と高速化に貢献しています。

---
**【初心者が勘違いしやすい点】】**
「実行中の命令のアドレスを指している」あるいは「実行完了した命令のアドレスを指している」という誤解がよく見られます。PCは常に一歩先を行く「予言者」のような存在である、と覚えておきましょう。この正確なタイミングの理解は、割り込み発生時に退避されるPCの値が何を意味するのかを考える上でも重要になります。

---
**【問18】**
あるプログラムで、2つの数値を比較して大小を判断する処理を実装します。このとき、アセンブリ言語レベルでは一般的に `CMP` (Compare) 命令が使われますが、この命令は直接的なジャンプを行いません。`CMP` 命令の実行結果を、後続の条件分岐命令（例: `JG` (Jump if Greater)）に引き継ぐ役割を担うレジスタは何ですか。

---
**【解答】**
ステータスレジスタ（PSW）です。

---
**【解説】**
`CMP` 命令は、内部的には2つのオペランドの減算を行います。しかし、その減算結果を汎用レジスタなどには格納しません。その代わり、減算結果の状態（結果は正か、負か、ゼロか）を**ステータスレジスタ（PSW）**の各種フラグ（サインフラグ、ゼロフラグなど）にセットします。
その後、`JG` (より大きければジャンプ) や `JE` (等しければジャンプ) といった条件分岐命令が、このPSWのフラグの状態を読み取ります。そして、指定された条件（例：「サインフラグが0で、かつゼロフラグが0である」= 結果が正である）を満たしていれば、プログラムカウンタ（PC）にジャンプ先のアドレスをセットします。
このように、`CMP` 命令と条件分岐命令は、PSWを介して連携することで、高度な制御フローを実現しています。

---
**【初心者が勘違いしやすい点】**
`CMP` 命令自体がプログラムの流れを変える（ジャンプする）と誤解しがちです。`CMP` はあくまで「判断材料を準備する」命令であり、実際の「判断と行動」は後続の条件分岐命令が行います。この役割分担を理解することが、低レイヤのプログラム動作を把握する鍵となります。

---
**【問19】**
CPUの主要レジスタ群を一つの劇団に例えます。「監督」「台本」「主演俳優」「舞台効果」「小道具係」という役割に、それぞれ最もふさわしいレジスタ（PC, IR, GPR, PSW, SP）を割り当て、その理由を説明してください。

---
**【解答】**
*   **監督**: **プログラムカウンタ（PC）**
    *   理由: 次にどのシーン（命令）を演じるかを常に指示し、物語（プログラム）全体の進行を管理するから。
*   **台本**: **命令レジスタ（IR）**
    *   理由: 現在演じているシーンの具体的な指示（命令）そのものが書かれており、俳優たちがそれを見て行動するから。
*   **主演俳優**: **汎用レジスタ（GPR）**
    *   理由: 実際にデータ（セリフや小道具）を持って演算（演技）を行い、物語の中心で活躍するから。
*   **舞台効果**: **ステータスレジスタ（PSW）**
    *   理由: 俳優の演技（演算）の結果、「緊迫した雰囲気になった（桁あふれ）」「決着がついた（ゼロになった）」といった舞台の状態を記録し、次のシーンの展開（条件分岐）に影響を与えるから。
*   **小道具係**: **スタックポインタ（SP）**
    *   理由: 俳優が一時的に舞台袖に退場する（サブルーチン呼び出し）際に、持っていた小道具や台本のページ番号（レジスタや戻り先アドレス）を預かる場所を管理する、裏方の重要な役割を担うから。

---
**【解説】**
この比喩は、各レジスタの役割と相互関係を体系的に理解するのに役立ちます。
*   監督（PC）が「次のページを読め」と指示し、
*   俳優（GPR）が台本（IR）を読み、
*   演技（演算）をします。
*   その結果、舞台の雰囲気（PSW）が変わり、
*   監督（PC）は観客の反応を見て次のシーン（分岐先）を決めます。
*   登場人物が増えたり退場したりする（サブルーチン呼び出し）際には、小道具係（SP）が舞台裏を整理します。

このように、一見無関係に見えるレジスタ群が、一つのプログラムを上演するために見事に連携している様子がイメージできます。

---
**【初心者が勘違いしやすい点】**
レジスタを個別の暗記事項として捉えると、その関連性が見えなくなりがちです。このような比喩を用いることで、断片的な知識が有機的に結びつき、応用情報技術者試験で問われるような、複合的で本質的な問いにも対応できる思考力が養われます。

---
**【問20】**
「スタックポインタ（SP）は、主にサブルーチン呼び出しの戻り先アドレスを管理するために存在する」という説明は正しいですが、不十分です。サブルーチン呼び出し以外で、SPとスタックが決定的に重要な役割を果たす場面を2つ挙げ、それぞれなぜ必要不可欠なのかを説明してください。

---
**【解答】**
1.  **割り込み処理**: 予期せぬ割り込みが発生した際、実行中のプログラムのPC（戻り先）やPSW（状態）をスタックに自動退避させるため。これにより、割り込み処理後に元のプログラムを何事もなかったかのように再開でき、システムの安定性が保たれる。
2.  **局所変数の動的な領域確保**: サブルーチン内で使用される一時的な変数のメモリ領域を、実行時にスタック上に確保・解放するため。これにより、メモリを効率的に利用できるだけでなく、再帰呼び出しのように同一サブルーチンが複数同時に存在する場合でも、それぞれの変数が独立して管理される。

---
**【解説】**
SPの役割をサブルーチン呼び出しだけに限定してしまうと、その重要性を見誤ります。
*   **割り込み処理**は、現代のOSがマルチタスクを実現する上で根幹となる技術です。タイマー割り込みによるタスク切り替えなど、あらゆる場面でスタックによるコンテキスト（実行状態）の退避・復元が行われています。
*   **局所変数の管理**は、C言語やJavaなど、ほとんどの高級プログラミング言語が構造化プログラミングを実現するための基盤となっています。私たちが普段何気なく書いている関数内の変数が、スタックとSPのおかげで正しく機能しているのです。

SPは、プログラムの構造的な実行と、予期せぬイベントへの対応という、静と動の両面から現代のコンピュータシステムを支える、縁の下の力持ちと言えるでしょう。

---
**【初心者が勘違いしやすい点】】**
試験では、SPの役割として「サブルーチン呼び出し」が最もよく問われるため、それ以外の用途についての意識が薄れがちです。しかし、応用情報技術者としては、割り込み処理やメモリ管理といった、よりシステム全体の動作に関わる視点からSPの役割を理解しておくことが、深い知識の証明となります。

---

## CPUの主要レジスタ解説

### 1. CPUの主要レジスタの概要と比較

CPUには、それぞれ特定の役割を持つ複数のレジスタが存在します。命令を実行する流れに沿って理解することが効果的です。

```text
【CPU内の主要レジスタと役割】
 ┌─────────────────┐
 │ プログラムカウンタ（PC） │ → 次に実行する命令のアドレスを保持
 ├─────────────────┤
 │ 命令レジスタ（IR）        │ → 現在実行中の命令そのものを保持
 ├─────────────────┤
 │ スタックポインタ（SP）    │ → スタックの最上段のアドレスを保持
 │                           │   （戻りアドレス，局所変数，退避レジスタ）
 ├─────────────────┤
 │ ステータスレジスタ（PSW） │ → 演算結果の状態，割込み許可状態を保持
 ├─────────────────┤
 │ 汎用レジスタ（GPR）       │ → データや演算結果など、汎用的に値を保持
 └─────────────────┘
```
**【学習のポイント】この並び順（PC→IR→SP→PSW）の意味**
この順序は、CPUが命令を実行する一連の流れ「**命令の流れを指す(PC) → 命令を取り込む(IR) → 実行結果を保持する(PSW)**」に沿っています。SPは、サブルーチン呼び出しなどでこの流れを補助する役割を果たします。この順序で覚えることで、各レジスタの関連性を体系的に理解しやすくなります。

#### 1.1. 主要レジスタの機能比較表

| レジスタ名 | 保持する内容 | 主な用途 | 試験で狙われる混同 |
| :--- | :--- | :--- | :--- |
| **プログラムカウンタ (PC)** | 次に実行する命令のアドレス | 命令の逐次実行を制御 | SPと混同しやすい |
| **命令レジスタ (IR)** | メモリから読み出した実行中の命令（機械語命令そのもの） | 命令デコーダが解釈し、CPUの各部へ制御信号を出す | PCと混同しやすい |
| **スタックポインタ (SP)** | スタック領域の最上段のアドレス | サブルーチン呼出し、割込み処理、局所変数の管理 | PCやIRと混同しやすい |
| **ステータスレジスタ (PSW)** | 演算結果の状態（フラグ）、割込み許可状態 | 条件分岐、例外処理の制御 | IRと混同しやすい |
| **汎用レジスタ (GPR)** | データ、計算途中の値、アドレスなど | プログラムのデータ処理の主体 | - |

### 2. スタックポインタ(SP)の詳細解説

#### 2.1. 定義と役割
スタックポインタ（Stack Pointer, SP）は、メモリ上にある**スタック領域の最上段のアドレスを保持する**ための専用レジスタです。スタックは、後入れ先出し（LIFO: Last-In, First-Out）のデータ構造であり、SPはデータの格納（Push）や取り出し（Pop）が行われる位置を常に指し示しています。

#### 2.2. 技術的な必要性
SPとスタックは、プログラムの実行において以下の重要な課題を解決します。

- **サブルーチン呼び出し**: サブルーチンを実行した後、呼び出し元の次の命令へ正確に戻る必要があります。そのための**復帰先アドレス**をスタックに一時的に保存し、その場所をSPで管理します。
- **局所変数の確保**: サブルーチン内でだけ使用する一時的な変数（局所変数）の領域を、スタック上に動的に確保・解放するためにSPが利用されます。
- **割り込み処理**: 割り込みが発生した際、実行中のプログラムの状態（PCやPSWなど）をスタックに退避させて処理を中断し、割り込み処理完了後に正確に復帰するために必須です。

### 3. 具体例で理解する：サブルーチン呼び出しとスタック操作

メインルーチンがサブルーチンを呼び出す際、CPUとスタックは以下のように連携して動作します。

1.  **復帰先アドレスの退避 (Push)**
    メインルーチンの次に実行される命令のアドレス（現在のPCの値）を、SPが指すスタック領域に格納（Push）します。
2.  **サブルーチンへジャンプ**
    サブルーチンの開始アドレスをPCに設定し、処理を移します。
3.  **局所変数領域の確保**
    サブルーチン内で局所変数が必要な場合、SPの値をずらしてスタック上に領域を確保します。
4.  **サブルーチン実行**
    サブルーチンの処理を行います。
5.  **局所変数領域の解放**
    サブルーチン終了時、確保した局所変数領域を解放するため、SPの値を元に戻します。
6.  **復帰先アドレスの復元 (Pop)**
    SPが指すスタック領域から退避させていた復帰先アドレスを取り出し（Pop）、PCに設定します。これにより、メインルーチンの元の場所へ処理が戻ります。

### 4. 応用情報技術者試験の攻略ポイント

#### 4.1. 試験の着眼点と頻出パターン
試験では「**どのレジスタが、どの情報を保持しているか**」を正確に区別できるかが問われます。特に、以下の混同を狙った選択肢が多く見られます。
- **PCとSPの違い**: 「次に実行する命令のアドレス」はPC、「スタックの最上段のアドレス」はSPです。出題者はこの2つを入れ替えた選択肢で受験者を混乱させようとします。
- **IRとPSWの違い**: 「実行中の命令そのもの」はIR、「演算結果の状態やフラグ」はPSWです。

#### 4.2. 典型的な正答例と誤答例
以下は、スタックポインタが問われた際の典型的な選択肢のパターンです。

- **【正答例】**
  - `サブルーチン呼出し時に，戻り先アドレス及びレジスタの内容を格納するメモリのアドレス`
  - *解説：SPは、これらの情報が格納されるスタック領域の先頭アドレスを指します。*

- **【誤答例（他のレジスタの説明）】**
  - `次に読み出す機械語命令が格納されているアドレス`
  - *解説：これは**プログラムカウンタ(PC)**の説明です。*
  - `メモリから読み出された機械語命令`
  - *解説：これは**命令レジスタ(IR)**の説明です。*
  - `割込みの許可状態，及び条件分岐の判断に必要な演算結果の状態`
  - *解説：これは**ステータスレジスタ(PSW)**の説明です。*

#### 4.3. よくある誤解と正しい知識

| 誤解 | 正しい知識 |
| :--- | :--- |
| SPは「最後に参照されたアドレス」を保持する。 | SPは「**スタックの最上段のアドレス**（次にPush/Popされる場所）」を保持する。 |
| SPは命令の流れを管理する。 | 命令の流れを管理するのは**PC**。SPはデータの一時的な保存場所を管理する。 |
| 局所変数はメモリの固定領域に置かれる。 | 局所変数は、実行時に**スタック領域に動的に確保**されるのが一般的である。 |

### 5. 【発展】命令実行サイクルと各レジスタの連携

CPUは「フェッチ → デコード → 実行」というサイクルで命令を処理します。この流れの中で各レジスタがどのように連携するかを知ると、理解がさらに深まります。

**例：`ADD R1, R2` （R1にR2を加算）という命令の実行サイクル**

1.  **フェッチ（命令の取り出し）**
    - **PC**が指すメモリアドレス（例: `0x1000`）から命令 `ADD R1, R2` を読み出します。
    - 読み出された命令は**IR (命令レジスタ)**に格納されます。
    - **PC**は次の命令のアドレス（例: `0x1004`）を指すよう更新されます。
2.  **デコード（命令の解釈）**
    - 命令デコーダが**IR**の内容を解釈し、「R1とR2の値を加算する」という処理内容を特定します。
3.  **実行（演算）**
    - 演算装置(ALU)が**汎用レジスタ** R1とR2から値を読み出し、加算処理を実行します。
    - 演算結果（`R1 + R2` の値）は、再び**汎用レジスタ** R1に書き込まれます。
    - 演算結果の状態（ゼロになったか、桁あふれしたか等）が**PSW (ステータスレジスタ)**の各フラグに反映されます。

この一連のサイクルにおいて、サブルーチン呼び出し（CALL命令）や割り込みが発生した場合にのみ、**SP (スタックポインタ)**が補助的に動作し、PCやレジスタの内容をスタックに退避・復元します。