# 自己結合で、重複を取り除く二つの方法

（１）DISTINCT
# このSQLクエリで `DISTINCT` がなぜ必要なのか、


-- 同じ家族だけど、住所が違うレコードを検索する SQL
```
SELECT DISTINCT A1.name, A1.address
  FROM Addresses A1 INNER JOIN Addresses A2
    ON A1.family_id = A2.family_id
   AND A1.address <> A2.address;
```

# このクエリは、Addressesという一つのテーブルをA1とA2という2つの名前（エイリアス）で扱い、自分自身と結合（自己結合）しています。

# FROM句が最も早く実行されるので、ここでエイリアスを使って、二つの表にしている。

### 1. `FROM`句が最初に評価される
SQLクエリがどのように実行されるかを論理的に考えると、`FROM`句が最初に評価されます。
データベースはまず、どのテーブルからデータを取得してくるかを確定させる必要があります。

**論理的な実行順序の一般的なイメージ:**
1.  **`FROM` / `JOIN`**: どのテーブルを結合して、巨大な仮想的なテーブルを作るかを決定する。
2.  `WHERE`: その仮想テーブルから、条件に合わない行をフィルタリングする。
3.  `GROUP BY`: 残った行をグループ化する。
4.  `HAVING`: グループ化した結果から、条件に合わないグループをフィルタリングする。
5.  **`SELECT`**: 最終的にどの列を表示するかを決定する。
6.  `DISTINCT`: 表示する列の中から重複を取り除く。
7.  `ORDER BY`: 結果を並べ替える。

この順序で考えると、`FROM`句でテーブルの準備が行われるというのは正しいです。

### 2. エイリアスで「二つの表として扱う」という考え方

これも非常に良い捉え方です。
より厳密に言うと、物理的に新しいテーブルを2つコピーして作っているわけではありません。
**「同じ一つの`Addresses`テーブルを、このクエリの中だけで、あたかも別々のテーブルであるかのように扱えるように、`A1`と`A2`という2つの名前（インスタンス）をつけている」**
という状態です。

したがって、
**「SQLはまず`FROM`句を評価し、そこで`Addresses`テーブルに対して`A1`と`A2`という2つの独立した参照（エイリアス）を作成する。これにより、一つのテーブルを二つの異なるテーブルと見なして、行同士を比較することが可能になる。」**



# 二つの異なるテーブルとしてみなした後、これらを以下の2つの条件で絞り込んでいます。
# A1.family_id = A2.family_id
 同じ家族であること
#  A1.address <> A2.address
住所が異なること
これにより、「同じ家族IDを持っているにもかかわらず、住所が異なるレコード」を抽出することができます。


### 結論から言うと

**「同じ家族に、住所が違う人が2人以上いる場合」に、同じレコードが複数回表示されてしまうのを防ぐため**です。

このクエリの目的は「同じ家族なのに住所が違う」という状態になっているレコード（人）を**リストアップ**することです。重複してリストアップする必要はありません。

---

### 具体的な例

以下のような `Addresses` テーブルがあったとします。
`family_id`が101の家族には、太郎、花子、次郎の3人がいて、全員住所が異なっています。

| name | address | family_id |
| :--- | :--- | :--- |
| 太郎 | 東京都 | 101 |
| 花子 | 大阪府 | 101 |
| 次郎 | 名古屋市 | 101 |
| 健太 | 北海道 | 102 |

このテーブルに対して、`DISTINCT` **なし**で自己結合（self-join）を実行するとどうなるか見てみましょう。

```sql
SELECT A1.name, A1.address
FROM Addresses A1 INNER JOIN Addresses A2
  ON A1.family_id = A2.family_id
 AND A1.address <> A2.address;
```

この結合は、`family_id` が同じで `address` が違うレコードのペアをすべて見つけ出します。

1.  **A1が「太郎」の場合**
    *   A2の「花子」とペアになる → `A1.family_id = A2.family_id` (101=101) かつ `A1.address <> A2.address` (東京≠大阪) なので条件に一致。 **結果に「太郎, 東京都」が追加される。**
    *   A2の「次郎」とペアになる → `A1.family_id = A2.family_id` (101=101) かつ `A1.address <> A2.address` (東京≠名古屋) なので条件に一致。 **結果に「太郎, 東京都」が再び追加される。**

2.  **A1が「花子」の場合**
    *   A2の「太郎」とペアになる → 条件に一致。 **結果に「花子, 大阪府」が追加される。**
    *   A2の「次郎」とペアになる → 条件に一致。 **結果に「花子, 大阪府」が再び追加される。**

3.  **A1が「次郎」の場合**
    *   A2の「太郎」とペアになる → 条件に一致。 **結果に「次郎, 名古屋市」が追加される。**
    *   A2の「花子」とペアになる → 条件に一致。 **結果に「次郎, 名古屋市」が再び追加される。**

`DISTINCT` をつけないと、以下のような重複した結果になってしまいます。

| name | address |
| :--- | :--- |
| 太郎 | 東京都 |
| 太郎 | 東京都 |  <-- 重複
| 花子 | 大阪府 |
| 花子 | 大阪府 |  <-- 重複
| 次郎 | 名古屋市 |
| 次郎 | 名古屋市 |  <-- 重複

これでは「どの人が条件に合致するか」という情報が冗長になってしまいます。

そこで `DISTINCT` を使うことで、これらの重複を排除し、条件に合致する人を一意なリストとして取得できます。

```sql
SELECT DISTINCT A1.name, A1.address
...
```

**`DISTINCT` ありの結果:**

| name | address |
| :--- | :--- |
| 太郎 | 東京都 |
| 花子 | 大阪府 |
| 次郎 | 名古屋市 |

このように、期待通りのスッキリした結果が得られます。これが `DISTINCT` が必要な理由です。



User
DISTINCT A1.name, A1.address　DINTINCTは２つの属性の重複を除くんだね

はい、その通りです！素晴らしい着眼点ですね。

`DISTINCT`は、`SELECT`句で指定された**すべての列の組み合わせ**が完全に一致する行を重複とみなし、それらを1つにまとめます。

今回の `SELECT DISTINCT A1.name, A1.address` の場合、

*   `A1.name` **と** `A1.address` の両方の値がセットで同じ行
*   を重複として扱います。

### 具体例

`DISTINCT`を適用する前のデータがこのようになったとします。

| A1.name | A1.address |
| :--- | :--- |
| 田中 | 東京都 |
| 田中 | 東京都 |  <-- 1行目と完全に重複
| 田中 | 大阪府 |  <-- nameは同じだがaddressが違う
| 鈴木 | 北海道 |

このデータに `SELECT DISTINCT A1.name, A1.address` を適用すると、

1.  1行目の `('田中', '東京都')` は結果に含まれます。
2.  2行目の `('田中', '東京都')` は、1行目と**nameとaddressの組み合わせが全く同じ**なので、重複とみなされ**除外**されます。
3.  3行目の `('田中', '大阪府')` は、nameは同じですがaddressが違うため、`('田中', '東京都')`とは**別の組み合わせ**と判断され、結果に含まれます。
4.  4行目の `('鈴木', '北海道')` は、他と重複していないので結果に含まれます。

最終的な結果は以下のようになります。

| A1.name | A1.address |
| :--- | :--- |
| 田中 | 東京都 |
| 田中 | 大阪府 |
| 鈴木 | 北海道 |

このように、`DISTINCT`は指定された複数の列を「1つのペア（またはセット）」として見て、そのセットが重複しているかどうかを判断します。



# **自己結合（セルフジョイン）のときには `DISTINCT` が非常によく使われます。**

それは、自己結合の特性上、意図せず重複した結果が生まれやすいためです。
主な理由は2つあります。

---

### 理由1：1つのレコードが、複数のレコードと条件に合致する場合 (今回の例)

これはまさに、最初の画像で見てきたケースです。

*   `family_id`が同じ家族の中に、住所が違う人が3人（太郎、花子、次郎）いるとします。
*   「太郎」のレコードを基準（`A1`）にすると、比較相手（`A2`）として「花子」と「次郎」の両方が結合条件に合致してしまいます。
*   これにより、「太郎」のレコードが結果セットに2回含まれることになります。

私たちが知りたいのは「条件に合致する人は誰か？」というリストであり、その人が何組のペアを作れたかではありません。そのため、`DISTINCT` を使って重複を排除し、人を1回だけリストアップする必要があります。

### 理由2：関係性が対称的（Symmetrical）な場合

自己結合は「ペア」を探すのによく使われますが、そのペアの関係が対称的だと重複が発生します。

**例：同じ都市に住んでいる人のペアを探す**

`Users` テーブル
| name | city |
| :--- | :--- |
| 佐藤 | 東京 |
| 鈴木 | 東京 |
| 高橋 | 大阪 |

```sql
-- 同じ都市に住む人の名前をリストアップする
SELECT u1.name
  FROM Users u1 JOIN Users u2
    ON u1.city = u2.city  -- 同じ都市
   AND u1.name <> u2.name; -- 自分自身ではない
```

このSQLを実行するとどうなるでしょうか。

1.  `u1`が「佐藤」のとき、`u2`は「鈴木」とマッチします → 結果に「佐藤」が追加される。
2.  `u1`が「鈴木」のとき、`u2`は「佐藤」とマッチします → 結果に「鈴木」が追加される。

この例では結果の重複は発生していませんが、「佐藤さんと鈴木さんのペア」は `(佐藤, 鈴木)` と `(鈴木, 佐藤)` の2回見つかっています。もしペアそのものを表示すると重複します。



（２）　DISTINCTを使わない方法
# DINTINCTを使わない方法
この「対称的な重複」を避けるためによく使われるテクニックが、`DISTINCT` ではなく **`id` や `name` など一意なカラムで大小比較をする方法**です。

```sql
-- 対称的な重複を避ける書き方
SELECT u1.name, u2.name
  FROM Users u1 JOIN Users u2
    ON u1.city = u2.city
   AND u1.name < u2.name; -- u1の名前がu2より小さいものだけ
```
こうすると、`(佐藤, 鈴木)` のペアは見つかりますが、`(鈴木, 佐藤)` は `u1.name < u2.name` の条件に合わないため、ペアが1度しか現れなくなります。これは `DISTINCT` よりも効率的な場合があります。

### まとめ

*   自己結合は、テーブル内の行同士を比較するため、**1つの行が複数の行とマッチ**したり、**対称的なペア (`A-B` と `B-A`)** が生まれたりしやすく、結果が重複しやすいです。
*   そのため、**最終的に得たい結果に合わせて `DISTINCT` を使うのは非常に一般的なプラクティス**です。
*   場合によっては、`DISTINCT` の代わりに `A.id < B.id` のような条件式で重複を防ぐ、より効率的な方法もあります。