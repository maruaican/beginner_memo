# CSRF（Cross-Site Request Forgery）対策:二重送信防止トークン（ワンタイムトークン）の仕組み

### CSRF攻撃が成立する前提

まず、なぜこの対策が必要なのかを理解するために、CSRF攻撃がどのように行われるかを簡単に確認します。

1.  **正規サイトへのログイン:** 利用者は、銀行やSNSなどの正規のWebサイトにログインしています。ブラウザには、そのサイトのセッション情報が入ったCookieが保存されています。
2.  **罠サイトへのアクセス:** 攻撃者が用意した罠サイト（掲示板やメール内のリンクなど）に利用者がアクセスします。
3.  **意図しないリクエストの送信:** 罠サイトには、正規サイトの機能を悪用するリクエスト（例：「パスワード変更」「送金」など）を自動的に送信するスクリプトが埋め込まれています。
4.  **攻撃の成立:** 利用者のブラウザは、正規サイトへのリクエストを送信する際、**自動的にCookieを添付**します。正規サイトのサーバーは、Cookieによって利用者がログイン済みであると判断し、そのリクエストが本人の意思によるものだと誤認して処理を実行してしまいます。

この攻撃のポイントは、「**正規サイトが、リクエストの送信元がどこであるかを検証せず、Cookieの有無だけで本人からのリクエストだと信じてしまう**」点にあります。

### 二重送信防止トークン（CSRFトークン）の詳細な仕組み

ご提示の①〜④のステップを、さらに詳しく見ていきましょう。この仕組みは「シンクロナイザトークンパターン（Synchronizer Token Pattern）」とも呼ばれます。

#### ① 【サーバー】トークンの生成とセッションへの保存
*   **いつ生成するか？** 重要な情報を扱うフォーム画面（個人情報入力、パスワード変更など）へのリクエストがあった際に、サーバーサイドで生成します。
*   **どうやって生成するか？** 最も重要なのは「**攻撃者に推測されないこと**」です。そのため、`random_bytes()` のような暗号論的に安全な疑似乱数生成器（CSPRNG）を使って、十分に長い（例：32バイト以上）ランダムな文字列を生成します。
*   **どこに保存するか？** 生成したトークンは、利用者のセッション情報に紐づけてサーバー上に保存します。 これにより、後で送信されてきたトークンが、このセッションのためにサーバー自身が発行したものであることを確認できます。

#### ② 【サーバー → ブラウザ】フォームへのトークンの埋め込み
*   生成したトークンを、HTMLの`<form>`タグ内に、以下のように`hidden`（隠し）タイプの`<input>`要素として埋め込みます。

    ```html
    <form action="/update_password" method="post">
        <input type="password" name="password">
        <input type="hidden" name="csrf_token" value="【ここにサーバーで生成したトークン文字列が入る】">
        <button type="submit">パスワード変更</button>
    </form>
    ```

*   `hidden`タイプにすることで、利用者の画面には表示されませんが、フォーム送信時には他のデータと一緒にサーバーに送られます。

#### ③ 【ブラウザ → サーバー】フォームとトークンの送信
*   利用者がフォームに情報を入力し、「パスワード変更」ボタンなどを押すと、ブラウザはフォーム内のすべてのデータ（この例ではパスワードと`csrf_token`）をサーバーに送信します。

#### ④ 【サーバー】トークンの検証
*   リクエストを受け取ったサーバーは、以下の2つを比較します。
    1.  **リクエストから受け取ったトークン** (`POST`データに含まれる`csrf_token`の値）
    2.  **セッションに保存しておいたトークン**（手順①で保存したもの）
*   この比較には、タイミング攻撃（処理時間のわずかな差から情報を推測する攻撃）を防ぐため、`hash_equals()` のような文字列を安全に比較する関数を使用することが推奨されます。
*   **トークンが一致した場合:** 正規の画面からのリクエストであると判断し、パスワード変更などの処理を続行します。
*   **トークンが一致しない、または存在しない場合:** 外部のサイトからの不正なリクエストである可能性が高いと判断し、リクエストを拒否してエラー処理（例：403 Forbiddenエラーを返す）を行います。

---

### なぜこの対策が有効なのか？

この仕組みの核心は、「**攻撃者は、正規の利用者のセッションに紐づいた正しいトークンの値を知ることができない**」という点にあります。

*   **トークンはサーバーと利用者のブラウザの間だけで共有される秘密の情報**です。
*   攻撃者が罠サイトに偽のフォームを用意しても、そこに埋め込むべき正しい`csrf_token`の値を知る術がありません。
*   ブラウザの「**同一生成元ポリシー（Same-Origin Policy）**」というセキュリティ機能により、攻撃者のサイト（例：`evil.com`）から、正規サイト（例：`bank.com`）のHTMLコンテンツを読み取ってトークンを盗み見ることはできません。

結果として、攻撃者が送信させるリクエストには正しいトークンが含まれないため、サーバーはそれを不正なリクエストとしてブロックできるのです。

### 補足と注意点

*   **ワンタイムトークンとしての利用:** セキュリティをさらに高めるためには、フォームを表示するたびに新しいトークンを生成し、一度使われたトークンは無効化する（ワンタイムにする）のが理想的です。 これにより、ブラウザの「戻る」ボタンによる再送信なども防ぐことができます。
*   **Ajax通信での利用:** JavaScriptを使った非同期通信（Ajax）でデータを送信する場合もCSRF対策は必須です。その場合、トークンをHTMLの`<meta>`タグなどに埋め込み、JavaScriptでその値を読み取ってリクエストヘッダー（`X-CSRF-Token`など）に含めて送信する方法が一般的です。
*   **他の対策との併用:** 近年では、Cookieの`SameSite`属性（特に`Lax`や`Strict`）を設定することで、外部サイトからのリクエスト時にCookieが送信されなくなり、CSRF攻撃自体を防ぐ効果も期待できます。これらの複数の対策を組み合わせることで、Webアプリケーションはより堅牢になります。