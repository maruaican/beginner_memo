
---

# 応用情報技術者試験対策：INとNOT INの徹底解説（NULLの罠とEXISTSによる回避策）

応用情報技術者試験（AP試験）のデータベース分野において、`IN`および`NOT IN`演算子は頻出ですが、特に`NOT IN`と`NULL`の組み合わせは、多くの受験者が陥りやすい「ひっかけ問題」の定番です。
ここでは、これらの演算子の基本から、試験で問われる核心部分、そして安全な代替策までを体系的に解説します。

## 1. IN / NOT IN 演算子の概要

### 1.1. 定義と役割
`IN`と`NOT IN`は、特定の列の値が、指定した値のリストやサブクエリ（副問い合わせ）の結果セットに「含まれるか」「含まれないか」を判定するための述語です。

| 演算子 | IPAによる定義 |
| **IN** | 列の値が指定リストまたはサブクエリ結果に含まれるかを判定するSQL演算子 |
| **NOT IN** | 列の値が指定リストまたはサブクエリ結果に含まれないかを判定するSQL演算子 |

これらの名称は、英語の"in"（～の中に）と"not in"（～の中にない）が語源となっており、集合論における要素の判定が由来です。

### 1.2. 必要性：なぜこれらの演算子が必要か？
複数の値を条件として効率的に行を絞り込みたい場合に、これらの演算子は非常に有効です。例えば、以下のような課題を解決します。
*   特定の部署に所属する複数の社員情報を一度に取得したい。
*   ある商品カテゴリに含まれる全商品の売上を抽出したい。
*   **注文履歴のない顧客を抽出したい。**

特に最後の例は、`NOT IN`の挙動を理解する上で重要なシナリオであり、試験でも頻出のテーマです。

## 2. IN 演算子の使い方とNULLの扱い

`IN`は、サブクエリやリストに`NULL`が含まれていても、それを無視して判定を行うため、直感的に理解しやすく安全に利用できます。

### 2.1. 具体例
以下のサンプルテーブルを使って、`IN`の動作を確認します。

**【顧客テーブル】**
| 顧客ID | 顧客名 |
| 1 | 佐藤 |
| 2 | 鈴木 |
| 3 | 高橋 |
| 4 | 田中 |

**【注文テーブル】**
| 注文ID | 顧客ID | 商品名 |
| 101 | 1 | ペン |
| 102 | 3 | ノート |
| 103 | NULL | 消しゴム |

**【SQL実行例】注文をしたことがある顧客を抽出する**
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID IN (SELECT 顧客ID FROM 注文);
```

**【出力結果】**
```
顧客名
佐藤
高橋
```
注文テーブルの`顧客ID`には`{1, 3, NULL}`が存在しますが、`IN`演算子は`NULL`を無視して`1`と`3`に合致する顧客を正しく抽出します。

## 3. NOT IN 演算子と「NULLの罠」

`NOT IN`は、「集合に含まれない」ことを判定しますが、その集合内に**1つでも`NULL`が存在すると、結果が意図せず0件になる**という重大な特性があります。これが応用情報技術者試験で繰り返し問われる「ひっかけポイント」です。

### 3.1. なぜNULLで結果が空になるのか？ - 3値論理の仕組み
この現象は、SQLが採用している**3値論理（TRUE / FALSE / UNKNOWN）** に起因します。`NOT IN` 演算子は、比較対象の集合内に1つでも`UNKNOWN`と評価される値（`NULL`との比較）が含まれていると、条件全体を真（TRUE）と判定しません。その結果、すべての行が除外されてしまいます。

### 3.2. 正しい対策：サブクエリからNULLを排除する
この問題を回避するには、`NOT IN`の比較対象となるサブクエリから、あらかじめ`NULL`値を除外する必要があります。

**【SQL実行例（正答）】**
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID NOT IN (
    SELECT 顧客ID FROM 注文 WHERE 顧客ID IS NOT NULL
);
```
サブクエリに`WHERE 顧客ID IS NOT NULL`を追加することで、`NULL`との比較（`UNKNOWN`）が発生しなくなり、意図した通りの結果が得られます。

## 4. 安全な代替策：NOT EXISTS 演算子

`NOT IN`の`NULL`問題を回避するための、よりシンプルで安全な方法が`NOT EXISTS`です。
`NOT EXISTS`は行の「存在」のみをチェックするため、`NULL`の存在に影響されません。
この評価方法は**2値論理（TRUE / FALSE）** に基づいており、`NULL`との比較で`UNKNOWN`が発生する`NOT IN`とは根本的に仕組みが異なります。

**【SQL実行例】**
```sql
SELECT 顧客名
FROM 顧客 c
WHERE NOT EXISTS (
    SELECT 1 FROM 注文 o WHERE o.顧客ID = c.顧客ID
);
```
このSQLは、`NOT IN`の正答例と同じ結果を、サブクエリ内で`NULL`を意識することなく得られます。

## 5. 評価プロセスと出力結果の視覚的比較

`NOT IN`と`NOT EXISTS`の挙動の違いを、各行がどのように評価され、最終的にどう出力されるかを見ていきましょう。

### 5.1. NOT IN の場合

```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID NOT IN (SELECT 顧客ID FROM 注文);
```

**【評価表】**
| 顧客ID | 顧客名 | 1≠顧客ID | 3≠顧客ID | NULL≠顧客ID | 最終結果（全体） | 行取得 |
| :--- | :--- | :---: | :---: | :---: | :---: | :---: |
| 1 | 佐藤 | `FALSE` | `TRUE` | `UNKNOWN` | `FALSE` | × |
| 2 | 鈴木 | `TRUE` | `TRUE` | `UNKNOWN` | `UNKNOWN` → `FALSE` | × |
| 3 | 高橋 | `TRUE` | `FALSE` | `UNKNOWN` | `FALSE` | × |
| 4 | 田中 | `TRUE` | `TRUE` | `UNKNOWN` | `UNKNOWN` → `FALSE` | × |

**→ 出力結果：**
```
顧客名
（空）
```
* サブクエリの結果全体を1つの「集合」として扱う
* メインテーブルの行ごとに、この 集合との比較 を行う
* 比較は「全ての値と≠か？」で判断される
* 1つでも NULL があると UNKNOWN になり、行は除外される
* つまり 行ごとに判定はしているが、サブクエリの集合全体を基準にして評価する → 3値論理が作用

* サブクエリの`NULL`があるため、全件除外されてしまいます。
* これが典型的な試験のひっかけポイントです。

### 5.2. NOT EXISTS の場合
```sql
SELECT 顧客名
FROM 顧客 c
WHERE NOT EXISTS (
    SELECT 1 FROM 注文 o WHERE o.顧客ID = c.顧客ID
);
```
**【評価表】**
| 顧客ID | 顧客名 | サブクエリ `o.顧客ID = c.顧客ID` の一致行 | 存在するか？ | `NOT EXISTS` 評価 | 行取得 |
| :--- | :--- | :--- | :---: | :---: | :---: |
| 1 | 佐藤 | 1行存在 | `TRUE` | `FALSE` | × |
| 2 | 鈴木 | なし | `FALSE` | `TRUE` | ○ |
| 3 | 高橋 | 1行存在 | `TRUE` | `FALSE` | × |
| 4 | 田中 | なし | `FALSE` | `TRUE` | ○ |

**→ 出力結果：**
```
顧客名
鈴木
田中
```
* サブクエリは メインテーブルの1行ごとに実行
* 「サブクエリで一致する行があるかどうか」を判定
* NULL があっても o.顧客ID = c.顧客ID が FALSE になるだけ → 影響なし
* つまり 行ごとに独立してTRUE/FALSEで評価される → 安全

* `NULL`があっても影響を受けず、正しく「注文していない顧客」を抽出できます。

## 6. 演算子の比較と使い分け

| 項目 | IN | NOT IN | NOT EXISTS |
| :--- | :--- | :--- | :--- |
| **判定条件** | 値が集合に含まれる | 値が集合に含まれない | 行が存在しないか |
| **NULLとの関係** | 無視される | **`NULL`があると結果が0件になる** | 無関係 |
| **評価論理** | 3値論理 | 3値論理 | 2値論理 |
| **パフォーマンス** | 比較的軽量 | 重い/注意が必要 | 高速な傾向 |

## 7. 試験対策：一問一答チェック

**1 問題：** 注文をしていない顧客を抽出するSQLとして、より安全なものはどれか？
**回答：** `NOT EXISTS`を使用するか、`NOT IN`のサブクエリで`WHERE 顧客ID IS NOT NULL`のように`NULL`を明示的に除外するSQL。

**2 問題：** `IN`を使ったサブクエリに`NULL`が含まれている場合、`NULL`はどのように扱われるか？
**回答：** 無視される。`NULL`は判定条件に影響を与えない。

**3 問題：** `SELECT * FROM T1 WHERE COL1 NOT IN (SELECT COL2 FROM T2);` というSQLで、サブクエリの結果に`NULL`が含まれている場合、結果はどうなるか？
**回答：** 0件（空）になる。

**4 問題：** `NOT IN`を`NOT EXISTS`に置き換えた場合、サブクエリ内の`NULL`の影響はどうなるか？
**回答：** 影響を受けなくなる。`NULL`が存在しても、意図した通りに「存在しない行」を抽出できる。

## 8. まとめ
*  1. **`IN`**は集合に含まれるかを判定し、**`NULL`を無視する**ため安全に利用できます。
*  2. **`NOT IN`**は集合に含まれないかを判定しますが、比較対象に**`NULL`が1つでも含まれると結果が0件になる**ため、サブクエリでの`NULL`除外が必須です。
*  3. `NOT IN`の`NULL`問題を回避し、より安全かつ高速な処理を期待できる **`NOT EXISTS`への書き換え**が推奨されます。