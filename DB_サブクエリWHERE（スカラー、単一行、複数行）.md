
### WHERE句におけるサブクエリの解説

`WHERE`句は、テーブルから特定の条件に合致する行を**絞り込む**ための重要な句です。
この条件式に固定の値（例：`WHERE 給与 > 300000`）を指定するだけでなく、別のSQL（サブクエリ）の実行結果を動的に利用することができます。

サブクエリが返す結果の形（行数と列数）によって、`WHERE`句での使い方や組み合わせる演算子が異なります。

サブクエリ (Subquery)
├── 単一行サブクエリ (Single-Row Subquery)
│   └── ★ スカラーサブクエリ (Scalar Subquery)  <-- 1行かつ1列の特別なケース
└── 複数行サブクエリ (Multi-Row Subquery)
重要なのは、**スカラーサブクエリは単一行サブクエリの一種（最も特殊な形）**であるという点です。
---

### 1. スカラーサブクエリ（1行1列の値と比較する）

スカラーサブクエリは、結果として**必ず1行1列の単一の値**（スカラー値）を返します。集計関数（`MAX`, `AVG`, `SUM`など）を用いた問い合わせが典型例です。

*   **戻り値**: 1行1列
*   **使用演算子**: `=`, `<`, `>`, `<=`, `>=`, `<>`
*   **考え方**: サブクエリ全体が「**一つの確定した値**」に置き換わると考えます。そのため、単純な比較演算子が利用できます。

#### SQL例：全商品の平均単価を上回る単価の商品を抽出する

```sql
SELECT 商品名, 単価
FROM 商品マスタ
WHERE 単価 > (SELECT AVG(単価) FROM 商品マスタ);
```

**解説**:
1.  まず、サブクエリ `(SELECT AVG(単価) FROM 商品マスタ)` が実行され、全商品の平均単価という**単一の値**（例：`1500`）が計算されます。
2.  次に、主文のSQLは `WHERE 単価 > 1500` と解釈され、各商品の単価がこの平均値を超えているかどうかを判定します。

---

### 2. 単一行サブクエリ (複数列)（一対の複数項目で比較する）

このサブクエリは、**単一行ですが、複数の列**を返します。特定の単一レコードが持つ複数の属性値を「一組のデータ」として扱いたい場合に非常に有効です。

*   **戻り値**: 1行複数列
*   **使用演算子**: `=`
*   **考え方**: 複数の列を `()` で囲んで「**行の組（タプル）**」として扱い、サブクエリが返す「行の組」と完全に一致するかを判定します。

#### SQL例：特定の社員と全く同じ「所属部署」と「役職」を持つ社員を抽出する

```sql
SELECT 社員名, 所属部署コード, 役職コード
FROM 社員マスタ
WHERE (所属部署コード, 役職コード) = (SELECT 所属部署コード, 役職コード FROM 社員マスタ WHERE 社員番号 = 'S0010')
  AND 社員番号 <> 'S0010';
```

**解説**:
1.  サブクエリは、社員番号'S0010'の人物の所属部署コードと役職コードの**一組の値**（例：`('DEP02', 'MGR')`）を返します。
2.  主文のSQLは、各社員の `(所属部署コード, 役職コード)` の組が、サブクエリの返した組 `('DEP02', 'MGR')` と一致するかを評価します。これにより、複数の条件を `AND` で個別に繋ぐよりも、意図が明確で簡潔なSQLを記述できます。

---

### 3. 複数行サブクエリ（値のリストと比較する）

複数行サブクエリは、結果として**複数行1列の値**、つまり「**値のリスト（集合）**」を返します。

*   **戻り値**: 複数行1列
*   **使用演算子**: `IN`, `NOT IN`, `ANY`, `ALL`
*   **考え方**: サブクエリが返すのは値のリストなので、`=` のような単一値向けの演算子は使えません。「リストに含まれるか」「リストのいずれかの値より大きいか」「リストのすべての値より大きいか」といった、集合に対する比較演算子を用います。

#### SQL例：大阪支社のいずれかの社員と同じ給与額の、東京支社の社員を抽出する

```sql
SELECT 社員名, 給与
FROM 社員
WHERE 勤務地 = '東京'
  AND 給与 IN (SELECT 給与 FROM 社員 WHERE 勤務地 = '大阪');
```

**解説**:
1.  サブクエリ `(SELECT 給与 FROM 社員 WHERE 勤務地 = '大阪')` が実行され、大阪支社に勤務する社員の給与の**リスト**（例：`(250000, 320000, 450000)`）が返されます。
2.  主文のSQLは、東京支社の社員の中から、給与がこのリストの**いずれかの値と一致する**社員を `IN` 演算子で絞り込みます。
3.  もしここで誤って `WHERE 給与 = ...` と記述すると、サブクエリが複数の値を返す可能性があるため、エラーが発生します。この「`=`と`IN`の使い分け」は、試験で頻繁に問われる重要ポイントです。

### 4.１ 複数行サブクエリ（IN / NOT IN / ANY / ALL）の詳論

### １－１サンプル

```
顧客（customer）
+---------+--------+
| 顧客ID  | 顧客名 |
+---------+--------+
| C001    | 佐藤   |
| C002    | 鈴木   |
| C003    | 高橋   |
| C004    | 田中   |
+---------+--------+

注文（orders）
+---------+---------+--------+
| 注文番号| 顧客ID  | 金額   |
+---------+---------+--------+
| O001    | C001    | 5000   |
| O002    | C002    | 8000   |
| O003    | C003    | 12000  |
+---------+---------+--------+
```
※定義（IPA準拠）
IN：複数行サブクエリの結果に一致するかどうかを判定。
NOT IN：一致しない場合を判定。
ANY：複数行サブクエリのいずれかと比較して条件を満たす。
ALL：複数行サブクエリのすべてと比較して条件を満たす。

### １－２　SQL例と結果

### （１）IN （WHERE句複数サブクエリ）
「注文が存在する顧客をすべて抽出」
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID IN (SELECT 顧客ID FROM 注文);
```
※顧客表（FROM）を（注文表に**存在する**顧客ID）にある顧客IDで絞り込む（WHERE）
**結果**
```
佐藤
鈴木
高橋
```
（田中C004は注文なし → 出力されない）
---
### （２）NOT IN （WHERE句複数サブクエリ）
「注文が**存在しない**顧客を抽出」

```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID NOT IN (SELECT 顧客ID FROM 注文);
```
※顧客表（FROM）を（注文表に**存在しない**顧客ID）にある顧客IDで絞り込む（WHERE）

**結果**
```
田中
```
---
### （３）ANY （WHERE句複数サブクエリ）
「注文金額が 1万円を超える顧客をすべて抽出」
（ANYは「いずれか」と比較する）
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID = ANY (
    SELECT 顧客ID FROM 注文 WHERE 金額 > 10000
);
```
**結果**
```
高橋
```
（注文O003：12000 > 10000）
---
### （４）ALL （WHERE句複数サブクエリ）
「すべての注文金額が1万円以上の顧客をすべて抽出」
```sql
SELECT 顧客名
FROM 顧客
WHERE 顧客ID = ALL (
    SELECT 顧客ID FROM 注文 WHERE 金額 >= 10000
);
```
**結果**
```
高橋
```
（C003高橋の注文だけがすべて1万円以上）
---
# １－３　試験の着眼点

* **IN／NOT IN** は「集合との一致／不一致」
* **ANY／ALL** は「比較演算子と組み合わせて使う」

  * `> ANY` = 最小値より大きいか
  * `< ALL` = 最大値より小さいか
* 出題者は「`ANY` と `ALL` を混同させる」パターンをよく狙う。

---

# １－４　比較表 （WHERE句複数サブクエリ）

| 句      | 意味             | 例の結果     |
| ------ | -------------- | -------- |
| IN     | 集合のいずれかと一致     | 佐藤・鈴木・高橋 |
| NOT IN | 集合のどれとも一致しない   | 田中       |
| ANY    | 集合のいずれかとの比較に一致 | 高橋       |
| ALL    | 集合のすべてとの比較に一致  | 高橋       |

---

# １－５　代表例（正答例・誤答例）

* **正答例**：`WHERE 金額 > ANY (SELECT 金額 FROM 注文)`
* **誤答例**：`WHERE 金額 > ALL (SELECT 金額 FROM 注文)`（ANYとALLを取り違える）

---

# １－６　よくある誤解と正しい知識

* 誤解：`ANY` は `IN` と同じ意味。
* 正解：`ANY` は「比較演算子付き」で動作する。`= ANY` なら `IN` と等価だが、`> ANY` なら「最小値より大きい」になる。

---

# １－７　一問一答

**Q1** INを使うときの典型的な使い方は？
→ **集合のいずれかと一致**。`= ANY` と等価。

**Q2** NOT INの注意点は？
→ サブクエリの結果に`NULL`があると全体が成立しなくなる。

**Q3** `> ANY (集合)` の意味は？
→ 集合の最小値より大きければ成立。

**Q4** `< ALL (集合)` の意味は？
→ 集合の最大値より小さければ成立。

**Q5** 試験で狙われやすい誤解は？
→ ANYとALLを「IN/NOT IN」と混同させること。

---

# １－８　要約（3行以内）

* **IN／NOT IN** は「集合の一致／不一致」。
* **ANY／ALL** は「比較演算子＋集合」で条件を判定。
* 出題者はANYとALLの取り違えを狙う。

---

#### 各演算子の詳細と注意点

| 演算子 | 判定内容 | 思考パターン / 備考 |
| :--- | :--- | :--- |
| **IN** | 集合に含まれるか | `=ANY` と同義。 |
| **NOT IN** | 集合に含まれないか | **注意**: サブクエリの結果に **NULL が含まれると、比較結果が UNKNOWN となり、全ての行が対象外**になる。 |
| **=ANY** | 集合のどれか1つと等しいか | `IN` と同義。OR的な判定。 |
| **>ANY** | 集合のいずれかの値より大きいか | 「集合の中の**最小値**より大きい」ことと同じ。 |
| **<ANY** | 集合のいずれかの値より小さいか | 「集合の中の**最大値**より小さい」ことと同じ。 |
| **=ALL** | 集合の全てと等しいか | 全ての候補が同じ値でない限り成立しないため、実用性は低い。 |
| **>ALL** | 集合の全てより大きいか | 「集合の中の**最大値**より大きい」ことと同じ。 |
| **<ALL** | 集合の全てより小さいか | 「集合の中の**最小値**より小さい」ことと同じ。 |

#### よくある質問と誤解（Q&A）
*   **Q1. `IN` と等価な表現はどれか。**
    *   **A1.** `=ANY`。集合の中のいずれか一つに一致すればよいため。
*   **Q2. 「給与が部署10の全員より高い社員」を求めるにはどの演算子か。**
    *   **A2.** `>ALL`。全員との比較はAND条件に相当するため。
*   **Q3. 「給与が部署10の誰か一人より高い社員」を求めるにはどの演算子か。**
    *   **A3.** `>ANY`。一人でも超えればよいOR条件に相当するため。
*   **Q4. `NOT IN` のサブクエリに `NULL` が含まれるとどうなるか。**
    *   **A4.** 全ての比較が `UNKNOWN` となり、結果は0件になる。
*   **Q5. 「すべての候補値に等しい」を表すのはどの演算子か。**
    *   **A5.** `=ALL`。ただし、実用上ほとんど使われない。










### 2.3. EXISTS / NOT EXISTS との組み合わせ
サブクエリが1行以上の結果を返すかどうか（存在するかどうか）を判定します。多くの場合、相関サブクエリと組み合わせて使用されます。

*   **目的**: 関連するデータが存在するかどうかに基づいて行を抽出する。
*   **特徴**: サブクエリが返す実際の値は無視され、行の有無のみが評価されます。詳細は「4. 相関サブクエリ」の章で解説します。

### 2.4. WHERE句サブクエリの注意点と試験対策

#### 代表的な誤答・凡ミス
1.  **スカラサブクエリが複数行を返してエラー**
    *   **原因**: `=` などの比較演算子を使っているのに、サブクエリが複数行を返してしまうケース。
    *   **対策**: サブクエリが必ず1行1列になるよう、`MAX`, `MIN`, `AVG` などの集約関数を使うか、`IN` 演算子に切り替える。
2.  **`NOT IN` でのNULLの扱いによる意図しない結果**
    *   **原因**: `NOT IN` のサブクエリ結果に `NULL` が含まれていると、比較が `UNKNOWN` となり、意図せず結果が0件になる。
    *   **対策**: `NOT EXISTS` を使用する方が安全。
3.  **EXISTS と IN の意味の違いの混同**
    *   **原因**: `IN` は「値の集合」に含まれるかを比較するのに対し、`EXISTS` はサブクエリの「行の存在」そのものを問う。この違いを理解せず、使い分けを誤る。
4.  **相関サブクエリと非相関サブクエリの混同**
    *   **原因**: 外側の行ごとにサブクエリが実行される相関サブクエリの構造を理解せず、非効率なクエリを作成してしまう。

#### 性能上の留意点
*   **相関サブクエリ**: 外側の各行ごとにサブクエリが実行されるため、行数が増えると性能が低下しやすい。インデックスの活用が重要。
*   **非相関サブクエリ**: サブクエリは一度だけ実行され、その結果がキャッシュされることが多い。ただし、巨大な結果セットを生成する場合は注意が必要。
*   **EXISTS**: 条件を満たす最初の行が見つかった時点で評価が終了する（早期終了）ため、`IN` よりも高速になることがある。
*   **JOINへの書き換え**: サブクエリは `JOIN` を使って書き換えられる場合があり、オプティマイザがインデックスを効率的に利用できるため、性能が向上することがある。