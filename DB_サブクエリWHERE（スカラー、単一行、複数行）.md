
### WHERE句におけるサブクエリの解説

`WHERE`句は、テーブルから特定の条件に合致する行を**絞り込む**ための重要な句です。
この条件式に
（１）固定の値（例：`WHERE 給与 > 300000`）を指定するだけでなく、
（２）サブクエリの動的な実行結果を利用することができます。


サブクエリが返す結果の形（行数と列数）によって、`WHERE`句での使い方や組み合わせる演算子が異なります。

サブクエリ (Subquery)
├── 単一行サブクエリ (Single-Row Subquery)
│   └── ★ スカラーサブクエリ (Scalar Subquery)  <-- 1行かつ1列の特別なケース
└── 複数行サブクエリ (Multi-Row Subquery)

重要な点は、**スカラーサブクエリは単一行サブクエリの一種（最も特殊な形）**であるということ。
---

### 1. スカラーサブクエリ（1行1列の値（単一の値）と比較する）

スカラーサブクエリは、結果として**必ず1行1列の単一の値**（スカラー値）を返します。
集計関数（`MAX`, `AVG`, `SUM`など）を用いた問い合わせが典型例です。

*   **戻り値**: 1行1列（単一の値）
*   **使用演算子**: `=`, `<`, `>`, `<=`, `>=`, `<>`
*   **考え方**: サブクエリ全体が「**一つの確定した値**」に置き換わると考えます。そのため、単純な比較演算子が利用できます。

#### SQL例：全商品の平均単価を上回る単価の商品を抽出する

```sql
SELECT 商品名, 単価
FROM 商品マスタ
WHERE 単価 > (SELECT AVG(単価) FROM 商品マスタ);
```

**解説**:
1.  まず、サブクエリ `(SELECT AVG(単価) FROM 商品マスタ)` が実行され、全商品の平均単価という**単一の値**（例：`1500`）が計算されます。
2.  次に、主文のSQLは `WHERE 単価 > 1500` と解釈され、各商品の単価がこの平均値を超えているかどうかを判定します。

---
### 2. 単一行サブクエリ (複数列)（複数カラムが完全に一致するものを絞り込む）

このサブクエリは、**単一行ですが、複数の列**を返します。特定の単一レコードが持つ複数の属性値を「一組のデータ」として扱いたい場合に非常に有効です。

*   **戻り値**: 1行複数列
*   **使用演算子**: `=`
*   **考え方**: 複数の列を `()` で囲んで「**行の組（タプル）**」として扱い、サブクエリが返す「行の組」と完全に一致するかを判定します。

#### SQL例：特定の社員と全く同じ「所属部署」と「役職」を持つ社員を抽出する

```sql
SELECT 社員名, 所属部署コード, 役職コード
FROM 社員マスタ
WHERE (所属部署コード, 役職コード) = (SELECT 所属部署コード, 役職コード FROM 社員マスタ WHERE 社員番号 = 'S0010')
  AND 社員番号 <> 'S0010';
```

**解説**:
1.  サブクエリは、社員番号'S0010'の人物の所属部署コードと役職コードの**一組の値**（例：`('DEP02', 'MGR')`）を返します。
2.  このSQLは、各社員の `(所属部署コード, 役職コード)` の組（**２つのカラム両方とも**）が、サブクエリの返した組 `('DEP02', 'MGR')` と一致するものをリストアップします。
これにより、複数の条件を `AND` で個別に繋ぐよりも、意図が明確で簡潔なSQLを記述できます。

---

### 3. 複数行サブクエリ（値のリスト【集合】と比較する）

複数行サブクエリは、結果として**複数行1列の値**、つまり「**値のリスト【集合】**」を返します。

*   **戻り値**: 複数行1列
*   **使用演算子**: `IN`, `NOT IN`, `ANY`, `ALL`
*   **考え方**: サブクエリが返すのは値のリスト【集合】なので、`=` のような単一値向けの演算子は使えません。「リストに含まれるか」「リストのいずれかの値より大きいか」「リストのすべての値より大きいか」といった、集合に対する比較演算子を用います。

#### SQL例：大阪支社のいずれかの社員と同じ給与額の、東京支社の社員を抽出する

```sql
SELECT 社員名, 給与
FROM 社員
WHERE 勤務地 = '東京'
  AND 給与 IN (SELECT 給与 FROM 社員 WHERE 勤務地 = '大阪');
```

**解説**:
1.  サブクエリ `(SELECT 給与 FROM 社員 WHERE 勤務地 = '大阪')` が実行され、大阪支社に勤務する社員の給与の**リスト【集合】**（例：`(250000, 320000, 450000)`）が返されます。
2.  主文のSQLは、東京支社の社員の中から、給与がこのリストの**いずれかの値と一致する**社員を `IN` 演算子で絞り込みます。
3.  もしここで誤って `WHERE 給与 = ...` と記述すると、サブクエリが複数の値を返す可能性があるため、エラーが発生します。この **「`=`と`IN`の使い分け」**は、試験で頻繁に問われる重要ポイントです。

### 4.１ 複数行サブクエリ（IN / NOT IN / ANY / ALL）の詳論

### **WHERE句の役割：行を選択するための評価式**

まず、`WHERE`句の根本的な役割は、「`FROM`句で指定されたテーブルの一行ごとに、そこに書かれた条件式が**真 (TRUE)** になるか、**偽 (FALSE)** になるかを評価すること」です。

データベースシステムは、テーブルの`全行`を対象にこの評価を行い、条件式が**真 (TRUE) となった行だけ**を集めて、最終的な問い合わせ結果として返します。

サブクエリは、この評価で使われる「比較対象となる値のリスト【集団】」を動的に生成する部品です。

#### **サンプルのテーブル**

以下の2つのテーブルを例として使用します。

**`社員`テーブル** (主テーブル)

| 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
| :--- | :--- | :--- | :--- | :--- |
| S001 | 鈴木 | 営業部 | リーダー | 85 |
| S002 | 田中 | 開発部 | マネージャー| 95 |
| S003 | 佐藤 | 営業部 | 一般 | 70 |
| S004 | 高橋 | 経理部 | 一般 | 75 |
| S005 | 渡辺 | 開発部 | リーダー | 90 |

**`重点プロジェクト部門`テーブル** (サブクエリで使用)

| 部署名 |
| :--- |
| 開発部 |
| 経理部 |

---

###　（１） **IN**

`WHERE`句に指定された列の値が、サブクエリが生成した値のリストの**いずれかの値と等しい**場合、その行に対する評価は**真 (TRUE)** となります。

*   **評価プロセス**:
    `WHERE 列A IN (SELECT 列X FROM TableB)` という条件式は、`FROM`句のテーブルから取り出した一行の `列A` の値について、以下の論理式と同じ評価を行います。
    *   `列A = (サブクエリ結果1) OR 列A = (サブクエリ結果2) OR ...`
    *   この `OR` 条件のいずれか一つでも成立すれば、式全体が**真 (TRUE)** と評価されます。

*   **選択される行**:
    上記評価が**真 (TRUE)** となった行が、最終的な結果として選択されます。

*   **サンプルSQL**:
    `重点プロジェクト部門`に所属する社員を検索します。
    ```sql
    SELECT *
    FROM 社員
    WHERE 所属部署 IN (SELECT 部署名 FROM 重点プロジェクト部門);
    ```
    ※サブクエリは `('開発部', '経理部')` というリストを返します。

*   **出力結果**:
    | 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
    | :--- | :--- | :--- | :--- | :--- |
    | S002 | 田中 | 開発部 | マネージャー| 95 |
    | S004 | 高橋 | 経理部 | 一般 | 75 |
    | S005 | 渡辺 | 開発部 | リーダー | 90 |

###　（２）  **NOT IN**

`WHERE`句に指定された列の値が、サブクエリが生成した値のリストの**どの値とも等しくない**場合、その行に対する評価は**真 (TRUE)** となります。

*   **評価プロセス**:
    `WHERE 列A NOT IN (SELECT 列X FROM TableB)` という条件式は、以下の論理式と同じ評価を行います。
    *   `列A <> (サブクエリ結果1) AND 列A <> (サブクエリ結果2) AND ...`
    *   この `AND` 条件がすべて成立した場合にのみ、式全体が**真 (TRUE)** と評価されます。

*   **選択される行**:
    上記評価が**真 (TRUE)** となった行が、最終的な結果として選択されます。

*   **サンプルSQL**:
    `重点プロジェクト部門`に所属して**いない**社員を検索します。
    ```sql
    SELECT *
    FROM 社員
    WHERE 所属部署 NOT IN (SELECT 部署名 FROM 重点プロジェクト部門);
    ```

*   **出力結果**:
    | 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
    | :--- | :--- | :--- | :--- | :--- |
    | S001 | 鈴木 | 営業部 | リーダー | 85 |
    | S003 | 佐藤 | 営業部 | 一般 | 70 |

###　（３）  **ANY**

`WHERE`句に指定された列の値と、サブクエリが生成した値のリストの各値とを比較演算子で評価した結果、その**いずれか一つでも真 (TRUE) になれば**、その行に対する評価は**真 (TRUE)** となります。

*   **評価プロセス**:
    `WHERE 列A > ANY (SELECT 列X FROM TableB)` という条件式は、以下の論理式と同じ評価を行います。
    *   `(列A > サブクエリ結果1) OR (列A > サブクエリ結果2) OR ...`
    *   この `OR` 条件のいずれか一つでも成立すれば、式全体が**真 (TRUE)** と評価されます。

*   **選択される行**:
    上記評価が**真 (TRUE)** となった行が、最終的な結果として選択されます。（これは実質的に、`列A` がサブクエリ結果の最小値より大きいことを意味します。）

*   **サンプルSQL**:
    営業部の**誰か一人でもいいので**、その人より評価点が高い社員を全社から検索します。
    ```sql
    SELECT *
    FROM 社員
    WHERE 評価点 > ANY (SELECT 評価点 FROM 社員 WHERE 所属部署 = '営業部');
    ```
    ※サブクエリは営業部の評価点リスト `(85, 70)` を返します。条件は「70点より大きい」と実質的に同じになります。

*   **出力結果**:
    | 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
    | :--- | :--- | :--- | :--- | :--- |
    | S001 | 鈴木 | 営業部 | リーダー | 85 |
    | S002 | 田中 | 開発部 | マネージャー| 95 |
    | S004 | 高橋 | 経理部 | 一般 | 75 |
    | S005 | 渡辺 | 開発部 | リーダー | 90 |

###　（４）  **ALL**

`WHERE`句に指定された列の値と、サブクエリが生成した値のリストの各値とを比較演算子で評価した結果、その**すべてが真 (TRUE) になった場合のみ**、その行に対する評価は**真 (TRUE)** となります。

*   **評価プロセス**:
    `WHERE 列A > ALL (SELECT 列X FROM TableB)` という条件式は、以下の論理式と同じ評価を行います。
    *   `(列A > サブクエリ結果1) AND (列A > サブクエリ結果2) AND ...`
    *   この `AND` 条件がすべて成立した場合にのみ、式全体が**真 (TRUE)** と評価されます。

*   **選択される行**:
    上記評価が**真 (TRUE)** となった行が、最終的な結果として選択されます。（これは実質的に、`列A` がサブクエリ結果の最大値より大きいことを意味します。）

*   **サンプルSQL**:
    営業部の**全員**よりも評価点が高い社員を全社から検索します。
    ```sql
    SELECT *
    FROM 社員
    WHERE 評価点 > ALL (SELECT 評価点 FROM 社員 WHERE 所属部署 = '営業部');
    ```
    ※サブクエリは営業部の評価点リスト `(85, 70)` を返します。条件は「85点より大きい」と実質的に同じになります。

*   **出力結果**:
    | 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
    | :--- | :--- | :--- | :--- | :--- |
    | S002 | 田中 | 開発部 | マネージャー| 95 |
    | S005 | 渡辺 | 開発部 | リーダー | 90 |
---
# １－３　試験の着眼点

* **IN／NOT IN** は「集合との一致／不一致」
* **ANY／ALL** は「比較演算子と組み合わせて使う」

  * `> ANY` = 最小値より大きいか
  * `< ALL` = 最大値より小さいか
* 出題者は「`ANY` と `ALL` を混同させる」パターンをよく狙う。

---

## `IN`と`ANY`の違い【重要】

### 結論から：一番大事な違い

*   **`IN`** は、**「＝（等しい）」** の比較しかできません。
*   「このリストの中に、**全く同じものが存在しますか？**」という、**所属確認**のための演算子です。

*   **`ANY`** は、**「＞」や「＜」などの比較演算子**と一緒に使います。
*   「このリストの中の、**どれか一つにでも勝てますか？（あるいは負けますか？）**」という、**大小比較**のための演算子です。

この「**イコールだけの`IN`**」と「**大小比較もできる`ANY`**」という点が、根本的な違いです。

---

### ２つの演算子を並べて、徹底比較してみましょう

同じ`社員`テーブルと、比較対象として**営業部の評価点リスト `(85, 70)`** を使って、両者の動きの違いを見ていきます。

#### **`IN`**：ゲストリストでの本人確認

`IN`は、リストに**含まれているか**、その一点のみをチェックします。

**例題**: 「評価点が、営業部の評価点リスト `(85, 70)` の**どちらかと一致する**社員は誰か？」

```sql
SELECT 氏名, 評価点
FROM 社員
WHERE 評価点 IN (85, 70);```

**SQLの頭の中**:
*   鈴木(85点) → リストに `85` があるか？ → YES → **選択**
*   田中(95点) → リストに `95` があるか？ → NO → 除外
*   佐藤(70点) → リストに `70` があるか？ → YES → **選択**
*   高橋(75点) → リストに `75` があるか？ → NO → 除外
*   渡辺(90点) → リストに `90` があるか？ → NO → 除外

**出力結果**:
| 氏名 | 評価点 |
| :--- | :--- |
| 鈴木 | 85 |
| 佐藤 | 70 |

---

#### **`ANY`**：大会での予選通過

`ANY`は、リストの中の**誰か一人にでも**勝てればOK、というルールです。

**例題**: 「評価点が、営業部の評価点リスト `(85, 70)` の**どちらか一つより大きい**社員は誰か？」

```sql
SELECT 氏名, 評価点
FROM 社員
WHERE 評価点 > ANY (85, 70);
```

**SQLの頭の中**:
*   鈴木(85点) → `85 > 85` はNO。`85 > 70` はYES。**OR条件なので、一つでもYESならOK** → **選択**
*   田中(95点) → `95 > 85` はYES。その時点でOK → **選択**
*   佐藤(70点) → `70 > 85` はNO。`70 > 70` はNO。すべてNO → 除外
*   高橋(75点) → `75 > 85` はNO。`75 > 70` はYES。OK → **選択**
*   渡辺(90点) → `90 > 85` はYES。その時点でOK → **選択**

**出力結果**:
| 氏名 | 評価点 |
| :--- | :--- |
| 鈴木 | 85 |
| 田中 | 95 |
| 高橋 | 75 |
| 渡辺 | 90 |

---

### 最大の混乱ポイント： `= ANY` は `IN` と同じ

`ANY`は `>` や `<` だけでなく `=` とも一緒に使えます。そして、`= ANY` と書いた場合、**`IN`と全く同じ意味になります。**

`WHERE 評価点 = ANY (85, 70)`

これは、
「`評価点 = 85` **OR** `評価点 = 70`」
と解釈されます。

これは、
`WHERE 評価点 IN (85, 70)`
と完全に同じ動きをします。

この事実が、多くの人を混乱させる原因です。`IN`は`= ANY`の、より直感的で分かりやすい書き方だと考えてください。

### まとめ

| 特徴 | `IN` | `ANY` |
| :--- | :--- | :--- |
| **目的** | リストとの**完全一致**を確認する | リストの**どれか一つ**との大小比較を行う |
| **使う演算子** | **`=`** のみ (暗黙的に) | **`=`、`>`、`<`、`<>`** などと一緒に使う |
| **キーワード** | **所属確認** (Is it IN the list?) | **予選通過** (Can it beat ANYONE in the list?) |
| **`= ANY`との関係** | `IN` は `= ANY` と**全く同じ**意味 | `ANY`は `IN` の機能を包含するが、大小比較が主戦場 |

---

# １－７　一問一答

**Q1** INを使うときの典型的な使い方は？
→ **集合のいずれかと一致**。`= ANY` と等価。

**Q2** NOT INの注意点は？
→ サブクエリの結果に`NULL`があると全体が成立しなくなる。

**Q3** `> ANY (集合)` の意味は？
→ 集合の最小値より大きければ成立。

**Q4** `< ALL (集合)` の意味は？
→ 集合の最大値より小さければ成立。

**Q5** 試験で狙われやすい誤解は？
→ ANYとALLを「IN/NOT IN」と混同させること。

---

# １－８　要約（3行以内）

* **IN／NOT IN** は「集合の一致／不一致」。
* **ANY／ALL** は「比較演算子＋集合」で条件を判定。
* 出題者はANYとALLの取り違えを狙う。

---

#### 各演算子の詳細と注意点

| 演算子 | 判定内容 | 思考パターン / 備考 |
| :--- | :--- | :--- |
| **IN** | 集合に含まれるか | `=ANY` と同義。 |
| **NOT IN** | 集合に含まれないか | **注意**: サブクエリの結果に **NULL が含まれると、比較結果が UNKNOWN となり、全ての行が対象外**になる。 |
| **=ANY** | 集合のどれか1つと等しいか | `IN` と同義。OR的な判定。 |
| **>ANY** | 集合のいずれかの値より大きいか | 「集合の中の**最小値**より大きい」ことと同じ。 |
| **<ANY** | 集合のいずれかの値より小さいか | 「集合の中の**最大値**より小さい」ことと同じ。 |
| **=ALL** | 集合の全てと等しいか | 全ての候補が同じ値でない限り成立しないため、実用性は低い。 |
| **>ALL** | 集合の全てより大きいか | 「集合の中の**最大値**より大きい」ことと同じ。 |
| **<ALL** | 集合の全てより小さいか | 「集合の中の**最小値**より小さい」ことと同じ。 |

#### よくある質問と誤解（Q&A）
*   **Q1. `IN` と等価な表現はどれか。**
    *   **A1.** `=ANY`。集合の中のいずれか一つに一致すればよいため。
*   **Q2. 「給与が部署10の全員より高い社員」を求めるにはどの演算子か。**
    *   **A2.** `>ALL`。全員との比較はAND条件に相当するため。
*   **Q3. 「給与が部署10の誰か一人より高い社員」を求めるにはどの演算子か。**
    *   **A3.** `>ANY`。一人でも超えればよいOR条件に相当するため。
*   **Q4. `NOT IN` のサブクエリに `NULL` が含まれるとどうなるか。**
    *   **A4.** 全ての比較が `UNKNOWN` となり、結果は0件になる。
*   **Q5. 「すべての候補値に等しい」を表すのはどの演算子か。**
    *   **A5.** `=ALL`。ただし、実用上ほとんど使われない。










### 2.3. EXISTS / NOT EXISTS との組み合わせ
サブクエリが1行以上の結果を返すかどうか（存在するかどうか）を判定します。多くの場合、相関サブクエリと組み合わせて使用されます。

*   **目的**: 関連するデータが存在するかどうかに基づいて行を抽出する。
*   **特徴**: サブクエリが返す実際の値は無視され、行の有無のみが評価されます。詳細は「4. 相関サブクエリ」の章で解説します。

### 2.4. WHERE句サブクエリの注意点と試験対策

#### 代表的な誤答・凡ミス
1.  **スカラサブクエリが複数行を返してエラー**
    *   **原因**: `=` などの比較演算子を使っているのに、サブクエリが複数行を返してしまうケース。
    *   **対策**: サブクエリが必ず1行1列になるよう、`MAX`, `MIN`, `AVG` などの集約関数を使うか、`IN` 演算子に切り替える。
2.  **`NOT IN` でのNULLの扱いによる意図しない結果**
    *   **原因**: `NOT IN` のサブクエリ結果に `NULL` が含まれていると、比較が `UNKNOWN` となり、意図せず結果が0件になる。
    *   **対策**: `NOT EXISTS` を使用する方が安全。
3.  **EXISTS と IN の意味の違いの混同**
    *   **原因**: `IN` は「値の集合」に含まれるかを比較するのに対し、`EXISTS` はサブクエリの「行の存在」そのものを問う。この違いを理解せず、使い分けを誤る。
4.  **相関サブクエリと非相関サブクエリの混同**
    *   **原因**: 外側の行ごとにサブクエリが実行される相関サブクエリの構造を理解せず、非効率なクエリを作成してしまう。

#### 性能上の留意点
*   **相関サブクエリ**: 外側の各行ごとにサブクエリが実行されるため、行数が増えると性能が低下しやすい。インデックスの活用が重要。
*   **非相関サブクエリ**: サブクエリは一度だけ実行され、その結果がキャッシュされることが多い。ただし、巨大な結果セットを生成する場合は注意が必要。
*   **EXISTS**: 条件を満たす最初の行が見つかった時点で評価が終了する（早期終了）ため、`IN` よりも高速になることがある。
*   **JOINへの書き換え**: サブクエリは `JOIN` を使って書き換えられる場合があり、オプティマイザがインデックスを効率的に利用できるため、性能が向上することがある。