## 🔒 デッドロック理解の核心：なぜロックは途中で解放されないのか？

### ① ロックが解放されない理由（2相ロック方式）

SQLなどのトランザクション管理では、以下のルールが採用されています：

| フェーズ         | 内容                                           |
|------------------|------------------------------------------------|
| 取得フェーズ      | 必要なロックを次々に獲得（Growing phase）       |
| 解放フェーズ      | トランザクション終了時にまとめて解放（Shrinking phase） |

- 一度獲得したロックは、**COMMITまたはROLLBACKまで保持**される。
- つまり、処理A1が終わっても、資源Sのロックはトランザクション終了まで解放されない。

---

### ② なぜ途中で解放しないのか（設計上の理由）

ロックを途中で解放すると、以下の問題が発生します：

| 問題点             | 詳細説明                                                                 |
|--------------------|--------------------------------------------------------------------------|
| 一貫性の破壊        | 他トランザクションが資源Sを書き換えると、A2の参照結果が矛盾する。         |
| 原子性の喪失        | A1とA2がセットで処理される前提が崩れ、「中途半端な更新」が見える可能性。 |

➡️ よって、「A1が成功したらA2も同じ資源状態で処理される」ことを保証するために、ロックは最後まで保持される。

---
### ③ 応用情報試験での着眼点

- デッドロックは「トランザクション終了までロックを保持する」ことが前提。
- 「途中で解放すればいいのでは？」という疑問は自然だが、**整合性・原子性を守るために不可**。
- IPA試験では、この「なぜ途中で解放しないのか」の理解が問われる。

---

### ✅ 結論

処理A1終了時点で資源Sのロックを解放しないのは、  
**トランザクションの一貫性・原子性を守るために、2相ロック方式が採用されているから**。

---
