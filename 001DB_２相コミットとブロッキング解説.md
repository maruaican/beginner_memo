```markdown
# ２相`コミット`プロトコル 障害時動作に関する問題集

## 問題１
prepare応答後、commit指示未着の状態でコーディネータがクラッシュした場合、サブシステムはどう対応すべきか。

**正答：`ロールバック`する(またはコーディネータ復旧まで待機する)**

**解説：**
この状態は「準備完了を通知したが、最終的な確定指示を受け取っていない」という未確定状態です。この時点でサブシステムが単独で`コミット`を実行すると、以下のリスクが生じます。
- 他のサブシステムが準備段階で失敗していた場合、本来は全体が`ロールバック`されるべきであるにも関わらず、当該サブシステムのみが`コミット`され、`原子性`が破壊される
- コーディネータが復旧後に`ロールバック`指示を送信する可能性があるが、すでに`コミット`済みであれば指示に従えず、不整合が確定する
したがって、`安全側への倒し込み原則に従い、`ロールバック`を選択`します。ただし、実装によってはタイムアウトまで待機し、コーディネータ復旧を待つ方式も採用されます。

**誤答パターンとその理由：**
- 「自律的に`コミット`する」→prepare完了は処理可能性の表明であり、`確定指示ではない。単独での`コミット`は`原子性`を破壊`する
- 「何もせず無期限に待機する」→タイムアウト機構がない場合、リソースが永続的にロックされる(ブロッキング問題)
---
## 問題２
commit指示を受け取り、ログに記録済みの状態で、コーディネータがダウンした場合の対応はどれか。

**正答：ログに基づき`コミット`処理を完了させる**
**解説：**
``コミット`指示のログ記録は、トランザクションの確定`を意味します。この時点で、コーディネータは全サブシステムから肯定応答を得て、トランザクション全体を`コミット`すると決定しています。

ログに基づく復旧動作は以下の理由で必須です。
**(１)確定済みトランザクションの保護**
``コミット`指示がログに記録された時点で、論理的にはトランザクションは確定`済みです。この後に障害が発生しても、確定した事実は変更されません。
**(２)分散システム全体の整合性**
他のサブシステムも`コミット`指示を受け取っている可能性が高く、自サブシステムのみが`ロールバック`すると、データベース間で不整合が生じます。
**(３)永続性(Durability)の保証**
ACIDトランザクションの永続性要件により、`一度確定したトランザクションは、障害後も保証される`必要があります。

**処理手順：**
①システム再起動時、ログファイルを読み込む
②commit指示のログレコードを発見する
③`コミット`処理が未完了であれば、ログに基づき再実行する
④`コミット`完了をログに記録する

---
## 問題３
rollback指示を受けたサブシステムが、コーディネータ復旧前に再起動した場合、どう振る舞うか。
**正答：ログに従って`ロールバック`処理を再実行する**
**解説：**
``ロールバック`指示も`コミット`指示と同様、ログに記録された確定`事項です。サブシステムは以下の手順で動作します。
**(１)再起動時のログ解析**
- トランザクションログを走査し、未完了の`ロールバック`指示を検出
- ログに記録された操作内容を逆順に適用(undo処理)
**(２)`ロールバック`処理の再実行**
- 変更されたデータを元の状態に復元
- ロック資源を解放
- `ロールバック`完了をログに記録
**(３)独立性の保証**
`コーディネータとの通信が復旧していない状態でも、ログのみを根拠に処理を完了`できます。これにより、障害からの自律的な復旧が可能になります。
**ログベース復旧の利点：**
- ネットワーク障害やコーディネータ障害と無関係に復旧可能
- トランザクションの確定状態がログに保存されているため、判断に迷わない
- 復旧処理が冪等性(何度実行しても結果が同じ)を持つ

---
## 問題４
prepare完了済みだがcommit指示が未着の状態で、他のサブシステムがすでに`コミット`済みである場合、当該サブシステムはどう対応すべきか。

**正答：自律的には`ロールバック`する(または待機する)**
**解説：**
この状況は、２相`コミット`プロトコルの障害事例の中で最も判断が難しい状態です。以下の観点から分析します。

**(１)状況の整理**
- 自サブシステム：prepare完了、commit指示未受信(未確定状態)
- 他サブシステム：commit指示受信済み、処理完了(確定状態)
- コーディネータ：障害または通信断絶により、指示が届いていない

**(２)`原子性`の既存破壊**
この時点で、分散トランザクション全体の`原子性`はすでに部分的に失われています。理想的には「全て`コミット`」または「全て`ロールバック`」であるべきですが、`現実には一部が`コミット`済み、一部が未確定という不整合状態`です。

**(３)自律的判断の方針**
この状況で自サブシステムが取りうる選択肢は以下の３つです。
①自律的に`コミット`する
- リスク：コーディネータが最終的に`ロールバック`を決定していた場合、不整合をさらに拡大させる。他サブシステムが後から`ロールバック`される可能性もあり、`判断根拠が不十分`。

②自律的に`ロールバック`する
- 利点：少なくとも自サブシステムは安全側に倒れる。不整合の拡大を防ぎ、後続の復旧処理の選択肢を残す。
- 欠点：他サブシステムが`コミット`済みであれば、`結果として不整合は残る`。

③コーディネータの復旧を待つ
- 利点：正確な指示を受け取ることで、正しい判断が可能になる。
- 欠点：`無期限の待機によるリソースロック(ブロッキング問題)`。

**(４)推奨される対応**
`実際の試験問題では「`ロールバック`する」または「待機する」が正答`とされることが多く、その根拠は以下です。
- 確定情報がない状態で、推測に基づいて`コミット`することは、被害の拡大につながる
- ``ロールバック`は安全側への倒し込み`であり、少なくとも自サブシステムは確実に正しい状態を保つ
- 待機により、コーディネータ復旧後の正確な指示に従える可能性を残す

**(５)実システムでの対応**
実運用では、以下のような追加機構が導入されます。
- タイムアウト機構：一定時間経過後、`ロールバック`を自動実行
- コーディネータのログ複製：複数のコーディネータでログを共有し、単一障害点を排除

---
## 問題５
２相`コミット`でコーディネータのログが破損した場合、どう扱うべきか。

**正答：トランザクション全体を`ロールバック`する**
**解説：**
コーディネータのログ破損は、トランザクションの確定状態が不明になることを意味します。以下の観点から、`ロールバック`が妥当です。

**(１)判断根拠の喪失**
ログには以下の重要情報が記録されています。

- 各サブシステムのprepare応答結果
- commit/rollback指示の送信記録
- トランザクションの確定状態

ログが破損すると、コーディネータはトランザクションの最終状態を判断できません。

**(２)不整合リスクの評価**
この状況で取りうる選択肢は以下です。
①全サブシステムに`コミット`を指示
- リスク：一部のサブシステムが実際にはprepare段階で失敗していた場合、`原子性`が破壊される。

②全サブシステムに`ロールバック`を指示
- 利点：確実に整合性のある状態(全て`ロールバック`)に戻せる。
- 欠点:すでに`コミット`済みのトランザクションも`ロールバック`される可能性があるが、不整合よりは安全。

③各サブシステムに状態を問い合わせる
- 課題：ネットワーク障害や部分的なシステム障害がある場合、正確な情報が得られない可能性がある。

**(３)安全側への倒し込み**
不確実な情報に基づいて`コミット`すると、データの不整合が確定し、後から修正することが困難になります。一方、`ロールバック`であれば、最悪でもトランザクションのやり直しで済みます。

したがって、`ログ破損時は「疑わしきはロールバック」の原則`に従い、全体を`ロールバック`するのが標準的な対応です。

**(４)予防策**
実システムでは、以下の対策でログ破損のリスクを軽減します。
- ログの二重化：複数のディスクにログを書き込む
- チェックサム：ログレコードごとに誤り検出符号を付加
- 定期的なログバックアップ：破損時に過去のログから復旧
```



**【問1】**
分散データベースシステムにおいて、複数の拠点にまたがるトランザクションの`一貫性`を保つために2相`コミット`プロトコルが用いられます。このプロトコルが、データベースのトランザクション特性であるACIDのうち、特にどの性質を保証するために不可欠なのか、2つ挙げてください。

---
**【解答】**
`原子性`（Atomicity）と`一貫性`（Consistency）です。

---
**【解説】】**
2相`コミット`プロトコル（Two-Phase Commit Protocol, 2PC）は、分散環境におけるトランザクション管理の中核をなす技術です。その最大の目的は、ACID特性を保証することにあります。

*   **`原子性` (Atomicity):** 「すべて実行されるか、まったく実行されないか」という"all-or-nothing"の原則です。2相`コミット`は、参加するすべてのノードが`コミット`に合意した場合にのみ処理を確定し、一つでも合意できないノードがあれば全ノードの処理を取り消す（`ロールバック`する）ことで、トランザクションが中途半端な状態で終わることを防ぎ、`原子性`を保証します。
*   **`一貫性` (Consistency):** トランザクションの前後で、データベースが予め定められた整合性ルール（制約）を満たしている状態を維持する性質です。2相`コミット`が`原子性`を保証することにより、一部のノードだけが更新されるといったデータの不整合を防ぎ、結果としてシステム全体の`一貫性`が保たれます。

ACIDは、Atomicity, Consistency, **Isolation（独立性）**, **Durability（永続性）** の頭文字を取ったものです。2相`コミット`は特に`原子性`と`一貫性`の担保に直接的に貢献します。

---
**【初心者が勘違いしやすい点】**
「2相`コミット`がACIDのすべてを保証する」と誤解しがちですが、それは不正確です。独立性（Isolation）はロック機構など他の同時実行制御技術によって、永続性（Durability）は各ノードのログ機能などによって保証されます。2相`コミット`は、これら個々のノードが持つ機能を協調させ、分散環境で「`原子性`」を担保するための「司令塔」の役割を果たすプロトコルである、と理解することが重要です。

---
**【問2】**
2相`コミット`プロトコルは、「調停者」と「参加者」という2種類の役割によって構成されます。それぞれの役割を簡潔に説明してください。

---
**【解答】**
*   **調停者 (Coordinator):** トランザクション全体の最終的な意思決定（`コミット`か`ロールバック`か）を行い、その決定を全参加者に指示する中心的な役割。
*   **参加者 (Participant):** 実際にデータベースの更新処理を行い、調停者からの問い合わせに応答し、最終的な指示に従う役割。

---
**【解説】】**
2相`コミット`プロトコルにおける役割分担は、オーケストラの指揮者と演奏者の関係に似ています。

*   **調停者 (Coordinator):** 指揮者に相当します。トランザクションの開始から終了までを統括し、各参加者（演奏者）に「演奏準備は良いか？（COMMIT可否問合せ）」と確認し、全員の準備が整ったら「演奏開始！（COMMIT実行要求）」と号令をかけます。一人でも準備ができていなければ「中止！（ROLLBACK実行要求）」を指示します。
*   **参加者 (Participant):** 演奏者に相当します。それぞれが自身のデータベース（楽器）を担当し、調停者（指揮者）の指示に従って更新処理（演奏）の準備をし、最終的な指示に基づいて処理を確定または破棄します。

この明確な役割分担により、複雑な分散トランザクションを組織的かつ確実に実行することが可能になります。

---
**【初心者が勘違いしやすい点】**
調停者がデータベースの更新処理を直接実行すると誤解するケースがあります。調停者の役割はあくまで「調整」と「決定」であり、実際のデータ操作は各参加者が自身の責務として行います。調停者は各参加者の処理内容の詳細を知る必要はなく、「そのトランザクションを`コミット`できるか否か」という結果だけを取りまとめます。

---
**【問3】**
2相`コミット`プロトコルにおける第1相（投票フェーズ）の目的と、このフェーズで調停者と参加者が行う主要なやり取りを説明してください。

---
**【解答】**
**目的:** トランザクションを`コミット`できるか否かを、全参加者の意思を確認して判断するための準備段階。
**やり取り:** 調停者が全参加者に「COMMIT可否問合せ」を送信し、各参加者は`コミット`可能なら「可」、不可能なら「否」を返答する。

---
**【解説】】**
第1相は、投票フェーズ（Voting Phase）または準備フェーズ（Prepare Phase）とも呼ばれます。このフェーズは、いわば「最終決定前の根回し」です。

1.  **調停者のアクション:** トランザクションを`コミット`する要求を受け取ると、まず全参加者に対して「このトランザクション、`コミット`して大丈夫ですか？」という趣旨の「**COMMIT可否問合せ (Prepare Request)**」をブロードキャストします。
2.  **参加者のアクション:** 問い合わせを受けた各参加者は、自身の担当する処理をすべて完了させ、`コミット`可能な状態にできるか自己判断します。
    *   **可能 (Yes/Agree):** 更新内容を永続的なログに書き出し、いつでも`コミット`できる状態（セキュア状態）になった上で、調停者に「可」と返答します。
    *   **不可能 (No/Abort):** 制約違反やリソース不足などで`コミット`できない場合、トランザクションを`ロールバック`し、調停者に「否」と返答します。

このフェーズが完了した時点で、調停者はトランザクション全体を`コミット`すべきか、`ロールバック`すべきかの判断材料をすべて手に入れます。

---
**【初心者が勘違いしやすい点】**
第1相で参加者が「可」と返答した時点で、その参加者のデータベースで`コミット`が完了した、と誤解されがちです。これは大きな間違いです。「可」の返答は、あくまで「`コミット`の準備ができました。あとは指示待ちです」という意思表示に過ぎません。
実際の`コミット`は、第2相で調停者から「COMMIT実行要求」を受け取ってから初めて行われます。

---
**【問4】**
2相`コミット`プロトコルにおいて、調停者がトランザクションの「ROLLBACK」を決定するのは、どのような状況ですか？ 具体的なケースを2つ挙げてください。

---
**【解答】**
1.  第1相（投票フェーズ）において、一人でも「否」を返答した参加者がいた場合。
2.  第1相（投票フェーズ）において、所定の時間内に応答しない（タイムアウトした）参加者がいた場合。

---
**【解説】】**
2相`コミット`の意思決定は、極めて厳格な「**全員一致の原則**」に基づいています。調停者がCOMMITを決定できるのは、**全ての参加者から「可」の応答を受け取った唯一のケースのみ**です。

それ以外の全てのケース、すなわち、
*   **明示的な拒否:** 参加者の誰か一人が「否 (No/Abort)」を返答した。
*   **応答不能:** 参加者の誰か一人がネットワーク障害やノードのダウンにより、タイムアウト時間内に応答できなかった。

これらの状況では、トランザクションの`原子性`を保証できないため、調停者は即座にROLLBACKを決定し、全参加者（「可」と応答した参加者も含む）に対して「**ROLLBACK実行要求**」を送信します。これにより、システム全体がトランザクション開始前の状態に安全に戻されます。

---
**【初心者が勘違いしやすい点】**
「過半数が『可』と答えれば`コミット`されるのでは？」という多数決の考え方を適用してしまうのが典型的な誤りです。データベースの整合性は1か0かの世界であり、妥協は許されません。たった一つのノードでも処理を完了できなければ、システム全体の整合性が崩れるリスクがあるため、全員一致が絶対条件となります。

---
**【問5】**
参加者が第1相で「可」と返答した後、調停者からの第2相の指示を待っている状態を何と呼びますか？ また、この状態にある参加者は、なぜ自身の判断で`コミット`や`ロールバック`を行ってはいけないのですか？

---
**【解答】**
**状態名:** セキュア状態（Prepared State）
**理由:** 他の参加者の状況を知らないため。自分は`コミット`準備ができていても、他の参加者が「否」と応答している可能性があり、その場合はトランザクション全体を`ロールバック`する必要がある。全体の決定は調停者に一任されているため、勝手な判断は許されない。

---
**【解説】】**
セキュア状態（Prepared State）は、2相`コミット`において非常に重要な中間状態です。これは「**更新処理は完了したが、まだ確定（`コミット`）も破棄（`ロールバック`）もしていない、いわば『仮押さえ』の状態**」を指します。

この状態に入った参加者は、以下の責務を負います。
*   **リソースのロック:** トランザクションで更新対象となったデータやリソースをロックし、他のトランザクションからの変更を防ぎます。
*   **ログへの記録:** 障害発生時に復旧できるよう、更新内容と「準備完了」のステータスを永続的なログ（先行書き込みログ、WAL: Write-Ahead Logging）に記録します。
*   **調停者からの指示待機:** 調停者からの「COMMIT」または「ROLLBACK」の最終指示をひたすら待ち続けます。

この状態で自己判断を許してしまうと、ある参加者は`コミット`し、別の参加者は`ロールバック`するという最悪の不整合状態に陥るため、厳しく禁じられています。

---
**【初心者が勘違いしやすい点】**
「セキュア状態」という言葉の響きから、「安全で安定した状態」とポジティブに捉えがちです。しかし、この状態はシステムにとって非常に不安定な側面も持ち合わせています。なぜなら、リソースをロックしたまま外部からの指示を待つため、後述する「ブロッキング問題」の直接的な原因となるからです。「`コミット`も`ロールバック`もできず、身動きが取れない状態」というニュアンスで理解することが重要です。

---
**【問6】**（調停者障害）
2相`コミット`プロトコルが抱える最も重大な欠点として知られる「ブロッキング問題」とは、どのような問題ですか？ 調停者に障害が発生した場合のシナリオを基に説明してください。

---
**【解答】**
ブロッキング問題とは、一部のノード（調停者や参加者）に障害が発生した結果、障害とは無関係の正常なノードまで処理を続行できなくなり、システム全体が停止（ブロック）してしまう問題です。
特に、第1相で「可」と返答した参加者が、第2相の指示を受け取る前に調停者に障害が発生すると、参加者は`コミット`すべきか`ロールバック`すべきか判断できず、調停者が復旧するまでリソースをロックしたまま永久に待機し続けることになります。

---
**【解説】】**
ブロッキング問題（Blocking Problem）は、2相`コミット`のアキレス腱とも言える深刻な課題です。

**シナリオ：調停者障害**
1.  **第1相:** 全参加者が「可」と返答し、セキュア状態に入る。各参加者はリソースをロックし、調停者からの最終指示を待っている。
2.  **障害発生:** 調停者が第2相の「COMMIT」指示を送信する**直前に**クラッシュする。
3.  **ブロック状態:** 参加者は、指示が来ないため、`コミット`も`ロールバック`もできず、リソースをロックしたまま待ち続けるしかありません。このロックされたリソースにアクセスしようとする他の全てのトランザクションも連鎖的に停止してしまいます。
4.  **影響:** 調停者が手動で復旧されるまで、システムの一部または全体が完全に停止します。この、最終決定を知ることができず身動きが取れない状態を「**不確定状態 (Uncertain State)**」と呼びます。

このように、単一障害点（SPOF: Single Point of Failure）である調停者がダウンすると、システム全体に影響が波及するのがブロッキング問題の恐ろしさです。

---
**【初心者が勘違いしやすい点】**
「調停者が故障したら、参加者同士で連絡を取り合って多数決で決めれば良いのでは？」と考えるかもしれません。しかし、それは不可能です。ある参加者が調停者からの指示を受け取った直後に調停者がダウンした可能性を、他の参加者は知ることができません。不確実な状況で勝手な判断を下すと、データ不整合を引き起こすため、プロトコルとして「ひたすら待つ」しか選択肢がないのです。

---
**【問7】**（参加者障害）
調停者ではなく、参加者の一台に障害が発生した場合でもブロッキング問題は起こり得ます。第2相でCOMMITが決定された後、ある参加者がCOMMIT実行要求を受け取る前に障害でダウンした場合、どのような問題が発生しますか？

---
**【解答】**
`調停者と他の正常な参加者はトランザクションを`コミット``しますが、`障害が発生した参加者はセキュア状態のまま停止`します。この参加者が復旧するまで、そのノードが保持するリソースはロックされ続け、そのリソースを利用する他のトランザクションがブロックされるという問題が発生します。

---
**【解説】】**
参加者障害のケースも、タイミングによっては厄介な問題を引き起こします。

*   **第1相で参加者がダウンした場合:**
    調停者は応答がないことをタイムアウトで検知し、安全にトランザクション全体を`ロールバック`させることができます。この場合はブロッキング問題は発生しにくいです。
*   **第2相で参加者がダウンした場合（問題のケース）:**
    1.  調停者は全参加者から「可」を受け取り、COMMITを決定。
    2.  調停者は全参加者に「COMMIT実行要求」を送信。
    3.  ほとんどの参加者は要求を受け取り`コミット`を完了。しかし、一台の参加者だけが、要求を受け取る直前にネットワーク障害やクラッシュでダウン。
    4.  この障害ノード(参加者)は、`コミット`も`ロールバック`もできない「セキュア状態」のまま停止します。
    5.  システム全体としては`コミット`されているのに、このノードだけが中途半端な状態で取り残されます。復旧後、ログを見てトランザクションを完了（ロールフォワード）させる必要がありますが、それまでの間、関連リソースはロックされ続けます。

このように、障害からの復旧処理が完了するまでの間、局所的なブロッキングが発生します。

---
**【初心者が勘違いしやすい点】**
「参加者の障害なら、そのノードだけの問題で全体には影響ない」と考えがちです。しかし、分散システムは相互に連携して動作しているため、一つのノードがロックしたリソースが、他の多くの処理のボトルネックになることがあります。特に重要なマスタデータを保持するノードでこの問題が起こると、影響は甚大になります。

---
**【問8】**
2相`コミット`プロトコルでは、障害からの復旧を確実に行うために、調停者と参加者が`自身の状態`を永続的な記憶領域に記録します。この記録のことを一般的に何と呼びますか？ また、なぜこの記録が不可欠なのですか？

---
**【解答】**
**記録の名称:** トランザクションログ（またはジャーナル）
**不可欠な理由:** ノードが障害で再起動した際に、ログを参照することで、障害発生直前の`自身の状態`（例：トランザクションがセキュア状態だったか、`コミット`済みだったか）を正確に把握し、トランザクションを中途半端な状態にせず、`コミット`または`ロールバック`を正しく完了させるため。

---
**【解説】】**
トランザクションログは、2相`コミット`における「記憶の命綱」です。各ノードは、`自身の状態が変化する重要なタイミングで、その証拠をログに書き出します`。

*   **参加者のログ記録タイミング:**
    *   トランザクションの更新内容
    *   第1相で「可」を返答する直前（"prepare"レコード）
    *   第2相でCOMMIT/ROLLBACK指示を受け、処理を完了した直後（"commit" / "abort"レコード）
*   **調停者のログ記録タイミング:**
    *   第2相でCOMMIT/ROLLBACKを決定した直後

特に、**何かを`実行する前`に、まずその実行内容をログに書き出す**という原則（**WAL: Write-Ahead Logging / 先行書き込みログ**）が重要です。これにより、万が一ログを書き出した直後にクラッシュしても、再起動時に「自分は何をしようとしていたか」を思い出し、処理を再開できます。もしログがなければ、障害からの自動復旧は不可能になります。

---
**【初心者が勘違いしやすい点】**
「ログは単なる処理履歴」と軽く考えがちですが、分散システムにおけるログは、単なる履歴ではなく「未来の行動を決定する契約書」のようなものです。特にセキュア状態（"prepare"レコード）をログに書き出した参加者は、「調停者からの指示に従う」という契約を交わしたことになり、再起動後もその契約を履行する義務を負います。

---
**【問9】**
2相`コミット`はブロッキング問題という大きな課題を抱えています。この問題を解決するために考案されたプロトコルとして「3相`コミット`」がありますが、広く普及するには至っていません。その主な理由を、プロトコルの特性に触れながら説明してください。

---
**【解答】**
3相`コミット`は、投票フェーズと決定フェーズの間に「事前`コミット`フェーズ」を設けることで、調停者がダウンしても参加者がタイムアウトによって自律的に判断を下せるようにし、ブロッキングを回避します。しかし、プロトコルが複雑化し、通信回数が増えるためパフォーマンスが低下するというデメリットがあり、広くは普及していません。

---
**【解説】】**
3相`コミット`（Three-Phase Commit, 3PC）は、2相`コミット`のブロッキング問題を理論的に解決するプロトコルです。

*   **第1相 (投票):** 2PCと同じ。
*   **第2相 (事前`コミット` / PreCommit):** 調停者はCOMMITを決定すると、まず「**PreCommit要求**」を送信します。参加者はこれを受け取ると「`コミット`する準備ができました」と応答します。この段階があることで、「全員が`コミット`に合意した」という事実を全ノードが共有できます。
*   **第3相 (決定 / DoCommit):** 調停者は「**DoCommit要求**」を送信し、実際の`コミット`が行われます。

この設計により、もしPreCommitフェーズ以降に調停者がダウンしても、生き残った参加者は「どうせ`コミット`されるはずだ」と判断してタイムアウト後に自律的に`コミット`を進めることができます。

しかし、この巧妙な仕組みには代償が伴います。
*   **複雑性:** プロトコルの状態管理が複雑になり、実装が困難。
*   **パフォーマンス:** 通信の往復が1回増えるため、トランザクションの完了までの遅延（レイテンシ）が大きくなります。

これらのデメリットから、実システムでは3PCの採用は稀で、ブロッキングのリスクを許容した上で2PCを使うか、後述するSagaパターンのような全く別のアプローチを選択することが一般的です。

---
**【初心者が勘違いしやすい点】**
「3相`コミット`は2相`コミット`の上位互換で、常に優れた選択肢である」という誤解です。技術選定は常にトレードオフであり、3相`コミット`はブロッキング耐性と引き換えに、性能と実装の複雑性というコストを支払います。多くのシステムでは、そのコストが見合わないと判断されています。

---
**【問10】**
マイクロサービスアーキテクチャのような、より疎結合(コンポーネント同士の依存関係が弱く、互いに独立している。障害や変更が局所的に留まり、全体への影響を最小限にできるので保守性が高いというメリット)な分散システムにおいて、2相`コミット`の代替として注目されている設計パターンに「Sagaパターン」があります。2相`コミット`とSagaパターンの、トランザクション失敗時のアプローチの根本的な違いを、「`ロールバック`」と「補償トランザクション」という言葉を用いて説明してください。

---
**【解答】**
2相`コミット`は、トランザクションの途中で失敗が発生した場合、それまでに行った処理をすべて取り消す「`ロールバック`」によって`原子性`を保証します。
一方、Sagaパターンは、各処理を独立したローカルトランザクションとして次々に`コミット`していき、途中で失敗した場合は、それまでに完了した処理を打ち消すための「補償トランザクション」を逆順に実行することで、全体として`一貫性`を回復します。

---
**【解説】】**
2相`コミット`とSagaパターンは、分散トランザクションを実現するという目的は同じですが、その哲学が全く異なります。

*   **2相`コミット`（悲観的アプローチ）:**
    *   「失敗するかもしれない」と悲観的に考え、全員の合意が取れるまでリソースをロックし、`コミット`を保留します。
    *   失敗時は、あたかも「何もなかったかのように」元の状態に完全に戻します（**`ロールバック`**）。
    *   例えるなら、全員が契約書に署名するまで、インクを乾かさずに待っている状態です。誰か一人が署名を拒否すれば、全員の署名を消して契約を破棄します。

*   **Sagaパターン（楽観的アプローチ）:**
    *   「基本的には成功するだろう」と楽観的に考え、各サービスの処理（ローカルトランザクション）を次々に確定（`コミット`）させていきます。リソースの長期ロックは発生しません。
    *   もし途中で失敗したら、「起きてしまったことを打ち消す」ための後始末処理（**補償トランザクション**）を実行します。
    *   例えるなら、「航空券を予約（`コミット`）」「ホテルを予約（`コミット`）」「レンタカーを予約（失敗！）」となった場合、「ホテルのキャンセル処理（補償）」「航空券のキャンセル処理（補償）」を順に実行するようなものです。

Sagaパターンは、マイクロサービスのように各サービスが独立したデータベースを持つ疎結合なシステムに適しており、ブロッキング問題も発生しません。ただし、補償処理を正確に設計・実装する必要があるという複雑さが伴います。

---
**【初心者が勘違いしやすい点】**
SagaパターンはACID特性のうち、特に独立性（Isolation）を完全には保証しません。あるトランザクションが完了し、次のトランザクションが補償処理を実行するまでの間、他のトランザクションは一時的に不整合な状態（例：航空券は予約済みだがホテルはまだ、の状態）を観測できてしまいます。この点を許容できるかどうかで、Sagaパターンが適用可能かどうかが決まります。

---
**【問11】**
調停者が第1相で「COMMIT可否問合せ」を送信し、ある参加者から「否」の応答、他の参加者からは「可」の応答を受け取りました。この後、調停者が最初に行うべきアクションは何ですか？

---
**【解答】**
自身のログに「ROLLBACK」の決定を記録し、その後、応答をくれた全ての参加者（「可」と答えた参加者も含む）に対して「ROLLBACK実行要求」を送信することです。

---
**【解説】】**
2相`コミット`の原則は「一人でも否なら全員`ロールバック`（`原子性`）」です。調停者は、参加者の誰か一人からでも「否」の応答を受け取った瞬間に、トランザクション全体の`ロールバック`を決定します。

その後のアクションの順序が重要です。
1.  **自身のログに決定を記録:** まず、`送信前に`、調停者自身が「このトランザクションは`ロールバック`する」という決定を永続的なログに書き込みます。これにより、万が一この直後に調停者がクラッシュしても、再起動時に正しい決定を再現できます。
2.  **全参加者に指示を送信:** 次に、「可」と応答してセキュア状態で待機している参加者と、「否」と応答した参加者の両方を含む、全ての関係者に「ROLLBACK実行要求」を送信します。これにより、全ノードがトランザクション開始前の状態に戻り、`一貫性`が保たれます。

---
**【問12】**
2相`コミット`プロトコルにおいて、調停者が参加者に対して送信するメッセージ（要求）の種類を3つ挙げてください。

---
**【解答】**
1.  COMMIT可否問合せ (Prepare Request)
2.  COMMIT実行要求 (Commit Request)
3.  ROLLBACK実行要求 (Rollback/Abort Request)

---
**【解説】】**
調停者の役割は、この3種類のメッセージを適切なタイミングで参加者に送ることに集約されます。

1.  **COMMIT可否問合せ (Prepare Request):** 第1相（投票フェーズ）の開始を告げるメッセージ。「このトランザクションを確定する準備はいいか？」という問い合わせです。
2.  **COMMIT実行要求 (Commit Request):** 第2相（決定フェーズ）で、全参加者から「可」の応答を得た場合に送信されるメッセージ。「全員の準備が整ったので、トランザクションを確定してください」という最終指示です。
3.  **ROLLBACK実行要求 (Rollback/Abort Request):** 第2相（決定フェーズ）で、一人でも「否」またはタイムアウトが発生した場合に送信されるメッセージ。「問題が発生したので、トランザクションを取り消してください」という最終指示です。
---
**【初心者が勘違いしやすい点】**
ログの書き込みは、各ノード(調停者や参加者)が`自身の状態`を永続化するために行う**内部的な実装**です。調停者が指示するのは、あくまでプロトコル上の抽象的なアクション（Prepare, Commit, Rollback）であり、その実現方法（ログ書き込みのタイミングなど）は各参加者の実装に委ねられています。

---
**【問13】**
ある分散システムで、調停者がCOMMITを決定し、全参加者にCOMMIT実行要求を送信しました。しかし、ある参加者Aだけがネットワークの遅延により要求の到着が大幅に遅れています。この間、参加者Aが保持しているリソースはどうなっていますか？ また、それがシステム全体に与える影響を説明してください。

---
**【解答】**
参加者Aは`セキュア状態`にあり、トランザクションで利用したリソースを`ロック`し続けています。
これにより、そのロックされたリソースにアクセスしようとする他のトランザクションは、参加者AがCOMMIT要求を受け取ってロックを解放するまで待たされ、処理が遅延する（`ブロックされる`）という影響が出ます。

---
**【解説】】**
これは、障害だけでなく、ネットワークの遅延のような一時的な性能問題でもブロッキングが発生しうることを示す良い例です。

参加者Aの視点では、第1相で「可」と返答して以降、調停者からの連絡が途絶えている状態です。そのため、プロトコルのルールに従い、セキュア状態を維持し、リソースをロックしたまま指示を待ち続けます。

一方、他の正常な参加者はすでに``コミット`を完了し、ロックを解放`しています。システム全体としてはトランザクションは成功しているにもかかわらず、参加者Aだけが取り残され、そのノードがボトルネックとなって関連する他の処理の足を引っ張ってしまうのです。2相`コミット`は、参加者の中で`最も応答の遅いノード（最も性能の低いノード）の速度`に、システム全体の性能が引きずられる傾向があります。

---
**【初心者が勘違いしやすい点】**
「`コミット`は決定したのだから、もう問題はないはず」と考えてしまいがちです。しかし、分散システムでは「決定すること」と同じくらい「決定を全員に確実に伝えること」が重要です。通信の信頼性が保証されないネットワーク上では、この「伝える」という部分がボトルネックや障害点になり得ます。

---
**【問14】**
2相`コミット`プロトコルは、なぜ「2相」と呼ばれるのですか？ その2つの「相（フェーズ）」の名称と、それぞれのフェーズが果たす役割の境界線を明確に説明してください。

---
**【解答】**
プロトコルが明確に分離された2つの段階（フェーズ）で構成されているため「2相」と呼ばれます。
1.  **第1相 (投票フェーズ):** 全参加者から`コミット`の可否を集め、トランザクション全体を`コミット`するか`ロールバック`するかの**「意思決定を行う」**までのフェーズ。
2.  **第2相 (決定フェーズ):** 第1相で下した決定を、全参加者に伝達し**「実行させる」**フェーズ。

---
**【解説】】**
この2つのフェーズの境界は、**調停者が最終決定を下す瞬間**にあります。

*   **第1相（投票フェーズ / Prepare Phase）:**
    *   **役割:** 意思決定のための情報収集。
    *   **ゴール:** 調停者が「COMMIT」か「ROLLBACK」かの判断を下すこと。このフェーズが終わった瞬間、トランザクションの運命は決定されます。

*   **第2相（決定フェーズ / Commit Phase）:**
    *   **役割:** 決定事項の執行。
    *   **ゴール:** 調停者が下した決定を全参加者に通知し、データベースの状態を全員で同期させること。このフェーズが完了して初めて、トランザクションの結果が永続化されます。

このように、「決定」と「執行」という2つの明確なステップに分かれていることが、このプロトコルの名前の由来であり、動作の根幹をなしています。

---
**【初心者が勘違いしやすい点】**
2つのフェーズが時間的に連続しているため、一体のものとして捉えがちです。しかし、この2つの間には「後戻りできない一線」が存在します。調停者は、第1相の結果を見てCOMMITを決定したら、その後何があってもその決定を覆してROLLBACKに変更することはできません。この不可逆性が、プロトコルの信頼性を担保しています。

---
**【問16】**
ある参加者が第1相で`コミット`不可能と判断し、「否」の応答を調停者に返しました。この参加者は、なぜセキュア状態に入らないのですか？ その理由を説明してください。

---
**【解答】**
セキュア状態とは、`コミット`の準備が完了し、`調停者からの最終指示を待つ状態`だからです。``コミット`不可能と判断した参加者は、トランザクションを自身で`ロールバック`します`。一人でも「否」であれば、調停者は`ロールバック`を決定することが分かっているので、`コミット`の準備は必要なく、「最終指示を待つ」必要がありません。
そのため、セキュア状態には入らず、トランザクションを即座に終了させます。

---
**【解説】】**
セキュア状態（Prepared State）に入るための条件は、**「自身の担当範囲において、トランザクションの`コミット`を保証できること」**です。

*   **「可」と応答する場合:**
    参加者は「私はいつでも`コミット`できます。`他の皆さんの準備が整うのを待ちます」という状態です。この「待機」状態がセキュア状態`であり、リソースのロックが伴います。
*   **「否」と応答する場合:**
    参加者は`「私は`コミット`できません。この話はここでおしまいです」と判断した状態です。他の参加者の状況を待つ必要はなく、自身の判断でトランザクションを即座に`ロールバック`し、ロックを解放`できます。

つまり、`セキュア状態に入るのは、第1相で「可」と応答した参加者だけ`です。「否」と応答したり、タイムアウトで応答できなかったノードは、この状態にはなりません。

---
**【初心者が勘違いしやすい点】**
「第1相が終わったら、すべての参加者が何らかの中間状態に入る」と考えてしまいがちです。しかし、実際には`コミット`の意思があるノードとないノードでは、その後の状態が全く異なります。`「否」と答えたノードは、いち早くトランザクションから離脱し、リソースを解放する`、という点を押さえておきましょう。

---
**【問17】**
2相`コミット`のスケーラビリティには限界があるとされています。参加するノードの数が増えると、システム全体にどのような影響が生じるか、2つの観点から説明してください。

---
**【解答】**
1.  **性能の低下:** 参加ノード数に比例して通信の往復回数が増加し、全員からの応答を待つ必要があるため、トランザクション全体の完了時間（レイテンシ）が増大する。
2.  **可用性の低下:** `参加ノードが増えるほど、いずれか一つのノードで障害が発生する確率が高まる`。2相`コミット`は一つの障害で全体が`ロールバック`またはブロックするため、結果的にシステム全体の可用性が低下する。

---
**【解説】】**
2相`コミット`は、`その厳格な合意形成プロセスゆえに、大規模なシステムには向かない`という特性を持っています。

*   **性能面（パフォーマンス）:**
    トランザクションの完了時間は、`最も遅い参加者の応答時間に依存`します。ノードが100台あれば、100台すべての応答を待たなければなりません。これにより、参加者数が増えるほど、全体のボトルネックが悪化し、スループットが低下します。調停者の負荷も増大します。

*   **可用性面（アベイラビリティ）:**
    参加者が増えれば増えるほど、「低機能なノード」が含まれる可能性が高くなります。たった一つのノードの障害がトランザクション全体の失敗につながるため、システム全体の成功率は参加者数が増えるにつれて指数関数的に低下していきます。

これらの理由から、2相`コミット`は比較的小規模で、密結合な信頼性の高いネットワーク内で構成されるシステムに適していると言えます。

---
**【問18】**
調停者に障害が発生し、セキュア状態の参加者が「不確定状態」に陥りました。管理者が手動で復旧作業を行う際、このトランザクションを`コミット`すべきか、`ロールバック`すべきかを判断するために、まず何を調査する必要がありますか？

---
**【解答】**
調停者のトランザクションログを調査する必要があります。
`ログに「COMMIT」の決定が記録されていれば、参加者にCOMMITを強制的に実行`させます。
`ログに「ROLLBACK」の決定が記録されているか、または何の決定も記録されていない場合は、参加者にROLLBACKを実行`させます。

---
**【解説】】**
不確定状態（Uncertain State）からの復旧は、管理者の慎重な判断が求められる最も困難な作業の一つです。判断の唯一の拠り所は、**調停者がクラッシュする`前に何を決定していたか`**という事実です。

1.  **調停者のログを確認:** 復旧作業の第一歩は、ダウンした調停者の永続化されたトランザクションログを解析することです。
2.  **ログに基づく判断:**
    *   **"commit"レコードがある場合:** 調停者はCOMMITを決定した後にクラッシュしたことがわかります。したがって、不確定状態の参加者は`コミット`されるべきです。`管理者は参加者に対し、手動で`コミット`を指示します（ロールフォワード）`。
    *   **"abort" / "rollback"レコードがある場合:** 調停者はROLLBACKを決定した後にクラッシュしたことがわかります。参加者は`ロールバック`されるべきです。
    *   **何の決定レコードもない場合:** 調停者は第1相の応答を集めている最中、または決定を下す直前にクラッシュしたことを意味します。この場合、`トランザクションは完了していないため、安全側に倒して`ロールバック`させる`のが原則です。

このように、ログは障害発生時の唯一の「真実」を語る証拠となります。

---
**【初心者が勘違いしやすい点】**
「他の参加者に問い合わせて、多数派の意見に従えばよい」と考えるのは危険です。なぜなら、調停者が一部の参加者にだけCOMMIT指示を送った直後にクラッシュした、というシナリオがあり得るからです。この場合、問い合わせても`コミット`済みのノードと未決定のノードが混在し、正しい判断ができません。あくまで、`意思決定者である調停者のログが絶対的な正義`となります。

---
**【問19】**
2相`コミット`プロトコルと、単一ノードのデータベースにおける排他制御（ロック）は、どちらもデータの`一貫性`を保つための技術ですが、その目的とスコープには明確な違いがあります。「目的」と「手段」という言葉を用いて、この2つの関係性を説明してください。

---
**【解答】**
**目的:** 2相`コミット`の目的は、**分散環境**にまたがる`単一のトランザクションの**`原子性`**を保証すること`です。
**手段:** この目的を達成するための手段の一部として、`各参加ノードが自身の持つ**排他制御（ロック）**を利用してリソースを保護し、他のトランザクションからの干渉を防ぎます`。

つまり、排他制御は2相`コミット`プロトコルを構成する個々のノードレベルの基本的な機能（手段）であり、2相`コミット`はそれらの機能を協調させて、より大きなスコープ（分散環境）での`一貫性`を実現する仕組み（目的）と言えます。

---
**【解説】】**
この2つはしばしば混同されがちですが、レイヤーの異なる概念です。

*   **排他制御（ロック）:**
    *   **スコープ:** 単一のデータベース（ノード）内。
    *   **役割:** 複数のトランザクションが**同時に**同じデータにアクセスしようとした際に、データの矛盾を防ぐ（独立性/Isolationを保証する）ための仕組みです。これは分散環境でなくても必須の機能です。

*   **2相`コミット`プロトコル:**
    *   **スコープ:** 複数のデータベース（ノード）にまたがる環境。
    *   **役割:** **単一の**トランザクションが複数のノードにまたがって処理を行う際に、その処理全体が「すべて成功」か「すべて失敗」のどちらかになること（`原子性`/Atomicity）を保証するための通信規約（プロトコル）です。

2相`コミット`の第1相で、参加者が「可」と答えるために更新対象のリソースをロックしますが、この時に使われているのが、そのデータベースが元々持っている排他制御の機能なのです。

---
**【初心者が勘違いしやすい点】**
「2相`コミット`はロックの仕組みである」という短絡的な理解は不正確です。2相`コミット`はロックを**利用**しますが、その本質はロックそのものではなく、`複数の独立したノード間で「`コミット`するか否か」`の**合意を形成する**ためのプロトコルにあります。目的と手段を取り違えないようにしましょう。

---
**【問20】**
あなたは分散システムの管理者です。監視システムから「2相`コミット`のトランザクションが30分以上セキュア状態のまま留まっている」というアラートを受け取りました。最も可能性の高い原因は何だと考えられますか？ また、最初に確認すべきことは何ですか？

---
**【解答】**
**最も可能性の高い原因:** 調停者に障害が発生し、第2相の指示を参加者に送信できなくなっている（`ブロッキング問題`が発生している）。
**最初に確認すべきこと:** 調停者の死活監視ステータス（ping、プロセス稼働状況など）を確認し、実際に障害が起きているかどうかを特定すること。

---
**【解説】】**
この問題は、理論知識を実践的な障害対応シナリオに応用する力を問うています。
「トランザクションがセキュア状態のまま長時間停止している」という状況は、2相`コミット`における典型的な危険信号です。`セキュア状態とは、参加者が調停者からの指示を待っている状態`なので、これが長時間続くということは、その`指示を出すべき調停者に何か問題が起きている可能性が高い`ことを示唆しています。

**障害対応フローの初動:**
1.  **状況の解釈:** アラート内容から「`ブロッキング問題`の発生」を推測する。
2.  **原因の切り分け:** まず、`調停者が正常に稼働しているかを確認`します。ここで調停者のダウンが確認できれば、原因はほぼ特定できます。
3.  **次のアクション:** もし調停者が正常であれば、次は調停者と当該参加者との間のネットワーク経路に問題がないかを確認する、というように調査範囲を広げていきます。


了解しました、Mack。以下に、**分散トランザクションの三つの状態フェーズ（準備中・コミット待ち・確定済み）**の観点を明示した解説を追加した、完全版の問題セットを提示します。各問題には：

- 状況がどのフェーズに該当するか  
- それがどう読み取れるか（語句・構造・設計原則）  
- 他の選択肢との区別ポイント  
- 試験での判別テクニック  

をすべて含めています。

---

## 問題1：ブロッキング問題と2フェーズコミット

### 問題  
分散トランザクションにおいて、2フェーズコミット（2PC）の準備フェーズで、あるノードが応答を返さず、他のノードがコミット処理に進めない状態が長時間続いている。この状況は何と呼ばれるか。

A. セキュア状態  
B. 不確定状態  
C. ブロッキング問題  
D. ロールバック状態

### 正解：C. ブロッキング問題

### 状態フェーズ：**準備中（Prepare Phase）**

### なぜそう判断できるか：
- 「準備フェーズで応答を返さず」という記述から、まだ最終的な`コミット`指示が出ていないことがわかる。
- 他ノードが「進めない」という語句は、**`処理が停止している＝ブロッキング`**を示す。

### 他の選択肢との区別ポイント：
- **不確定状態**：状態が曖昧な場合（例：クラッシュで指示が不明）
- **セキュア状態**：認証・整合性が保証された状態。停止とは無関係
- **ロールバック状態**：処理が明示的に失敗し、巻き戻しが完了している状態

### 試験テクニック：
- 「待っている」「進めない」「応答がない」→ブロッキング問題
- 「クラッシュ」「判断できない」→不確定状態
- 「認証済み」「拒否される」→セキュア状態

---

## 問題2：不確定状態と障害時の整合性

### 問題
分散トランザクションのコミットフェーズ中にコーディネータがクラッシュし、参加ノードが「コミットすべきかロールバックすべきか」を判断できない状態に陥った。この状況は何と呼ばれるか。

A. セキュア状態
B. 不確定状態
C. ブロッキング問題
D. アトミック状態

### 正解：B. 不確定状態

### 状態フェーズ：**コミット待ち（Between Prepare and Commit）**

### なぜそう判断できるか：
- 「コミットフェーズ中」「クラッシュ」「判断できない」という語句から、**`最終指示が未到達で曖昧な状態`**であることがわかる。
- これは2PCの**最大の弱点**である「不確定状態」を示す典型例。

**確定** ＝　**コミットの確定** と同井木

### 他の選択肢との区別ポイント：
- **ブロッキング問題**：応答待ちで停止しているが、状態自体は明確。そのノードは「コミットすべきかどうか」をまだ判断する段階にない。現在の状態は「`コミット指示待ち`」または「準備済みで待機中」であることが明確にわかる。
つまり、「曖昧ではないが、進めない」＝明確な待機状態。

- **セキュア状態**：安全性が保証されている状態。曖昧さは存在しない  
- **アトミック状態**：成功か失敗かが確定している状態（不確定とは対極）

### 試験テクニック：
- 「クラッシュ」「判断不能」「曖昧」→不確定状態
- 「応答待ち」「進めない」→ブロッキング問題
- 「認証済み」「アクセス制御」→セキュア状態
- 「すべて成功 or すべて失敗」→アトミック性（≠不確定）

---

## 問題3：セキュア状態とアクセス制御

### 問題
分散トランザクションの参加ノードにおいて、認証済みのクライアントのみがトランザクション開始・コミット・ロールバックを実行できるように設計されている。この状態は何と呼ばれるか。

A. セキュア状態
B. 不確定状態
C. ブロッキング問題
D. トランザクション分離レベル

### 正解：A. セキュア状態

### 状態フェーズ：**確定済み（After Commit or Abort）**

### なぜそう判断できるか：
- 「認証済み」「操作が制限されている」という語句から、**安全性が保証された状態＝セキュア状態**であると判断できる。
- トランザクションの開始・終了が**明示的に制御されている＝状態が確定している**。

### 他の選択肢との区別ポイント：
- **不確定状態**：状態が曖昧で、処理の方向性が不明  
- **ブロッキング問題**：処理が停止しているが、認証とは無関係  
- **分離レベル**：同時実行制御に関する概念（セキュリティとは別）

### 試験テクニック：
- 「認証」「認可」「拒否される」→セキュア状態  
- 「クラッシュ」「判断不能」→不確定状態  
- 「応答待ち」「進めない」→ブロッキング問題  
- 「ダーティリード」「ファントムリード」→分離レベルの話

---





## 2相`コミット`プロトコル（Two-Phase Commit: 2PC）のブロッキング問題

### 1. 概要

#### 1-1. 定義と目的
*   **分散トランザクション（Distributed Transaction）**
    複数のデータベースやシステム（サブシステム）にまたがって`一貫性`を保ちながら処理を行うトランザクションのことです。「transaction」は「取引・処理」を意味します。

*   **2相`コミット`プロトコル（Two-Phase Commit Protocol）**
    分散トランザクションにおいて、**コーディネータ**と複数の**サブシステム**が協調し、「**すべて`コミット`**」または「**すべて`ロールバック`**」することを保証するための手順です。これにより、トランザクションの**`原子性`（All-or-Nothing）**を確保します。
    プロトコルは、第1相（prepare）で「準備OK」かを確認し、第2相（commit/rollback）で処理を確定させる2段階のフェーズで構成されます。

#### 1-2. 必要性：分散環境における課題
分散環境では、一部のサブシステムだけが処理に成功し、他のサブシステムが失敗することで、システム全体のデータに矛盾が生じる「**整合性崩壊**」が起こり得ます。2相`コミット`は、このような状況を防ぎ、全体が成功するか、あるいは全体を処理前の状態に戻すかのどちらか一方の状態を保証するために不可欠な技術です。

### 2. プロトコルの流れと全体像

#### 2-1. プロセスの全体像
```text
[コーディネータ]
   │  prepare要求
   ↓
[サブシステムA]───準備OK───→[コーディネータ]←───準備OK───[サブシステムB]
   │                                  │
   │         commit指示（またはrollback指示）
   ↓                                  ↓
`コミット`または`ロールバック`        ※クラッシュ時はログを確認して再処理
```

#### 2-2. 2つのフェーズ
| フェーズ | コーディネータの動作 | サブシステムの動作 | 状態の確定性 |
| :--- | :--- | :--- | :--- |
| **第1相：準備段階 (Prepare Phase)** | 各サブシステムに「`コミット`準備できるか？」(prepare要求)を送信する。 | ローカル処理を実行して結果を一時保留し、「準備OK」または「NG」で応答する。自身の状態をログに記録する。 | ❌ **未確定** |
| **第2相：確定段階 (Commit/Rollback Phase)** | 全サブシステムが「準備OK」なら **commit**、1つでも「NG」なら **rollback** を全サブシステムに送信する。 | 指示に従って`コミット`または`ロールバック`を実行する。指示内容をログに記録する。 | ✅ **確定** |

### 3. 障害発生時の挙動と判断基準

分散環境では、特にコーディネータがダウンした場合に、各サブシステムがどのように振る舞うかが重要になります。

#### 3-1. 基本原則：`原子性`の維持
サブシステムは、トランザクションの「**`原子性`（All-or-Nothing）**」を守ることを最優先に行動します。基本方針は以下の通りです。

> **サブシステムは、`コミット`指示を受け取っていれば`コミット`し、それ以外の場合は`ロールバック`する。**

*   コーディネータは、再起動後にログを確認し、未完了のトランザクションがあれば再処理を行います。
*   サブシステムは、タイムアウト設計により、コーディネータからの`コミット`指示が一定時間なければ、自律的に`ロールバック`します。

#### 3-2. ログの役割
*   **判断の根拠**: サブシステムは、自身がコーディネータから受け取った指示（`prepare`, `commit`, `rollback`）を永続的なログに記録します。
*   **自律的判断**: コーディネータがダウンしていても、サブシステムは自身のログを参照することで、次に取るべき行動（`コミット`か`ロールバック`か）を自律的に判断できます。
*   **安全策**: ログが破損していたり、指示がログに記録されていない（未着の）場合は、トランザクションは未確定とみなし、安全策として`ロールバック`を選択します。ログが唯一の信頼できる根拠となります。

#### 3-3. サブシステムの判断基準
コーディネータがダウンした場合、サブシステムは自身のログの状態に基づいて行動を決定します。

| サブシステムの状態 | コーディネータからの指示（ログの記録） | サブシステムの行動 | 理由 |
| :--- | :--- | :--- | :--- |
| `コミット`指示を受け取っている | あり（commit指示をログに記録済） | **`コミット`する** | トランザクションは既に確定済み。全体の整合性を守るために、処理を完了させる必要がある。 |
| `コミット`指示を受け取っていない | なし（prepare要求の受信で止まっている） | **`ロールバック`する（または待機）** | トランザクションはまだ未確定。安全性を最優先し、`ロールバック`するのが妥当。 |

#### 3-4. 状況別の詳細な判断
| 状況 | コーディネータの状態 | サブシステムのログ | サブシステムの判断 | 処理 |
| :--- | :--- | :--- | :--- | :--- |
| ① prepare要求のみ受信 | ダウン | commit指示なし | `コミット`してよいか不明 | ✅ **`ロールバック`（または待機）** |
| ② commit指示を受信済 | ダウン | commit指示あり | `コミット`すべきと判断 | ✅ **自律的に`コミット`** |
| ③ rollback指示を受信済 | ダウン | rollback指示あり | `ロールバック`すべきと判断 | ✅ **自律的に`ロールバック`** |
| ④ commit指示未着＋他のサブシステムが`ロールバック`済 | ダウン | 状態不一致の可能性 | `原子性`を守る必要あり | ✅ **`ロールバック`** |

### 4. 【応用】IPA試験における頻出ポイントとよくある誤解

#### 4-1. 試験の着眼点
*   **コーディネータのクラッシュ**: コーディネータがクラッシュした場合のサブシステムの判断が頻繁に出題されます。
*   **安全策**: 「`prepare`まで完了したが`commit`指示が届かない」場合の安全策は**`ロールバック`**である、という点が問われます。
*   **キーワード**: 「`原子性`」「All-or-Nothing」「全か無」「途中確定なし」といったキーワードが重要です。

#### 4-2. 最重要ポイント：「prepare ≠ 確定」
この一点を理解することが、2相`コミット`に関する問題を解く上で極めて重要です。

*   **prepareの意味**: `prepare`は「`コミット`してもよい準備が整った」というサブシステムからの通知にすぎません。この段階では、サブシステムはトランザクションの結果を一時的に保留しているだけで、まだ`コミット`も`ロールバック`もしていません。
*   **なぜ未確定か**: `prepare`段階では、他のサブシステムが「NG」を応答し、コーディネータが最終的に`rollback`を指示する可能性があるため、トランザクションがどちらに転ぶかは決まっていません。
*   **確定のタイミング**: トランザクションの**確定**（`コミット`または`ロールバック`）は、コーディネータからの**第2相の指示（`commit`要求または`rollback`要求）を受け取った瞬間**にのみ行われます。

#### 4-3. よくある誤解と正しい知識
| 誤解 | 正しい知識 |
| :--- | :--- |
| 「準備OK (`prepare`応答) なら`コミット`してよい」 | ✕：**`commit`指示が来なければ未確定**です。`原子性`を守るため、指示がなければ`ロールバック`します。 |
| 「他のサブシステムが`コミット`していれば自分も`コミット`してよい」 | ✕：コーディネータ経由の指示がなければ、他のサブシステムの状況を基準に**勝手に確定してはいけません**。 |
| 「ログがない場合も、最後の応答を頼りに処理できる」 | ✕：**ログが唯一の信頼できる根拠**です。ログが破損・存在しない場合は、安全側（`ロールバック`）に倒すのが原則です。 |







---

## 【最終決定版】2相`コミット`プロトコル（Two-Phase Commit: 2PC）の完全解説書

### 1. 2相`コミット`プロトコルとは何か？

#### 1.1. 問題提起：なぜこの技術が必要なのか？
複数のデータベースにまたがる処理（**分散トランザクション**）では、一部の処理は成功し、他は失敗するという「中途半端な状態」が発生し得ます。これを放置すると、システム全体のデータが食い違い、致命的な**整合性崩壊**を引き起こします。2相`コミット`は、この問題を解決するために生まれました。

#### 1.2. 解決策としての2PC：定義と目的
2相`コミット`プロトコルは、「**トランザクションに参加する全てのシステムが、一斉に`コミット`（確定）するか、一斉に`ロールバック`（破棄）するかのどちらか一方の状態になること**」を保証するための通信規約です。

これにより、データベースのトランザクション特性**ACID**のうち、分散環境において特に維持が困難な**`原子性`（Atomicity）**を担保します。

-   **`原子性` (Atomicity)**: 「すべて実行されるか、まったく実行されないか」を保証する **All-or-Nothing** の原則。2相`コミット`はこの`原子性`を実現するための「司令塔」の役割を果たします。
-   **`一貫性` (Consistency)**: `原子性`が保証されることで、データの不整合が防がれ、システム全体の`一貫性`が保たれます。

#### 1.3. 構成要素：調停者と参加者
2相`コミット`は、オーケストラの指揮者と演奏者のような、明確な役割分担で成り立っています。

-   **調停者 (Coordinator)**: **指揮者**に相当します。トランザクション全体の最終的な意思決定（`コミット`か`ロールバック`か）を行い、その決定を全参加者に指示する中心的な役割を担います。調停者自身は、**単一障害点（SPOF）**となる潜在的なリスクを抱えています。
-   **参加者 (Participant)**: **演奏者**に相当します。実際にデータベースの更新処理を行い、調停者からの問い合わせに応答し、最終的な指示に従います。

### 2. どのように動作するのか？（正常系のシーケンス）

#### 2.1. 全体像の図解
プロトコルの流れは、以下のテキスト図で視覚的に理解できます。

```text
[調停者]
   │  1. COMMIT可否問合せ (prepare要求)
   ↓
[参加者A] ─── 2. 準備OK ───→ [調停者] ←─── 2. 準備OK ─── [参加者B]
   │                                │
   │         3. COMMIT実行要求 (commit指示)
   ↓                                ↓
4. `コミット`実行                    4. `コミット`実行
```

#### 2.2. 第1相：投票フェーズ (Prepare Phase) - 意思決定のための情報収集
**目的**: トランザクションを`コミット`できるか否かを、全参加者の意思を確認して判断するための準備段階です。

1.  **調停者のアクション**: 全参加者に対し、「このトランザクションを`コミット`できる準備は整っているか？」を問う「**COMMIT可否問合せ (prepare要求)**」を送信します。
2.  **参加者のアクション**:
    -   **`コミット`可能**: 更新内容を永続的なログに記録し、いつでも`コミット`できる状態（**セキュア状態**）になった上で、調停者に「**準備OK (可)**」と返答します。
    -   **`コミット`不可能**: 自身の処理を`ロールバック`し、調停者に「**否**」と返答します。この場合、他の参加者を待つ必要はないため、セキュア状態には入らず、即座にトランザクションから離脱します。

#### 2.3. 第2相：決定フェーズ (Commit/Rollback Phase) - 決定の執行
**目的**: 第1相で下した決定を、全参加者に伝達し「実行させる」フェーズです。

1.  **調停者のアクション**:
    -   **`コミット`決定**: **全ての参加者から「準備OK」の応答を受け取った場合**、自身のログに決定を記録した後、全参加者へ「**COMMIT実行要求 (commit指示)**」を送信します。
    -   **`ロールバック`決定**: **一人でも「否」と応答した、またはタイムアウトした参加者がいた場合**、ログに決定を記録した後、全参加者へ「**ROLLBACK実行要求 (rollback指示)**」を送信します。

2.  **参加者のアクション**: 調停者からの最終指示に従い、`コミット`または`ロールバック`を実行してトランザクションを完了させます。

### 3. 理解を深めるための重要概念

#### 3.1. セキュア状態 (Prepared State)
第1相で「可」と返答した参加者が入る、**「更新は完了したが、まだ`コミット`も`ロールバック`もしていない、いわば『仮押さえ』の中間状態」**を指します。この状態は「`コミット`も`ロールバック`もできず、身動きが取れない状態」という不安定な側面を持ち、リソースをロックしたまま外部からの指示を待つため、後述する**ブロッキング問題**の直接的な原因となります。

#### 3.2. トランザクションログ (WAL: Write-Ahead Logging)
障害からの復旧を支える唯一の信頼できる根拠であり、「**記憶の命綱**」です。各ノードは、自身の状態が変化する重要なタイミング（prepare, commitなど）で、**何かを実行する前に、まずその実行内容をログに書き出し**ます。これにより、万が一クラッシュしても、再起動時に「自分は何をしようとしていたか」を思い出し、処理を再開できます。

#### 3.3. 排他制御 (ロック) との関係：目的と手段
この2つはレイヤーの異なる概念です。
-   **目的**: 2相`コミット`の目的は、**分散環境**における**`原子性`**の保証です。
-   **手段**: この目的を達成するため、各参加ノードは自身の持つ**排他制御（ロック）**を利用してリソースを保護します。

つまり、排他制御は2相`コミット`を構成する個々のノードレベルの基本的な機能（手段）であり、2相`コミット`はそれらを協調させて、より大きなスコープでの`一貫性`を実現する仕組み（目的）と言えます。

### 4. 最大の課題と障害発生時の対応（異常系のシナリオ）

#### 4.1. ブロッキング問題：2PCのアキレス腱
一部のノード障害が、無関係の正常なノードの処理まで停止させてしまう、2相`コミット`最大の欠点です。

-   **調停者障害**: 第1相完了後に調停者がクラッシュすると、セキュア状態の参加者は`コミット`も`ロールバック`もできず、リソースをロックしたまま永久待機します。この身動きが取れない状態を「**不確定状態 (Uncertain State)**」と呼びます。
-   **参加者障害/ネットワーク遅延**: 第2相の指示が一部の参加者に届かない場合、その参加者だけがリソースをロックし続け、システム全体のボトルネックとなります。

#### 4.2. 障害発生時の判断ロジック（参加者の視点）
調停者がダウンした場合、参加者は自身のログだけを頼りに自律的に判断しなければなりません。

| 状況 | 参加者のログ | 実行すべき処理 | 理由 |
| :--- | :--- | :--- | :--- |
| ① prepare要求のみ受信 | commit/rollback指示なし | **`ロールバック`**（または待機） | トランザクションは**未確定**。安全性を守るため`ロールバック`が妥当。 |
| ② commit指示を受信済 | commit指示あり | **`コミット`** | トランザクションは**確定済**。整合性を守るために処理を完了する必要がある。 |
| ③ rollback指示を受信済 | rollback指示あり | **`ロールバック`** | トランザクションは**破棄が確定済**。 |
| ④ 他の参加者が`ロールバック`済 | commit/rollback指示なし | **`ロールバック`** | **`原子性`**を守る必要があるため、自分だけ`コミット`することは許されない。 |

#### 4.3. 管理者による手動復旧プロセス
「トランザクションが長時間セキュア状態のまま」というアラートは、ブロッキング問題発生の典型的な兆候です。その際の復旧手順は以下の通りです。

1.  **原因特定**: まず**調停者の死活ステータスを確認**します。
2.  **ログ調査**: ダウンした**調停者のトランザクションログを調査**します。これが判断の絶対的な正義となります。
3.  **強制実行**:
    -   ログに「COMMIT」記録があれば、不確定状態の参加者に**`コミット`を強制実行（ロールフォワード）**させます。
    -   ログに「ROLLBACK」記録があるか、何の決定も記録されていない場合は、**`ロールバック`を実行**させます。

### 5. 試験対策とよくある誤解

#### 5.1. 最重要コンセプト：「prepare＝まだ確定していない」
この一点を理解すれば、障害時の問題は確実に解けます。「`コミット`可能状態」と「`コミット`確定」は全くの別物です。トランザクションの**確定**は、第2相の指示によってのみ行われます。
```text
第1相：prepare（未確定）
  ↓ ＜この境界線は後戻りできない＞
第2相：commit or rollback（確定）
```
#### 5.2. よくある誤解と正しい知識

| 誤解 | 正しい知識 |
| :--- | :--- |
| 「準備OK」なら`コミット`してよい。 | ✕：**commit指示がなければ未確定**。`原子性`を守るため`ロールバック`が原則です。 |
| 他の参加者の状態を見て判断してよい。 | ✕：調停者経由の指示がなければ**勝手に確定してはいけません**。不整合を拡大させるリスクがあります。 |
| 過半数が「可」なら`コミット`される。 | ✕：**全員一致が原則**です。データベースの整合性は妥協を許しません。 |
| Sagaパターンは2PCの上位互換である。 | ✕：**トレードオフの関係**です。Sagaはブロッキングしませんが、**独立性 (Isolation)** を完全には保証しないという代償を支払います。 |

### 6. 発展的なトピックと代替技術

#### 6.1. スケーラビリティの限界
参加ノードが増えるほど、通信回数と障害発生確率が高まり、性能（**レイテンシ**、**スループット**）と**可用性**が低下します。そのため、2相`コミット`は比較的小規模で、**密結合**な信頼性の高いシステムに適しています。

#### 6.2. 代替技術
-   **3相`コミット` (3PC)**: ブロッキングを理論的に回避しますが、プロトコルが複雑で性能が低いため、実システムでの採用は稀です。
-   **Sagaパターン**: **疎結合**なマイクロサービスアーキテクチャで注目される設計パターンです。失敗時は「**補償トランザクション**」で後始末をします。

### 7. まとめ
2相`コミット`プロトコルは、分散システムにおけるデータ`一貫性`を支える古典的かつ強力な技術です。その厳格な動作は`原子性`を保証する一方で、ブロッキング問題という深刻な課題も抱えています。このプロトコルの核心は**「prepare＝未確定」**という一点に集約され、障害発生時には**トランザクションログ**が唯一の真実を語る羅針盤となります。現代のシステム設計においては、その特性を正しく理解し、Sagaパターンのような代替技術とのトレードオフを考慮した上で、適切な場面で選択することが求められます。