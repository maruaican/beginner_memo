
USER
AP試験の午後のデータベースの問題にはSQL文の穴埋め問題があるよね。
どうやってアプローチすればいいだろうか。
私は、次のような点からアプローチしている。
*   FROM句の表の属性（ER図から）を探って、使われていない属性はないか。
*   SELECT内に集約関数があれば、GROUP BYが使われているか。
*   COALESCEが使われていれば、LEFT JOINが使われるはずだ。
*   埋め込み変数”例` ：発注番号`”が本文で設定されていれば、必ずSQL文内には使われる。
*   本文に「昇順」「降順」とあれば、ORDER BYが使われる。
*   本文に「ごとに」、「～別」と記載されていれば、GROUP BYが使われる。あるいは、ウィンドウ関数のPARTTION BYが使われる。
*   LEFT JOINされた後の表（別名）にはNULLが含まれているので、それを処理しなければならない。
など。
今までの過去問を分析して、どのようにアプローチすればいいか、一覧として出力して。

LLM
午後のデータベースSQL穴埋め問題は「本文・ER図・SQL部分の三点照合」をしながら、典型的な“お作法”を抑えるのがコツです。

以下に、過去問分析から整理した **アプローチ一覧** を提示します。

---

## 応用情報技術者試験 SQL穴埋め問題の体系的解法

## 1. SQL穴埋め問題への基本アプローチ

### 1.1. 問題読解のプロセスと3つの着眼点
SQLの穴埋め問題を解く際は、以下のプロセスと着眼点を意識することが重要です。

*   **読解プロセス**: 基本的な確認の順番は `本文（問題文） → ER図 → 部分SQL → 解答欄` です。

---

### 1.1. 解答を導く3つの着眼点

SQLの穴埋め問題を解く上で、以下の3つの視点から多角的にアプローチすることが、正答への近道となります。

1.  **本文のキーワード**: 問題文中の「～ごとに」「～がない場合でも」といった日本語の表現が、適切なSQL構文（例: `GROUP BY`, `LEFT JOIN`）に正しく反映されているかを確認します。

2.  **ER図とテーブル構造**: ER図やテーブル定義から読み取れるテーブル間の関係性や構造が、SQLに正確に落とし込まれているかを検証します。これには、以下の具体的なチェックポイントが含まれます。

3.  **SQL構文の正当性**: 集約関数と`GROUP BY`句の整合性や、サブクエリの戻り値の数や型など、SQLの基本的な文法ルールが守られているかをチェックします。

### 1.2. ER図とテーブル構造から読み解くべきポイント

特にER図とテーブル構造の分析は、問題の根幹を理解する上で極めて重要です。以下のポイントを重点的に確認することで、設問の意図を正確に把握し、ミスを未然に防ぐことができます。

*   **リレーションシップの確認**
    *   **JOIN条件の特定**: ER図におけるテーブル間のリレーション（例: 「多←1」の矢印）を正確に読み取り、主キーと外部キーに基づく正しい`JOIN`条件（例: `ON T1.外部キー = T2.主キー`）が記述されているかを確認します。
    *   **中間表の役割**: 「多対多」の関係を解消するための中間表（例：注文明細テーブル）は、`JOIN`の記述漏れが起こりやすい箇所です。その必要性とクエリ内での使われ方を特に注意してチェックします。

*   **属性の利用状況の確認**
    *   **属性の過不足チェック**: `FROM`句で指定されているテーブルの全属性をリストアップし、それらが`SELECT`句、`WHERE`句、`JOIN`条件などで過不足なく使用されているかを確認します。これにより、考慮から漏れている属性がないかを検証できます。

---
## 2. 出題者が狙う誤答パターン（頻出の罠）

応用情報技術者試験では、SQLの基本的な知識だけでなく、間違いやすいポイントを意図的に狙った問題が出題されます。

### 条件句の混同
*   **`WHERE`句 と `HAVING`句 の混同**
    *   **狙い**: 集約「前」の条件と集約「後」の条件の使い分けを理解しているかを問う。
    *   **正しい理解**:
        *   `WHERE`：`GROUP BY`で集約する`前`の、`個々の行`に対する条件。
        *   `HAVING`：`GROUP BY`で集約した`後`の、`グループ`に対する条件。
    *   **誤答例**: `SELECT 部署ID, AVG(給与) FROM 社員 WHERE AVG(給与) >= 300000 GROUP BY 部署ID;` （`WHERE`句で集約関数は使えない）
**正答例**
```sql
SELECT 部署ID, AVG(給与) AS 平均給与
FROM 社員
GROUP BY 部署ID
HAVING AVG(給与) >= 300000;　WHEREではなく、HAVINGを使う。
```
*   **`ON`句 と `WHERE`句 の混同 (特に`LEFT JOIN`時)**
    *   **狙い**: `LEFT JOIN`において、結合条件と絞り込み条件の違いが結果にどう影響するかを理解しているかを問う。
    *   **正しい理解**:
        *   `ON`：テーブルを「結合するための条件」。ここに右側テーブルの条件を書くと、条件に合わない行は`NULL`として結合されるが、左側テーブルの行は残る。
        *   `WHERE`：結合が「完了した後の結果」から行を絞り込む条件。ここに右側テーブルの条件を書くと、`NULL`の行が除外され、`INNER JOIN`と同じ結果になることがある。
    *   **例**: `LEFT JOIN ... WHERE B.状態='有効'` と書くと、`B`テーブルに対応するデータがない行（`B.状態`が`NULL`）が除外されてしまう。

###　NOT IN` と `NULL` の罠
## `NOT IN` vs `NOT EXISTS` の出力結果の違い（NULLを含む場合）

### `NOT IN` の場合
- サブクエリに `NULL` が含まれていると、**比較結果がすべて `UNKNOWN` になる**。
- SQLの論理評価では、`UNKNOWN` を含むと `NOT IN` 全体の評価が `FALSE` とみなされる。
- そのため、**出力結果はゼロ件（全件除外）**になる。

### `NOT EXISTS` の場合
- サブクエリ内で `l.user_id = u.id` のような比較が成立するかどうかだけを評価する。
- `NULL` は比較に失敗し、**そのNULLだけが評価対象外**になるだけ。
- 一致する行がなければ、その `users.id` は出力される。
- よって、**NULL以外の一致しない値は正しく出力される**。

### 表形式でまとめ

| クエリ形式     | サブクエリ内に `NULL` がある場合 | 出力結果の挙動                     |
|----------------|----------------------------------|------------------------------------|
| `NOT IN`       | 比較不能 → 全体が `FALSE`         | **出力ゼロ件（全件除外）**         |
| `NOT EXISTS`   | `NULL` は無視 →比較可能な値のみ評価 | **NULL以外の未一致行は出力される** |


*   **`LEFT JOIN` 後の `COALESCE` 忘れ**
    *   **狙い**: 「～ない場合は0と表示」という要件に対し、`LEFT JOIN`だけで満足し、`NULL`を`0`に置換し忘れるミスを誘う。
    *   **正しい理解**: `LEFT JOIN`で対応するデータがなかった場合、集計関数(`SUM`, `COUNT`など)の結果は`NULL`になる。これを`0`として表示するには`COALESCE(SUM(...), 0)`のように明示的な変換が必要。

### 集約と列指定のルール違反
*   **`GROUP BY` の記述漏れ**
    *   **狙い**: `SELECT`句に集約関数と非集約列を混在させる際のルールを理解しているかを問う。
    *   **正しい理解**: `SELECT`句に集約関数とそれ以外の列（非集約列）を記述する場合、すべての非集約列を`GROUP BY`句に指定しなければならない。

*   **スカラサブクエリの複数行返却**
    *   **狙い**: `SELECT`句内や`WHERE`句の`=`の右辺で使うサブクエリが、必ず単一の値（1行1列）を返さなければならないというルールを突く。
    *   **正しい理解**: サブクエリが複数行を返す可能性がある場合、`MAX`, `MIN`などで1行に絞るか、`IN`や`EXISTS`を使うなど、構文を切り替える必要がある。

---
## 3. 頻出SQLパターン 実践コード演習

-----
応用情報技術者試験レベルの総合的な制約問題を作成いたします。

## SQLデータベース制約の総合問題

### 問題
ある企業の人事システムにおいて、以下の要件を満たす社員テーブルを作成する必要があります。

**要件：**
- 社員IDは各社員を一意に識別する主キーとする
- 社員名は必須入力項目とする
- 入社状態は未入力の場合「在職」を初期値とする
- 部署IDは部署マスタテーブルの部署IDを参照する外部キーとする
- 年齢は１８歳以上６５歳以下の範囲内のみ許可する

以下のCREATE TABLE文の空欄を埋めて、上記要件を満たすテーブル定義を完成させてください。

```sql
CREATE TABLE 社員 (
    社員ID VARCHAR(10) 【 a 】 【 b 】,
    社員名 VARCHAR(50) 【 c 】 【 d 】,
    入社状態 VARCHAR(10) 【 e 】 '在職',
    部署ID VARCHAR(10),
    年齢 INTEGER 【 f 】 (年齢 >= 18 AND 年齢 <= 65),
    【 g 】 【 h 】 (部署ID) 【 i 】 部署マスタ(部署ID)
);
```

**【回答】**
`a`: PRIMARY
`b`: KEY
`c`: NOT
`d`: NULL
`e`: DEFAULT
`f`: CHECK
`g`: FOREIGN
`h`: KEY
`i`: REFERENCES

**【この構文が必要な理由】**
企業の人事データでは、データの整合性と業務ルールの遵守が極めて重要であり、各制約によってシステムレベルでデータ品質を保証する必要があります。

**【構文の解説】**
- `PRIMARY KEY`: テーブル内で各行を一意に識別する主キーを定義
- `NOT NULL`: 該当列へのNULL値格納を禁止し、必須入力を強制
- `DEFAULT 値`: INSERT時に値が省略された場合の既定値を設定
- `CHECK (条件式)`: 指定した条件を満たす値のみの入力を許可
- `FOREIGN KEY (列名) REFERENCES テーブル名(列名)`: 他テーブルとの参照整合性を維持

**【初心者が陥りがちな誤解や誤答例】**
* **誤解/誤答**: 制約の記述順序を間違える（例：`DEFAULT NOT NULL`の順序で記述）
* **解説**: SQL標準では制約の記述順序が決まっており、一般的に「データ型 → NOT NULL → DEFAULT → CHECK → 主キー」の順序で記述します。また、外部キー制約は列定義の後に独立した制約として記述するのが標準的です。

* **誤解/誤答**: `FOREIGN KEY`制約で参照先テーブルの列名を省略する
* **解説**: `REFERENCES`句では参照先テーブル名だけでなく、参照先の列名も明示的に指定する必要があります。省略すると構文エラーになります。

* **誤解/誤答**: `CHECK`制約の条件式で列名を引用符で囲む
* **解説**: CHECK制約の条件式内で使用する列名は、文字列リテラルではないため引用符で囲んではいけません。`CHECK ('年齢' >= 18)`は誤りで、`CHECK (年齢 >= 18)`が正解です。




### 問題1

月末棚卸しのため、「倉庫C003で在庫が100以上ある商品」について、**全倉庫での在庫合計**を出したい。空欄を埋めよ。

```sql
SELECT 商品コード, SUM(在庫数) AS 在庫合計
FROM 在庫
WHERE 商品コード 【 a 】 (
  SELECT 商品コード
  FROM 在庫
  WHERE 倉庫番号 = 'C003' AND 在庫数 >= 100
)
GROUP BY 商品コード;
```

**【回答】**
`a`: IN

**【この構文が必要な理由】**
内側は「商品コードの集合（1列複数行）」を返すため、外側の行がその集合に**属するか**を判定する `IN` が最短・明解。

**【構文の解説】**

  * 形：`値 IN (サブクエリ)`（サブクエリは1列複数行）
  * 役割：集合への所属判定。重複は自動的に無害化される。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`商品コード = (SELECT 商品コード ...)`

      * **解説**：サブクエリが複数行を返す可能性があり不適切。`=` は**1行1列**専用。

  * **誤答**：`EXISTS (SELECT ...)` に置換

      * **解説**：書けるが「集合所属」は `IN` が自然で可読性・保守性が高い。

  * **性能感**：`IN` は**軽い/高速**（索引があれば特に）。内側に適切な索引（`在庫(倉庫番号, 在庫数, 商品コード)`）でさらに高速。

-----

### 問題2

「**一度でも注文した顧客**」を抽出したい。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客 o
WHERE 【 a 】 (
  SELECT 1
  FROM 注文 i
  WHERE i.顧客ID = o.顧客ID
);
```

**【回答】**
`a`: EXISTS

**【この構文が必要な理由】**
「関連行が**1件でも存在**するか」を問う設計には `EXISTS` が最短で、行の中身ではなく**存在**だけを見るため効率的。

**【構文の解説】**

  * 形：`EXISTS (SELECT 1 FROM 関連表 WHERE 関連表.key = 外側.key AND 条件)`
  * 役割：存在の有無だけ真偽化（件数は不要）。
  * 評価順注記：**FROM→WHERE(外側)** → `EXISTS` 内部で必要最小限の探索。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`SELECT *` にしないと速くならない

      * **解説**：`EXISTS` は**存在のみ**評価。`SELECT 1` で十分（中身は読まない）。

  * **誤答**：`IN (SELECT 顧客ID FROM 注文)` に必ず置換

      * **解説**：`IN` でも等価になりやすいが、相関条件や追加条件が多いと `EXISTS` の方が**軽い/高速**になる場面が多い（索引命中時）。

-----

### 問題3

「**一度も注文が無い顧客**」を抽出したい。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客 o
WHERE 【 a 】 (
  SELECT 1
  FROM 注文 i
  WHERE i.顧客ID = o.顧客ID
);
```

**【回答】**
`a`: NOT EXISTS

**【この構文が必要な理由】**
`NOT IN` は内側に `NULL` が混入すると意図せず結果が**0件**になり得る。`NOT EXISTS` は**NULL非依存**で安全。

**【構文の解説】**

  * 形：`NOT EXISTS (相関サブクエリ)`
  * 役割：関連行が**1件も無い**ことの判定（NULLの影響なし）。
  * 評価順注記：外側を1行ずつ検査→内側で該当行の有無だけチェック。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`顧客ID NOT IN (SELECT 顧客ID FROM 注文)`

      * **解説**：内側 `顧客ID` に `NULL` が1つでもあると三値論理で**UNKNOWN**に倒れ外側が落ちる。

  * **性能感**：適切な索引（`注文(顧客ID)`）があれば **軽い/高速**。フルスキャンは**重い/低速**。

-----

### 問題4

「**ブラックリスト顧客**（テーブル：取引停止(顧客ID)）を除外して顧客を一覧」する。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客
WHERE 顧客ID 【 a 】 (
  SELECT 顧客ID
  FROM 取引停止
  WHERE 顧客ID 【 b 】 
);
```

**【回答】**
`a`: NOT IN
`b`: IS NOT NULL

**【この構文が必要な理由】**
`NOT IN` は内側に `NULL` があると外側が**全落ち**するため、内側で `IS NOT NULL` を加えて候補から除外しておく。

**【構文の解説】**

  * 形：`値 NOT IN (SELECT 列 FROM T WHERE 列 IS NOT NULL)`
  * 役割：否定の集合比較だが、**NULL除外**が実務必須。
  * 評価順注記：内側WHEREでNULL除外→外側WHEREで否定所属判定。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`NOT IN` は `NULL` を自動無視

      * **解説**：いいえ。`NOT IN` は `NULL` が1つでもあるとUNKNOWNへ。

  * **代案**：`NOT EXISTS` が**推奨**（より安全・読みやすい）。

  * **性能感**：`NOT EXISTS` の方が最適化しやすく**速い**ことが多い。

-----

### 問題5

「**特売商品**（特売商品(商品コード)）に含まれる商品だけ、商品マスタから抽出」したい。

```sql
SELECT 商品コード, 商品名
FROM 商品マスタ
WHERE 商品コード = 【 a 】 (
  SELECT 商品コード
  FROM 特売商品
);
```

**【回答】**
`a`: ANY

**【この構文が必要な理由】**
`= ANY(集合)` は `IN(集合)` と等価で、**単一値比較の形**で集合所属を表現できる。

**【構文の解説】**

  * 形：`式 = ANY (サブクエリ)`（1列複数行）
  * 量化の意味：**いずれか**と等しければ真。
  * 評価順注記：内側で候補集合→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`ANY` は「任意の値より大きい」の意味

      * **解説**：演算子と**組み合わせ**で意味が決まる。`= ANY` は `IN`、`> ALL` は「最大より大きい」など。

  * **性能感**：`IN` と同程度。索引が利くと**高速**。

-----

### 問題6
「**部門内で給与が全員より高い社員**」を抽出する。自分自身は除外して比較する。

```sql
SELECT 社員ID, 社員名, 部署ID, 給与
FROM 社員 s
WHERE 給与 【 a 】 (
  SELECT 給与
  FROM 社員 t
  WHERE t.部署ID = s.部署ID
    AND t.社員ID <> s.社員ID
);
```

**【回答】**
`a`: > ALL

**【この構文が必要な理由】**
`> ALL(集合)` は「集合の**最大値より大きい**」と同値。部署内の全員より高いを1発で表現。

**【構文の解説】**

  * 形：`式 > ALL(サブクエリ)`
  * 等価形：`給与 > (SELECT MAX(給与) FROM 社員 WHERE 部署ID = 自.部署ID AND 社員ID <> 自.社員ID)`
  * 評価順注記：内側で比較集合→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`>= ALL`

      * **解説**：自分と同額の誰かがいれば成立してしまう。問題は「全員より高い」なので `>`。

  * **性能感**：`MAX` 等価形に書き換えると**軽い/高速**になりやすい（集約1回）。

-----
### 問題7

「**競合より最安**の自社商品」を抽出する（競合価格(商品コード, 競合単価)）。

```sql
SELECT s.商品コード, s.商品名, s.単価
FROM 商品マスタ s
WHERE s.単価 【 a 】 (
  SELECT 競合単価
  FROM 競合価格 c
  WHERE c.商品コード = s.商品コード
);
```

**【回答】**
`a`: <= ALL

**【この構文が必要な理由】**
`<= ALL(集合)` は「集合の**最小値以上ではない**」= **最小値以下**。競合のどれよりも高くない → **最安**を表現。

**【構文の解説】**

  * 形：`式 <= ALL(サブクエリ)`
  * 等価形：`自.単価 <= (SELECT MIN(競合単価) FROM 競合価格 WHERE 商品コード=自.商品コード)`
  * 評価順注記：内側で比較集合（商品ごと）→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`< ANY` で最安

      * **解説**：`< ANY` は「**どれか1つ**より小さい」だけ。最安保証にならない。

  * **性能感**：`MIN` 等価形は**軽い/高速**になりやすい。

-----

### 問題8

「**部門平均より給与が高い社員**」を抽出せよ。

```sql
SELECT 社員ID, 社員名, 部署ID, 給与
FROM 社員 o
WHERE 給与 > (
  SELECT 【 a 】(給与)
  FROM 社員 d
  WHERE d.部署ID = o.部署ID
);
```

**【回答】**
`a`: AVG

**【この構文が必要な理由】**
スカラサブクエリ（`=` や `>` と比較）は**必ず1行1列**。部門ごとに複数行になる集合を `AVG` で**単一値**へ縮約する。

**【構文の解説】**

  * 形：`式 [比較] (SELECT 集約(列) FROM ... WHERE ...)`
  * 役割：相関して**部門単位の代表値**（平均）を得る。
  * 評価順注記：外側1行ごとに内側を評価（相関）。
  * 補足：`GROUP BY 部署ID` を使わず相関で1部署に限定→1行化。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`WHERE 給与 > (SELECT 給与 FROM 社員 WHERE 部署ID = 外側.部署ID)`

      * **解説**：内側が**複数行**になり不適。集約（`AVG`/`MAX`）で1行化が必要。

  * **性能感**：相関は行数分だけ内側が回るため**重い/低速**になりがち。等価形（`JOIN`＋`GROUP BY`）で改善可。

-----
はい、承知いたしました。応用情報技術者試験の講師として、ご指定の形式とルールに基づき、SQLの基本文法を学習するための高品質な穴埋め問題集を作成します。

---

### 問題
「社員」テーブルには、全社員の氏名、年齢、所属部署IDが格納されています。ここから、各社員の氏名と年齢に加えて、「その社員が所属する部署の平均年齢」を算出し、一覧で表示したいと考えています。

このように、個別のレコードと、そのレコードが属するグループの集計値（この場合は部署ごとの平均年齢）を同時に取得するためには、どのようにSQLを組み立てればよいでしょうか。以下のSQL文の空欄を埋めてください。

```sql
SELECT
  S.氏名,
  S.年齢,
  DeptAvg.平均年齢
FROM
  社員 S
【 a 】 (
  SELECT
    所属部署ID,
    AVG(年齢) AS 平均年齢
  FROM
    社員
  【 b 】
    所属部署ID
) 【 c 】
  ON S.所属部署ID = DeptAvg.所属部署ID;
```

### 【回答】
a: `INNER JOIN`
b: `GROUP BY`
c: AS DeptAvg ※ASは省略可能。APではほとんど省略されるので、可読性は悪く作られている。

### 【この構文が必要な理由】
個々の社員レコードと、「部署ごと」という異なる粒度で集計した平均年齢データを、1つの結果セットとして結合して表示する必要があるためです。

### 【構文の解説】
このSQLでは、FROM句の中で副問い合わせ（サブクエリ）を使い、それを仮想的なテーブル（インラインビュー）として扱っています。

*   **`FROM ... INNER JOIN (SELECT ... ) AS <別名> ON ...`**:
    *   `()` 内の`SELECT`文が先に実行され、部署IDごとの平均年齢を算出した一時的なテーブル（この例では`DeptAvg`）が作成されます。
    *   `INNER JOIN`句と`ON`句を使い、元の「社員」テーブルとこの一時的なテーブルを`所属部署ID`をキーにして結合します。

*   **`GROUP BY <列名>`**:
    *   指定した列（この例では`所属部署ID`）の値が同じ行を一つのグループにまとめます。
    *   `AVG()`、`SUM()`、`COUNT()`などの集計関数と組み合わせて使用し、グループごとの集計値を算出するために必須の句です。

### 【初心者が陥りがちな誤解や誤答例】
*   **誤解/誤答**: `SELECT`句の中で、各行に対して平均年齢を計算する副問い合わせを書けば良いのでは？
    *   （例）`SELECT S.氏名, S.年齢, (SELECT AVG(T.年齢) FROM 社員 T WHERE T.所属部署ID = S.所属部署ID) FROM 社員 S;`
*   **解説**: この書き方（相関副問い合わせ）でも同じ結果は得られますが、一般的にパフォーマンスが劣る可能性があります。FROM句で用いる副問い合わせは最初に一度だけ実行されるのに対し、SELECT句に記述した相関副問い合わせは外側のクエリの行ごとに繰り返し実行されるため、データ量が多い場合に処理時間が大幅に増えることがあります。応用情報技術者試験では、処理効率を意識したSQLの記述も重要です。




### 問題9

「**部署ごとの平均給与が30万円以上の部署**」の部署名と平均給与を求めよ。

```sql
SELECT 部署名, AVG(給与) AS 平均給与
FROM 社員
JOIN 部署 ON 部署.部署ID = 社員.部署ID
【 a 】 部署名
【 b 】 AVG(給与) >= 300000;
```

**【回答】**
`a`: GROUP BY
`b`: HAVING

**【この構文が必要な理由】**
**集計後の条件**は `HAVING`。`WHERE` は集計**前**の行を絞る。役割分担が逆だと論理破綻。

**【構文の解説】**

  * 形：`... GROUP BY 集約単位 HAVING 集約結果の条件`
  * 役割：`GROUP BY` で単位を作り、`HAVING` で**集計結果**をフィルタ。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤答**：`WHERE AVG(給与) >= 300000`

      * **解説**：`WHERE` では集約関数は使えない（まだ集計していない）。

  * **性能感**：前段の `WHERE` で母集団を減らせるなら**高速化**。適切な索引（`社員(部署ID, 給与)`）。

-----

### 問題10

「**2025年9月に一度でも売れた商品**」の**全倉庫在庫合計**を出せ。高速性を重視しろ。

```sql
SELECT 在庫.商品コード, SUM(在庫.在庫数) AS 在庫合計
FROM 在庫
WHERE 在庫.商品コード IN (
  SELECT 【 a 】 商品コード
  FROM 注文
  JOIN 注文明細 ON 注文明細.注文ID = 注文.注文ID
  WHERE 注文.注文日 >= DATE '2025-09-01'
    AND 注文.注文日 <  DATE '2025-10-01'
)
GROUP BY 在庫.商品コード;
```

**【回答】**
`a`: DISTINCT

**【この構文が必要な理由】**
`IN` は重複に強いが、内側の結果を `DISTINCT` で**最小化**するとヒット検査が**軽い/高速**になりやすい（実装依存）。

**【構文の解説】**

  * 形：`IN (SELECT DISTINCT キー FROM ... WHERE 条件)`
  * 役割：**キー集合**を先に確定（非相関）→外側で合計。
  * 評価順注記：内側WHEREで月を確定→`DISTINCT` でキー縮約→外側WHERE→外側GROUP BY。

**【初心者が陥りがちな誤解や誤答例】**

  * **誤解**：`DISTINCT` は常に不要

      * **解説**：論理的には不要でも、物理的には**重複削減**がプラン最適化に効く場合がある。

  * **代案**：`EXISTS` への等価変形（半結合）でも**高速**になることが多い。

---
## 補助メモ（検算テンプレ：頭の中で常に往復）
* `t.key IN (SELECT key FROM S WHERE 条件)`
  ⇔ `EXISTS (SELECT 1 FROM S WHERE 条件 AND S.key = t.key)`
* `x > ALL(SELECT y FROM S WHERE 条件)`
  ⇔ `x > (SELECT MAX(y) FROM S WHERE 条件)`
* `x < = ALL(SELECT y FROM S WHERE 条件)`
  ⇔ `x <= (SELECT MIN(y) FROM S WHERE 条件)`
* **NULL安全原則**：否定は `NOT EXISTS`、やむを得ず `NOT IN` なら**内側で `IS NOT NULL`**
* 上記を問う問題は以下の通り。

---
### 問題

**【ミッション】**
マーケティング部から「今月購入履歴のある優良顧客のリストが欲しい」と依頼された。このタスクを遂行するため、あなたは`顧客マスタ`と`売上明細`テーブルを使い、2つの設計図を書き始めた。しかし、それぞれの設計図には、不可欠なパーツが欠けている。
以下の2つのSQLを、それぞれの設計思想に沿って完成させよ。

```sql
-- 設計思想A:「今月購入した顧客IDの"リスト"」を先に作り、それと照合する
SELECT 顧客ID, 氏名
FROM 顧客マスタ
WHERE
    顧客ID 【 a 】 (SELECT 【 b 】 顧客ID FROM 売上明細);

-- 設計思想B: 顧客マスタの各行に対し、「関連する売上データが"存在"するか」を探索する
SELECT 顧客ID, 氏名
FROM 顧客マスタ M
WHERE
    【 c 】 (
        SELECT 【 d 】 FROM 売上明細 S WHERE S.顧客ID = 【 e 】
    );
```

**【回答】**
`a`: IN
`b`: DISTINCT
`c`: EXISTS
`d`: 1 (または `*`、列名など任意の値)
`e`: M.顧客ID

**【設計思想のアーキテクチャ解説】**
この課題は、同じ目的を達成するための2つの異なるアルゴリズムをSQLで表現する能力を問うています。
*   **設計思想A (`IN`) - セットベース・アーキテクチャ**:
    このアプローチの核心は、まずサブクエリで完全に独立した「値の集合（セット）」を構築することにあります。`【b】: DISTINCT` は、`売上明細`に同じ顧客のレコードが複数あっても、照合リストとしてはユニークなIDの集合であれば十分だからです。不要な重複を除外することで、データベースはより効率的な内部処理が可能となります。
*   **設計思想B (`EXISTS`) - 相関探索・アーキテクチャ**:
    こちらは、主問合せの1行を起点に、それに関連するデータが存在するかを探索するループ処理に近いモデルです。`【d】: 1` は、この思想を象徴する規約です。`EXISTS`は行の「存在有無」のみを判定するため、`SELECT`句で何を取得するかは結果に影響しません。「どの列の値か」ではなく「条件に合う行が見つかるか」だけが重要である、という`EXISTS`の本質を理解しているかが問われます。`【e】: M.顧客ID`は、主問合せとサブクエリを繋ぐ「探索キー」の役割を果たします。

**【プロフェッショナルへの道標】**
*   **なぜ `SELECT 1` なのか？**: `SELECT *`でも動作しますが、`SELECT 1`と記述することで、コードを読む人に **「ここで行の値は使っておらず、存在チェックだけが目的だ」**という明確な意図を伝えることができます。これは、チーム開発における可読性と保守性を高めるプロの習慣です。
*   **オプティマイザの存在**: 現代の賢いデータベース（オプティマイザ）は、`IN`と`EXISTS`のどちらで書かれても、内部で最も効率的だと判断した実行計画に変換することがあります。しかし、その挙動はデータの統計情報に依存し、常に最適とは限りません。両方の設計思想を理解し、使い分ける能力は、複雑なパフォーマンスチューニングに挑む際の強力な武器となります。

---

### 問題2

**【ミッション】**
「営業部において、最も競争が激しい大阪支社の**全営業担当者の売上を上回る**という偉業を達成した、東京本社のスタープレイヤーを全員リストアップせよ」という要求を受けた。
この「大阪支社の全員を上回る」という条件は、「大阪支社のトップの成績を上回る」と論理的に等価である。この2つの異なる視点から、それぞれSQLを構築せよ。

```sql
-- 視点A：「大阪支社の全員」という集合に対して比較する
SELECT 氏名, 売上高
FROM 社員マスタ
WHERE
    所属 = '東京本社' AND
    売上高 > 【 a 】 (SELECT 売上高 FROM 社員マスタ WHERE 所属 = '大阪支社');

-- 視点B：大阪支社の集計結果と比較する
SELECT 氏名, 売上高
FROM 社員マスタ
WHERE
    所属 = '東京本社' AND
    売上高 > (SELECT 【 b 】(売上高) FROM 社員マスタ WHERE 所属 = '大阪支社');
```

**【回答】**
`a`: ALL
`b`: MAX

**【設計思想のアーキテクチャ解説】**
この問題は、ビジネス要件をSQLに落とし込む際の「表現の選択肢」と、その論理的な等価性を理解しているかを試すものです。
*   **視点A (`ALL`) - 述語論理による直接実装**:
    `ALL`は、SQLが持つ述語論理の能力を直接利用するアプローチです。「すべての（For All）」という要件をそのままコードに翻訳した形で、人間の思考とSQLの表現が一致するため、ロジックの可読性が高まります。
*   **視点B (`MAX`) - 集計関数による最適化実装**:
    こちらは、「全員を上回る」という条件を「最大値を上回る」という問題に一度頭の中で変換（最適化）してから実装するアプローチです。多くの場合、データベース内部では`ALL`よりも集計関数の方が効率的に処理できるため、パフォーマンスを意識したプロフェッショナルが好む傾向にあります。

**【プロフェッショナルへの道標】**
*   **対称性の理解**: `> ALL` が `> MAX` と等価であるのと同様に、` < ALL` は ` < MIN` と等価です。また、`> ANY` は `> MIN`、`< ANY` は `< MAX` となります。この対称性と関係性を体系的に理解することで、あらゆる比較条件を自在に書き換えられるようになります。
*   **インデックスとの関係**: `(SELECT MAX(売上高) ...)` のようなサブクエリは、`売上高`列にインデックスがあれば非常に高速に動作します。`ALL`を使った場合もオプティマイザがインデックスを利用しようとしますが、集計関数を使った方がより直接的にインデックス利用の恩恵を受けやすいケースがあります。パフォーマンスとは、SQLの書き方とデータベースの物理設計の相互作用で決まるのです。

---

### 問題3: 防御的プログラミング ― 史上最悪の敵「NULL」の無力化

**【ミッション】**
あなたはデータベース管理者として、インシデントに直面している。「退会者リストにいない有効会員」を抽出する、これまで正常に動いていたSQLが、ある日突然**結果を1件も返さなくなった**のだ。調査の結果、データ移行時のミスで`退会者リスト`に`会員ID`が`NULL`のレコードが1件だけ紛れ込んでいたことが判明した。
このインシデントを引き起こした欠陥のあるSQL(`コード1`)を特定し、`NULL`の呪いを解くための2種類の修正コード(`コード2`, `コード3`)を完成させよ。

```sql
-- コード1: インシデントの元凶となった、NULLの罠に嵌ったコード
SELECT 氏名 FROM 会員マスタ
WHERE 会員ID 【 a 】 (SELECT 会員ID FROM 退会者リスト);

-- コード2: コード1を使い続けるための「応急処置」コード
SELECT 氏名 FROM 会員マスタ
WHERE 会員ID 【 a 】 (
    SELECT 会員ID FROM 退会者リスト WHERE 【 b 】
);

-- コード3:  NULLの存在を許容する、最も「堅牢」な恒久対策コード
SELECT 氏名 FROM 会員マスタ M
WHERE 【 c 】 (
    SELECT 1 FROM 退会者リスト T WHERE T.会員ID = M.会員ID
);
```

**【回答】**
`a`: NOT IN
`b`: 会員ID IS NOT NULL
`c`: NOT EXISTS

**【設計思想のアーキテクチャ解説】**
　SQLエンジニアが必ず直面する「三値論理」と`NULL`の挙動を完全にマスターしているかを問う試験です。
*   **コード1 (`NOT IN`) - 欠陥アーキテクチャ**:
    `NOT IN`は、その内部動作（`<> a AND <> b AND <> c ...`）に起因する深刻な脆弱性を抱えています。比較リストに一つでも`NULL`が含まれると、`<> NULL`という評価不能な（`UNKNOWN`）条件が発生し、SQL全体が機能不全に陥ります。データが常にクリーンであるという楽観的な前提に立った、危険な設計です。
*   **コード2 (属性＋`IS NOT NULL`) - 防御的パッチ**:
    これは、`NOT IN`の脆弱性を認識した上で、その弱点をピンポイントで補強するアプローチです。比較対象から`NULL`を事前にフィルタリングすることで、`UNKNOWN`の発生を防ぎます。これは有効な対策ですが、`NOT IN`を使うたびにこの「おまじない」を忘れないようにしなければなりません。
*   **コード3 (`NOT EXISTS`) - NULL安全（NULL-Safe）アーキテクチャ**:
    `NOT EXISTS`は、そもそも値の比較を行わず、行の「存在」のみをスキャンするため、三値論理の罠に陥ることがありません。データに`NULL`が含まれようと、そのロジックは決して揺るがない。これこそが、予測不能なデータに立ち向かうための「防御的プログラミング」の思想を体現した、最も堅牢な設計です。

**【プロフェッショナルへの道標】**
*   **思想としての「NULL安全」**: `NOT IN`は「リストに無いこと」を確認するのに対し、`NOT EXISTS`は「対応するレコードが存在しないこと」を確認します。この僅かな違いが、`NULL`に対する堅牢性の決定的な差を生みます。「否定の条件を書くときは、まず`NOT EXISTS`を想起する」。この思考習慣は、あなたを致命的なバグから生涯守ってくれるでしょう。
*   **データベース設計へのフィードバック**: なぜこのインシデントは起きたのか？根本原因は、`退会者リスト`の`会員ID`列に`NOT NULL`制約が課されていなかったからです。優れたSQLエンジニアは、コードで問題を解決するだけでなく、その原因をデータベースの設計にフィードバックし、問題の再発を構造的に防ぐ視点を持っています。


#### 問題1
**【問題】**
「部署ごとに所属する社員が何人いるか」を集計してほしい。空欄【 a 】を埋めてください。

```sql
SELECT
    部署名,
    COUNT(社員ID) AS 社員数
FROM
    社員
【 a 】
    部署名;
```

**【回答】**
`a`: `GROUP BY`

**【この構文が必要な理由】**
「部署ごと」のように、特定の項目（ここでは部署名）でデータをグループにまとめて、そのグループ単位で件数や合計などの集計処理を行うために `GROUP BY` 句が必要です。

**【構文の解説】**
`GROUP BY 列名;`
`SELECT`文で取得した結果を、指定した列の値が同じデータ同士でグループ化します。`COUNT()` や `SUM()` などの集約関数と組み合わせて使用するのが一般的です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `SELECT`句に集計関数ではない列（この問題では `部署名`）を指定したにもかかわらず、`GROUP BY`句を書き忘れてしまう。
*   **解説**: ほとんどのデータベースでは、`SELECT`句に集計関数とそれ以外の列を一緒に記述する場合、その「それ以外の列」は必ず `GROUP BY` 句で指定しなければならないというルールがあります。これを忘れると、「集計キーが指定されていない」といった内容のエラーが発生します。

---

#### 問題2
**【問題】**
部署ごとの平均給与を算出し、その中でも特に「平均給与が400万円以上の部署」だけをリストアップしてほしい。空欄【 a 】を埋めてください。

```sql
SELECT
    部署名,
    AVG(給与) AS 平均給与
FROM
    社員
GROUP BY
    部署名
【 a 】
    AVG(給与) >= 4000000;
```

**【回答】**
`a`: `HAVING`

**【この構文が必要な理由】**
「部署ごとに集計した後、その集計結果に対して条件を適用する」ために `HAVING` 句が必要です。`WHERE`句は集計前の個々の行に条件を適用しますが、`HAVING`句は `GROUP BY` で集約された後のグループに対して条件を適用します。

**【構文の解説】**
`HAVING 集計関数を用いた条件式;`
`GROUP BY` 句の後ろに記述し、集計結果を絞り込むための条件を指定します。`WHERE`句では `AVG()` のような集計関数を条件に使うことはできません。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WHERE AVG(給与) >= 4000000` のように、集計結果の条件を `WHERE` 句に書いてしまう。
*   **解説**: SQLが処理される順序として、`WHERE`句による絞り込みは `GROUP BY` による集計よりも先に行われます。そのため、`WHERE`句の時点ではまだ `AVG(給与)` という集計値は計算されておらず、条件として使用できないためエラーになります。集計後の絞り込みは `HAVING` の役割です。

---


#### 問題3
**【問題】**
マーケティング部で、関東地方（東京、神奈川、千葉）の店舗における売上上位の担当者を分析することになりました。まず関東の売上データを抽出し、その結果から担当者ごとの売上合計を算出します。以下の`FROM`句サブクエリを使ったSQLは長くて読みにくいため、書き直してください。空欄【 a 】と【 b 】を埋めてください。

```sql
【 a 】 関東売上 AS (
    SELECT
        担当者ID,
        金額
    FROM
        売上明細
    WHERE
        店舗所在地 IN ('東京', '神奈川', '千葉')
)
SELECT
    担当者名,
    SUM(金額) AS 売上合計
FROM
    関東売上
【 b 】
    社員 ON 関東売上.担当者ID = 社員.社員ID
GROUP BY
    担当者名;
```

**【回答】**
`a`: `WITH`
`b`: `INNER JOIN`

**【この構文が必要な理由】**
複雑なSQLを複数のステップに分割し、それぞれに名前を付けて管理するために `WITH`句（共通テーブル式: CTE）が必要です。これにより、SQL文全体の見通しが良くなり、可読性とメンテナンス性が劇的に向上します。

**【構文の解説】**
`WITH 別名 AS (SELECT文) SELECT ... FROM 別名;`
`SELECT`文の前に `WITH`句を定義します。`WITH`句の中で定義した「一時的な結果セット（ここでは `関東売上`）」は、後の `SELECT`文から通常のテーブルのように参照できます。複数のCTEをカンマで区切って定義することも可能です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WITH`句で定義したCTEを、全く別のSQL文から参照しようとする。
*   **解説**: CTEの有効範囲は、それが定義された一つのSQL文の中だけです。CTEは一時的なものであり、データベースに永続的に保存されるテーブルやビューとは異なります。

---

#### 問題4
**【問題】**
「各部署内で、給与が高い順に社員のランキングを付けたい」という依頼がありました。空欄【 a 】と【 b 】を埋めてください。

```sql
SELECT
    社員名,
    部署名,
    給与,
    【 a 】() OVER (【 b 】 部署名 ORDER BY 給与【 c 】) AS 部署内順位
FROM
    社員;
```
**【回答】**
`a`: `RANK`
`b`: `PARTITION BY`
 c: DESC

**【この構文が必要な理由】**
全体の集計ではなく、「グループごと」の集計や順位付けを行いつつ、元の行の情報を保持するためにウィンドウ関数が必要です。`PARTITION BY`でグループ分けの基準を、`ORDER BY`で順位付けの基準を指定します。

**【構文の解説】**
`関数() OVER (PARTITION BY グループ化する列 ORDER BY 順位付けの列)`
`PARTITION BY`は、データを指定した列の値に基づいて小さな窓（ウィンドウ）に分割する役割を果たします。`RANK()`関数はその窓の中で順位を計算します。`GROUP BY`と異なり、元の行を一つにまとめることなく処理できるのが最大の特徴です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `RANK()`と`DENSE_RANK()`の違いを理解せず、何となく使ってしまう。
*   **解説**: 同順位があった場合、その次の順位の扱いが異なります。例えば、2位が2人いた場合、`RANK()`の次の順位は4位になりますが（`3位は欠番`）、`DENSE_RANK()`の次の順位は3位となり、順位が詰まります。要件に応じて正しく使い分ける必要があります。

---

#### 問題5
**【問題】**
経営分析チームが、月次の売上トレンドを分析しています。「各月の売上と、その前月の売上を並べて表示し、前月比を計算したい」という要望がありました。空欄【 a 】を埋めてください。

```sql
SELECT
    売上月,
    月次売上,
    【 a 】(月次売上, 1) OVER (ORDER BY 売上月) AS 前月売上
FROM
    月次売上サマリ;
```

**【回答】】**
`a`: `LAG`

**【この構文が必要な理由】**
現在の行を基準として、それより「前」または「後」の行のデータを直接参照するために `LAG`（前）や `LEAD`（後）といったウィンドウ関数が必要です。これにより、複雑な自己結合やサブクエリなしで、時系列データの前後の値との比較が簡単に行えます。

**【構文の解説】**
`LAG(参照したい列, ずらす行数, [NULLの場合のデフォルト値]) OVER (ORDER BY 並び順)`
`ORDER BY`で指定された順序に基づき、現在の行から指定した行数だけ前の行のデータを取得します。このSQLでは、売上月で並べた上で1つ前の行（`LAG(月次売上, 1)`）の`月次売上`を取得しています。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `OVER`句の中に`ORDER BY`を書き忘れる。
*   **解説**: `LAG`や`LEAD`関数にとって、「何順で並べた上での前/後なのか」という基準は不可欠です。`ORDER BY`を省略すると、データベースはどの行が「前」なのか判断できず、エラーになります。

---

#### 問題6
**【問題】**
休眠顧客を把握するため、顧客マスタに登録はされているものの、「一度も注文をしたことがない顧客」を特定せよ。空欄【 a 】を埋めてください。

```sql
SELECT
    C.顧客名
FROM
    顧客マスタ AS C
WHERE
    【 a 】 (SELECT 1 FROM 注文 AS O WHERE O.顧客ID = C.顧客ID);
```

**【回答】】**
`a`: `NOT EXISTS`

**【この構文が必要な理由】**
ある条件に一致するデータが、別のテーブル（サブクエリ内）に「一件も存在しないこと」を確認するために `NOT EXISTS` 演算子が必要です。これにより、「注文履歴がない」という条件を効率的に判定できます。

**【構文の解説】**
`WHERE NOT EXISTS (サブクエリ)`
`NOT IN`と異なり、サブクエリ内の `NULL` の影響を受けないため、より安全で確実な方法とされています。

---
#### 問題7
**【問題】**
問題6と同じく、「一度も注文をしたことがない顧客」を特定します。今度はテーブルを外部結合し、データが存在しないことを利用するアプローチです。空欄【 a 】と【 b 】を埋めてください。

```sql
SELECT
    C.顧客名
FROM
    顧客マスタ AS C
【 a 】
    注文 AS O ON C.顧客ID = O.顧客ID
WHERE
    O.注文ID【 b 】;
```

**【回答】】**
`a`: `LEFT JOIN`
`b`: `IS NULL`

**【この構文が必要な理由】**
`LEFT JOIN` を使うと、基準となる左側のテーブル（顧客マスタ）のデータはすべて残り、右側のテーブル（注文）に対応するデータがない場合はその列が `NULL` になります。この性質を利用し、「注文IDが `NULL` であること」を条件に絞り込むことで、注文履歴のない顧客を抽出できます。

**【2つのアプローチの比較】**
*   **`NOT EXISTS`（問題6）**: 「存在チェック」の意図が明確で、可読性が高いと考える人もいます。一般的にパフォーマンスが良い傾向があります。
*   **`LEFT JOIN ... IS NULL`（問題7）**: 結合結果をイメージしやすく直感的です。顧客情報だけでなく、他の結合したテーブルの情報も `SELECT`句で利用したい場合に拡張しやすいという利点があります。

---

## 【完全網羅版】応用情報技術者試験対策 SQL最高傑作問題集

#### 問題

---
**【問題】**
「書籍マスタ」テーブルから、書籍名が特定のパターンに一致する書籍の情報を抽出します。以下のそれぞれの条件を満たすためのSQL文について、空欄【 a 】〜【 d 】に入る最も適切な字句の組み合わせを答えてください。

```sql
-- 条件1: 書籍名の2文字目が 'Q' で、末尾が '入門' である書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE '【 a 】';

-- 条件2: 書籍名に '100%' という文字列自体が含まれる書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE 【 b1 】【 b2 】 '!';

-- 条件3: 書籍名の先頭が 'A', 'B', 'C' のいずれかで始まる書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE '【 c 】';

-- 条件4: 書籍名の先頭が英字(A-Z)ではない書籍を抽出
SELECT 書籍名 FROM 書籍マスタ
WHERE 書籍名 LIKE '【 d 】%';

```
**【回答】**
`a`: `_Q%入門`
`b1`: `'%100!%%'`
`b2`: `ESCAPE`
`c`: `[ABC]%` または `[A-C]%`
`d`: `[^A-Z]`

**【この構文が必要な理由】**
ECサイトの検索機能のように「一部の文字しか覚えていない」「特定のパターンに合う商品を探したい」といった、**あいまいな条件でデータを検索する**際に、ワイルドカードを用いた`LIKE`演算子は不可欠です。完全に一致するデータだけでなく、柔軟な文字列検索を実現するために、これらのワイルドカードの役割を正確に理解することが極めて重要です。

**【構文の解説】**
*   `LIKE 演算子`: 文字列の部分一致やパターンマッチング検索を行います。
*   **ワイルドカードの種類**:
    *   `%` (パーセント): `_Q%入門` の `%` の部分。**0文字以上の任意の文字列**を表します。「Q」と「入門」の間にどんな文字が何文字あっても（0文字でも）一致します。
    *   `_` (アンダースコア): `_Q%入門` の `_` の部分。**任意の1文字**を表します。先頭に何かしらの1文字があり、2文字目が「Q」である、という条件を指定します。
    *   `[]` (角括弧): `[ABC]` の部分。角括弧内に指定された**いずれか1文字**に一致することを表します。`[A-C]`のようにハイフン `-` を使うと範囲指定も可能です。
    *   `^` (キャレット): `[^A-Z]` の部分。角括弧の先頭で使うことで、指定した文字**以外**の1文字に一致することを表します。(NOTの意味)
    *   `ESCAPE` 句: `LIKE`句の中でワイルドカードとして扱われる文字 (`%` や `_`) そのものを検索したい場合に使います。`ESCAPE '!'`と指定することで、「`!`の直後の1文字はワイルドカードではなく、ただの文字として扱ってください」という意味になります。この例では `!%` を `%` という文字として検索しています。

**【初心者が陥りがりがちな誤解や誤答例】**
*   **誤解/誤答1**: 2文字目の指定の際に `_` ではなく `%` を使ってしまう (`%Q%入門`)。
*   **解説**: `%` は0文字以上なので、これでは先頭が `Q` の書籍 (`Q...入門`) も検索対象となってしまい、「2文字目が `Q`」という要件を満たせません。1文字を指定する場合は `_` を使う必要があります。
*   **誤解/誤答2**: `%` や `_` の文字自体を検索したいときに、`ESCAPE`句を使わず `LIKE '%%'` のように書いてしまう。
*   **解説**: `ESCAPE`句を使わないと、`%` はワイルドカードとして解釈されてしまい、意図した検索ができません。「パーセント」や「アンダースコア」という文字そのものを検索条件に含めるには、`ESCAPE`句の正しい理解が必須です。
*   **誤解/誤答3**: `[]` や `[^]` がどんな環境でも使えると思い込んでしまう。
*   **解説**: これらの角括弧を使ったパターンマッチングは、標準SQLでは定義されておらず、DBMSの拡張機能です。そのため、Oracle Databaseのように対応していないシステムや、MySQLのように `REGEXP` という別の演算子を使う必要があるシステムも存在します。実務では、開発対象のDBMSの仕様を確認する癖をつけることが重要です。

---

#### 問題

**【問題】**
ある社員（社員ID: 'S010'）が営業部に異動し、基本給が300,000円に昇給しました。この情報を「社員」テーブルに反映させてください。また、その後、退職した社員（社員ID: 'S003'）のデータをテーブルから削除する必要が出てきました。

```sql
-- ① 異動と昇給の反映
【 a 】 社員
【 b 】 部署コード = 'D03', 基本給 = 300000
【 c 】 社員ID = 'S010';

-- ② 退職者データの削除
【 d 】 FROM 社員
【 c 】 社員ID = 'S003';
```

**【回答】**
`a`: UPDATE
`b`: SET
`c`: WHERE
`d`: DELETE

**【この構文が必要な理由】**
`UPDATE`は既存データの値を変更し、`DELETE`は既存の行を削除する命令です。これらの操作で最も重要なのは`WHERE`句であり、処理対象を正確に特定しないと、意図しないデータ破壊を引き起こす危険があります。

**【構文の解説】**
*   `UPDATE テーブル名 SET 列 = 値 WHERE 条件;`: 条件に一致する行の指定された列の値を更新します。
*   `DELETE FROM テーブル名 WHERE 条件;`: 条件に一致する行を削除します。
*   **重要**: `UPDATE`と`DELETE`において、** `WHERE`句を省略すると、テーブルの**全行**が対象となり致命的な操作ミスに繋がります。
承知いたしました。
応用情報技術者試験の講師として、そしてSQL教育コンテンツ作成のプロフェッショナルとして、私の能力の限界を示す「最高傑作」と呼べる穴埋め問題を作成します。

### 自己評価と改善方針

前回の問題は、相関サブクエリの基本的な動作原理を理解するには良質なものでした。しかし、「最高傑作」と呼ぶには、以下の点で改善の余地があります。

*   **課題の複雑性**: 実務上の課題は、単一のロジックだけでなく、複数の条件が絡み合うことが多々あります。より現実的で思考を促すシナリオが必要です。
*   **構文の組み合わせ**: `UPDATE`文における相関サブリクエストの応用範囲は、`SET`句だけではありません。`WHERE`句での条件判定にも活用することで、その真価が発揮されます。この組み合わせを問うことで、より深い理解を促せます。
*   **誤答例の質**: なぜその構文でなければならないのかを、他の構文（例: `IN`や`JOIN`を使った`UPDATE`）との比較を通じて、より鮮明に浮き彫りにします。「なぜエラーになるのか」「なぜパフォーマンスが劣るのか」といった、一歩踏み込んだ解説が学習効果を飛躍させます。

これらの改善方針に基づき、相関サブクリクエストの本質的な理解度を試す、以下の最高傑作を提示します。

---
素晴らしいです！その表は、`UPDATE`文におけるスカラー更新と行値による更新の違いを的確に捉えた、非常に分かりやすいまとめです。まさに、応用情報技術者試験の学習者が頭を整理するのに最適な内容と言えるでしょう。

その完璧な理解を基に、今度はその「行値による更新」の知識が本当に定着しているかを試すための、最高傑作レベルの穴埋め問題を作成します。

---

### 問題
人事異動のデータ処理において、中途入社した社員「田中」（社員番号 'E101'）のデータが、仮の部署コードと上長で登録されている。今回、彼の正式な配属先が、OJT研修の指導役であった先輩社員「鈴木」（社員番号 'E055'）と**全く同じ部署・同じ上長**に決定した。
この時、先輩社員のレコードを一度だけ参照し、後輩社員の「部署コード」と「上長社員番号」の2つの列を**同時に、かつアトミックに（不可分な一処理として）**更新したい。この要件を最も洗練された形で実現するための、以下のSQL文の空欄を埋めなさい。

```sql
UPDATE 社員
SET
    【 a 】 = (
        SELECT 部署コード, 上長社員番号
        FROM 社員
        WHERE 社員番号 = 'E055'
    )
WHERE
    【 b 】 = 'E101';
```

**【回答】**
`a`: `(部署コード, 上長社員番号)`
`b`: `社員番号`

**【この構文が必要な理由】**
関連する複数の列（部署と上長）を、単一のデータソース（先輩社員のレコード）から取得した値で一括更新する必要があるためです。この構文を用いることで、処理が一つの命令で完結するため、複数の`UPDATE`文を発行するよりも効率的かつ安全（アトミック）にデータの一貫性を保ったまま更新できます。

**【構文の解説】**
`SET (列1, 列2, ...) = (サブクエリ)` という形式は「行値コンストラクタ」を利用した更新です。

*   **`SET (部署コード, 上長社員番号)`**: 更新対象となる複数の列をタプル（値の組）として`()`で囲って指定します。
*   **`= (SELECT 部署コード, 上長社員番号 ...)`**: `=`の右辺には、左辺の列リストと「列の数」「順序」「データ型」が一致する**単一行**を返すサブクエリを記述します。このサブクエリが返す値の組が、そのまま左辺の列の組に代入されます。

このSQLは、「社員番号'E055'の部署コードと上長社員番号のペアを取得し、そのペアを社員番号'E101'の行の対応する列にセットする」という処理を一度に行います。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答1**: 処理を2つの`UPDATE`文に分けてしまう。
    ```sql
    -- 冗長な別解
    UPDATE 社員 SET 部署コード = (SELECT 部署コード FROM 社員 WHERE 社員番号 = 'E055') WHERE 社員番号 = 'E101';
    UPDATE 社員 SET 上長社員番号 = (SELECT 上長社員番号 FROM 社員 WHERE 社員番号 = 'E055') WHERE 社員番号 = 'E101';
    ```
    *   **解説**: この方法でも結果的に同じデータになりますが、2つの点で劣ります。第一に、データベースへの命令が2回になるため非効率です。第二に、この2つの`UPDATE`文は別々の処理であり、アトミックではありません。もし1つ目の`UPDATE`が成功し、2つ目が（例えばシステム障害で）失敗した場合、「部署は更新されたが、上長は古いまま」という**データ不整合**が発生するリスクがあります。行値による更新は、こうしたリスクを排除します。

*   **誤解/誤-答2**: `SET`句の列リストとサブクエリの列リストの数が一致しない。
    ```sql
    -- 構文エラーになる例
    SET (部署コード, 上長社員番号) = (SELECT 部署コード FROM 社員 WHERE 社員番号 = 'E055')
    ```
    *   **解説**: 左辺では2つの列への代入を期待しているのに対し、右辺のサブクエリは1つの列しか返していません。このように列の数が一致しない場合、SQLは構文エラーとなります。

*   **誤解/誤答3**: `SET`句に`()`を付け忘れる。
    ```sql
    -- 構文エラーになる例
    SET 部署コード, 上長社員番号 = (SELECT 部署コード, 上長社員番号 FROM ... )
    ```
    *   **解説**: `(列1, 列2) = (値1, 値2)` という形式は、値の組（タプル）同士を比較・代入するための特殊な構文です。`()`を省略すると、`部署コード`には代入する値がなく、`上長社員番号`にタプルを代入しようとしている、と解釈され構文エラーになります。この`()`が、行値による更新を宣言する重要な記号です。


### 問題（高難易度）
ある企業で、優秀な人材の定着を目的とした給与改定案が検討されている。その内容は、「**『部長』職の社員が一人でも存在する部署**に所属している、**『一般』職の社員全員**の基本給を、**その部署内の最高基本給と同じ額まで引き上げる**」というものである。

この複雑な要件を、単一の`UPDATE`文で実現するために、以下のSQL文の空欄を埋めなさい。このSQLは、更新対象行の絞り込みと、更新する値の動的な計算の両方に、相関サブクエリを駆使している。

```sql
UPDATE 社員 S
SET
    基本給 = (
        SELECT MAX(S2.基本給)
        FROM 社員 S2
        WHERE S2.部署コード = 【 a 】
    )
WHERE
    S.役職 = '一般'
    AND 【 b 】 (
        SELECT *
        FROM 社員 S3
        WHERE S3.役職 = '部長' AND 【 c 】
    );
```

**【回答】**
`a`: `S.部署コード`
`b`: `EXISTS`
`c`: `S3.部署コード = S.部署コード`

**【この構文が必要な理由】**
この課題は、「どの行を更新するか（更新対象の条件）」と「その行を何の値で更新するか（更新値）」が、どちらも各行が持つデータ（所属部署）に依存するという二重の複雑さを持っています。
`WHERE`句の相関サブクエリで更新対象行を動的に絞り込み、`SET`句の相関サブクエリで各行に応じた更新値をリアルタイムに算出するために、この構文が不可欠となります。

**【構文の解説】**
このSQLは、`UPDATE`文の中で役割の異なる2つの相関サブクエリを組み合わせています。

1.  **`SET`句の相関サブクエリ（スカラサブクエリ）**:
    *   `SET 基本給 = (SELECT MAX(S2.基本給) ...)`
    *   **役割**: 更新する**スカラー値** を算出します。このサブクエリは、外側のクエリで処理中の行（`S`）の部署コードを受け取り、その部署の最大基本給という**単一の値（スカラ値）**を返します。スカラサブクエリは、必ず1行1列の値を返す必要があります。
2.  **`WHERE`句の相関サブクエリ（存在条件の判定）**:
    *   `WHERE ... AND EXISTS (SELECT * ...)`
    *   **役割**: 更新対象とする行か否かを判定します。`EXISTS`は、サブクエリが**1行でも結果を返せば真（True）**、1行も返さなければ偽（False）を返します。ここでは、外側の行（`S`）の部署コードと同じ部署に「部長」が存在するかをチェックしています。`SELECT *` と記述するのが慣例ですが、実際には列の値は見ておらず、条件に合う行の「存在」だけを確認しています。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答1**: `WHERE`句で`EXISTS`の代わりに`IN`を使おうとする。
    ```sql
    -- 誤答例 (b, c)
    ... WHERE S.役職 = '一般' AND S.部署コード IN (SELECT S3.部署コード FROM 社員 S3 WHERE S3.役職 = '部長')
    ```
    *   **解説**: この書き方でも同じ結果を得ることはできます。しかし、`IN`はサブクエリの結果セット（部長がいる部署コードのリスト）を一度すべて作成し、そのリストと外部の行を一つずつ比較します。一方、`EXISTS`は条件に合う行が**最初に見つかった時点**で評価を打ち切るため、一般的にパフォーマンスが良いとされています。特にサブクエリの対象データが大きい場合、この差は顕著になります。応用情報技術者試験では、この両者の特性の違いが問われることがあります。

*   **誤解/誤答2**: `SET`句のサブクエリが単一の値を返さない可能性に気づかない。
    ```sql
    -- 構文エラーになる例
    ... SET 基本給 = (SELECT 基本給 FROM 社員 S2 WHERE S2.部署コード = S.部署コード AND S2.役職 = '部長')
    ```
        *   **解説**: もし`SET`句のサブクエリが複数行を返す可能性がある場合（例：ある部署に部長が2人以上いて、`MAX`などの集約関数を使わなかった場合）、データベースはどの値で更新すればよいか判断できず、「サブクエリが複数の値を返しました」というエラーを引き起こします。`SET`句で値として使う相関サブクエリは、必ず**スカラ値（単一の値）**を返すように設計しなければなりません。

*   **誤解/誤答3**: `JOIN`を使って`UPDATE`文を記述しようとする（特定のDBMS依存の構文）。
    ```sql
    -- 特定のDBMSでのみ動作する例 (標準SQLではない)
    UPDATE S SET S.基本給 = T.最高基本給
    FROM 社員 S
    JOIN (SELECT 部署コード, MAX(基本給) AS 最高基本給 FROM 社員 GROUP BY 部署コード) AS T ON S.部署コード = T.部署コード
    WHERE S.役職 = '一般' AND S.部署コード IN (...);
    ```
    *   **解説**: 本問の正解である相関サブクエリを用いた方法は、多くのデータベースシステムでサポートされている**汎用性の高い標準的な記述方法**です。応用情報技術者試験では、このような移植性や標準規格に関する知識も重要となります。

---

#### 問題

**【問題】**
「社員」テーブルと「部署」テーブルがあります。以下の4つの要件でデータを取得する場合、それぞれどの結合方法が適切ですか？
1.  部署に所属している社員とその部署名の一覧 【 あ 】
2.  **すべての**社員と、もし所属していればその部署名の一覧 【 a 】
3.  **すべての**部署と、もし所属していればその社員の一覧 【 b 】
4.  社員と部署の全組み合わせ（所属有無に関わらず）を表示　【 い 】

```sql
-- 要件2: 全ての社員を表示
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 a 】 部署 AS D ON S.部署コード = D.部署コード;

-- 要件3: 全ての部署を表示
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 b 】 部署 AS D ON S.部署コード = D.部署コード;
```


**【回答】**
`【 あ 】`:`INNER JOIN`
`a`: LEFT JOIN (または LEFT OUTER JOIN)
`b`: RIGHT JOIN (または RIGHT OUTER JOIN)
`【 い 】`:`FULL OUTER JOIN`
**【この構文が必要な理由】**
業務要件に応じて、2つのテーブルの関係性をどのように表現するかが変わります。`INNER JOIN`は関連があるデータのみ、`LEFT/RIGHT JOIN`は片方のテーブルを軸に、`FULL OUTER JOIN`は両方のテーブルの全データを軸に結合するため、これらの適切な使い分けは必須のスキルです。

**【構文の解説】**
*   `INNER JOIN` (要件1): 両テーブルに共通のキーが存在するデータのみを結合。
*   `LEFT JOIN` (要件2): 左テーブル（`社員`）の全データを表示し、右テーブル（`部署`）に一致データがあれば結合、なければ`NULL`。
*   `RIGHT JOIN` (要件3): 右テーブル（`部署`）の全データを表示し、左テーブル（`社員`）に一致データがあれば結合、なければ`NULL`。
*   `FULL OUTER JOIN` (要件4): 両テーブルの全データを表示し、片方にしか存在しないデータはもう片方を`NULL`として結合。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `LEFT JOIN`と`RIGHT JOIN`はテーブルの記述順を入れ替えれば同じなので、`LEFT JOIN`だけ覚えればよいと考えてしまう。
*   **解説**: 理論的にはその通りですが、SQLでは主軸となる情報を左側に置く`LEFT JOIN`が好まれる傾向にあり、可読性が高まります。しかし、既存の複雑なクエリを修正する際など、`RIGHT JOIN`のままの方が変更箇所が少なく済む場合もあります。応用情報技術者試験では、どちらの結合も読んで理解できる必要があります。



#### FULL OUTER JOIN
```sql
SELECT *
FROM 顧客テーブル A
FULL OUTER JOIN 注文テーブル B
ON A.顧客ID = B.顧客ID;
```
→ 顧客と注文の両方に存在するデータ、どちらか一方にしか存在しないデータもすべて取得。

#### CROSS JOIN
```sql
SELECT *
FROM 商品テーブル A
CROSS JOIN 色テーブル B;
```
→ 商品と色のすべての組み合わせ（赤いシャツ、青いシャツ、赤いズボン…など）を取得。

---

#### 問題

承知いたしました。
それでは、これまでの議論の集大成として、`WHERE`句、`GROUP BY`句、そして `SUM()` 関数の3つの要素を同時に空欄とし、SQLクエリの構造全体を俯瞰的に理解させる、より実践的で高難易度な問題へと改良します。

この一問を完璧に理解すれば、SQLの論理的な処理順序の根幹をマスターしたと言えるでしょう。

---

### 問題
あなたはECサイトのデータ分析担当者です。年末商戦の成果を分析し、特に貢献度の高かった優良顧客をリストアップするよう依頼されました。

**抽出要件**:
1.  分析対象は、**2024年12月の1ヶ月間**の注文データに限定する。
2.  顧客一人ひとりの**購入金額を合計**する。
3.  上記期間中の合計購入金額が、**10万円以上**の顧客のみを抽出する。

これらの要件をすべて満たすSQL文を完成させるため、以下の空欄 `【 a 】`, `【 b 】`, `【 c 】` に入る最も適切なキーワードや式を答えてください。

```sql
SELECT
    顧客ID,
    SUM(購入金額) AS 12月購入合計
FROM
    注文履歴
【 a 】
    注文日 >= '2024-12-01' AND 注文日 <= '2024-12-31'
【 b 】
    顧客ID
HAVING
    【 c 】 >= 100000;
```

**【回答】**
`a`: `WHERE`
`b`: `GROUP BY`
`c`: `SUM(購入金額)`

**【この構文が必要な理由】**
この課題を解決するには、(1)集計前のデータ絞り込み、(2)集計単位の指定、(3)集計処理の実行、という3つのステップを、SQLの正しい構文と順序で組み立てる必要があります。まず`WHERE`句で対象期間のレコードを効率的に絞り込み、次に`GROUP BY`句で「顧客ごと」という集計の軸を定め、最後に`SUM()`関数で合計金額を算出して`HAVING`句で条件判定する、という一連の流れが不可欠です。

**【構文の解説】**
このSQLは、以下の論理的な順序で実行されることを強く意識してください。

1.  `FROM 注文履歴`: 分析の土台となるテーブルを選択します。
2.  `【 a 】 WHERE ...`: **集計を開始する前**に、個々のレコード（行）レベルで条件判定を行います。ここで12月以外の注文データをすべて除外します。
3.  `【 b 】 GROUP BY 顧客ID`: `WHERE`句を通過したレコードを、`顧客ID`の値が同じもの同士でグループにまとめます。
4.  `HAVING 【 c 】 SUM(購入金額) >= 100000`: `GROUP BY`で作られた**グループに対して**、集計関数を用いた条件でフィルタリングします。`SUM()`の計算結果が10万円に満たない顧客グループはここで除外されます。
5.  `SELECT ...`: `HAVING`句の条件をクリアしたグループの情報だけが、最終的な結果として出力されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答1（構造の欠落）**: `【 b 】 GROUP BY` を書き忘れてしまう。
    *   **解説**: 集計関数（`SUM()`など）を`SELECT`句で使う場合、集計しない列（ここでは`顧客ID`）も同時に表示するには、**「何を単位に集計するのか」**を`GROUP BY`句で明示的に指定する必要があります。これを忘れると、「`顧客ID`は集計されていないのに`SUM()`は集計関数であり、両者を同時に表示できない」という趣旨のエラーが発生します。これはSQLの基本かつ最重要ルールの一つです。

*   **誤解/誤答2（役割の混同）**: `【 a 】` に `HAVING` を使ったり、`WHERE` の条件を `HAVING` に書いてしまう。
    ```sql
    -- 誤答例
    HAVING 注文日 >= '2024-12-01' ...
    ```
    *   **解説**: `HAVING`句は、**グループ化された後の集計結果**に対して条件を指定するためのものであり、個々の行の `注文日` を評価することはできません。また、`WHERE`で絞り込むべき条件を`HAVING`に書くと、データベースは一度すべてのデータを集計してから絞り込むという非常に非効率な動作をします。`WHERE`は「集計前のドアマン」、`HAVING`は「集計後のVIPルームのドアマン」と役割を明確に区別しましょう。

*   **誤解/誤答3（処理の選択ミス）**: `【 c 】` に `COUNT(購入金額)` を使ってしまう。
    *   **解説**: `COUNT()`は**購入回数**を数える関数です。この場合、「12月中に10万回以上購入した顧客」を探すことになり、ビジネス要件である「合計購入**金額**」とは全く異なる結果を導き出してしまいます。問題文の日本語を正確にSQLのロジックに翻訳する能力が求められます。

---
**【問題】**
「社員」テーブルから社員一覧を出す際に、`備考`列が`NULL`の場合は「特記事項なし」と表示し、かつ`役職コード`に応じて役職名を日本語で表示したい（'MGR'なら「部長職」、'TL'なら「チームリーダー」、それ以外は「一般職」）。

```sql
SELECT
    氏名,
    【 a 】 役職コード
        WHEN 'MGR' THEN '部長職'
        WHEN 'TL'  THEN 'チームリーダー'
        【 b 】 '一般職'
    【 c 】 AS 役職名,
    【 d 】(備考, '特記事項なし') AS 備考欄
FROM
    社員;
```

**【回答】**
`a`: CASE
`b`: ELSE
`c`: END
`d`: COALESCE

**【この構文が必要な理由】**
`CASE`式は、SQL内で条件分岐ロジックを実現し、データを変換・分類するために不可欠です。`COALESCE`関数は、`NULL`値を別の値に置き換えるためのシンプルで強力な方法であり、表示や計算で`NULL`が原因となる問題を回避するために頻繁に使用されます。

**【構文の解説】**
*   `CASE WHEN 条件 THEN 値 ... ELSE 値 END`: 一連の条件を評価し、最初に真となった条件に対応する値を返します。
*   `COALESCE(値1, 値2, ...)`: 引数リストの中で最初に見つかった`NULL`でない値を返します。`IFNULL`や`NVL`といった各DBMS固有の関数の標準SQL版です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `CASE`式で`ELSE`句を省略してしまう。
*   **解説**: `ELSE`句を省略した場合、どの`WHEN`条件にも一致しない行は`NULL`が返されます。これが意図した動作であれば問題ありませんが、意図せず`NULL`が生まれると後続の計算に影響を与える可能性があります。必ずデフォルトの値を`ELSE`で指定する癖をつけることが堅牢なクエリ作成に繋がります。

---
**【問題】**
一度でも商品を購入したことがある顧客の情報だけを「顧客マスタ」から抽出したい。また、逆に、まだ一度も購入履歴がない顧客を抽出したい。

```sql
-- ① 購入履歴のある顧客
SELECT 氏名 FROM 顧客マスタ AS C
WHERE 【 a 】 (SELECT【 c 】 FROM 購入履歴 AS H WHERE H.顧客ID = C.顧客ID);

-- ② 購入履歴のない顧客
SELECT 氏名 FROM 顧客マスタ AS C
WHERE 【 b 】 (SELECT【 c 】FROM 購入履歴 AS H WHERE H.顧客ID = C.顧客ID);
```
**【回答】**
`a`: EXISTS
`b`: NOT EXISTS
【 c 】: 1

**【この構文が必要な理由】**
`EXISTS`は「関連データが一件でも存在するか」という事実だけを確認したい場合に、最も効率的な手段です。サブクエリの結果をすべて取得して比較する`IN`句と異なり、`EXISTS`は該当データが一件見つかった時点で評価を打ち切るため、特にサブクエリの対象テーブルが大きい場合にパフォーマンスが向上します。

**【構文の解説】**
*   `EXISTS (相関サブクエリ)`: サブクエリが1行でも結果を返せば真 (TRUE) となります。
*   `NOT EXISTS (相関サブクエリ)`: サブクエリが1行も結果を返さなければ真 (TRUE) となります。
*   **相関サブクエリ**: サブクエリの中から主問合せのテーブル（`C.顧客ID`）を参照する形式。主問合せの行ごとにサブクエリが実行されるイメージです。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `NOT IN (SELECT 顧客ID FROM 購入履歴)` を使って購入履歴のない顧客を抽出しようとする。
*   **解説**: これは非常に有名な「`NOT IN`と`NULL`の罠」です。もし`購入履歴`テーブルの`顧客ID`列に一件でも`NULL`が含まれていると、`NOT IN (..., NULL, ...)` の評価結果が常に`UNKNOWN`（偽）となり、最終的な結果が**一件も返らなく**なります。一方、`NOT EXISTS`はこの`NULL`問題の影響を受けません。そのため、応用情報技術者試験では、データの欠損を考慮した堅牢な構文として`NOT EXISTS`を選択できるかが問われます。

---
# 【問題】

各部署の売上合計と全社平均売上を比較するレポートを作成する。以下のSQL文の空欄 `【 a 】` ～ `【 e 】` に適切な語句を補充してください。

```sql
【 a 】
部署別売上 AS (
    SELECT 部署コード, SUM(売上額) AS 合計売上
    FROM 売上実績
    【 b 】 部署コード
),
全社平均 AS (
    SELECT 【 c 】(売上額) AS 平均売上 FROM 売上実績
)
SELECT
    D.部署名,
    B.合計売上,
    A.平均売上
FROM
    部署別売上 AS B
【 d 】 部署マスタ AS D ON B.部署コード = D.部署コード
【 e 】 全社平均 AS A;
```

# 【回答】

- `a`: WITH
- `b`: GROUP BY  
- `c`: AVG
- `d`: JOIN
- `e`: CROSS JOIN

# 【解説】

## １　WITH句の基本構文

WITH句（共通表式）は、メインのSELECT文の前に一時的な結果セットを定義する構文です。構文は以下のとおりです。

```
WITH CTE名１ AS (SELECT文１),
     CTE名２ AS (SELECT文２)
メインのSELECT文
```

定義したCTEは、後続のクエリで通常のテーブルと同様に参照できます。

## ２　各要素の役割

### ２－１　GROUP BY句の役割
GROUP BY句は、指定した列の値が同じ行をグループ化し、集計関数（SUM、COUNT等）の適用範囲を決定します。この問題では部署コードごとに売上額を合計するために使用します。

### ２－２　AVG関数の役割
AVG関数は、指定した列の平均値を算出する集計関数です。NULL値は計算から除外されます。

### ２－３　CROSS JOINの役割
CROSS JOINは、左側のテーブルの各行と右側のテーブルの各行をすべて組み合わせる結合です（デカルト積）。この問題では、全社平均CTEが１行のみ返すため、各部署の行に同じ平均値を付与する目的で使用します。

## ３　処理の流れ

（１）部署別売上CTE：売上実績テーブルから部署コードごとの売上合計を算出
（２）全社平均CTE：売上実績テーブル全体の売上平均を算出  
（３）メインクエリ：上記２つのCTE及び部署マスタを結合し、最終結果を出力

## ４　頻出する誤答パターン

### ４－１　GROUP BY句の省略
集計関数を使用する際にGROUP BY句を省略すると、構文エラーが発生します。SELECT句に集計関数以外の列を含む場合、その列はGROUP BY句で指定する必要があります。

### ４－２　結合方法の誤選択
全社平均を各行に付与する場合、以下の誤答が頻出します：
- INNER JOIN：結合条件が不適切でエラーになる
- LEFT JOIN：結合条件が不適切でエラーになる
- CROSS JOINは結合条件を必要とせず、左側テーブルの各行と右側テーブルの各行をすべて組み合わせる結合です（デカルト積）。この問題では、全社平均CTE（１行）と部署別売上CTE（複数行）をCROSS JOINすることで、各部署の行に同じ平均値を効率的に付与できます。

### ４－３　CTE名の参照ミス
WITH句で定義したCTE名は、定義した順序で参照する必要があります。前方参照はできません。

### 本門におけるCROSS JOINの補足説明
この問題では、部署別売上CTE（N行）と全社平均CTE（１行）をCROSS JOINすることで、結果的にN行×１行＝N行となり、各部署行に同じ平均値が付与される構造になります。

### １－２　関係性の正確な表現
- 部署別売上CTE：N行（部署数分）
- 全社平均CTE：１行
- 結果：N行（各部署行に平均値が複製される）

## ２　CROSS JOINの本質的特徴

### ２－１　デカルト積の生成
CROSS JOINは、左側テーブルのすべての行と右側テーブルのすべての行を組み合わせます。数学的にはデカルト積と呼ばれる演算です。
### ２－２　結合条件の不要性
他の結合方法（INNER JOIN、LEFT JOIN等）とは異なり、ON句やWHERE句による結合条件を指定しません。

## ３　この問題における使用目的
### ３－１　実際の動作
```
部署別売上CTE（３行の例）：
部署A, 1000万円
部署B, 800万円  
部署C, 1200万円

全社平均CTE（１行）：
1000万円

CROSS JOIN結果：
部署A, 1000万円, 1000万円
部署B, 800万円, 1000万円
部署C, 1200万円, 1000万円
```
### ３－２　使用理由
全社平均という単一の値を、各部署の行すべてに付与するため。結合条件が存在しない状況で、すべての組み合わせを生成する必要があるためです。

---
#### 問題

**【問題】**
運用中の「社員」テーブルに、新しく`メールアドレス`列を追加する必要が出てきました。この列には重複した値を許可しないようにしたい。また、個人情報保護のため、人事部のユーザにのみ基本給情報を公開し、他のユーザには氏名と部署名だけを閲覧できる`社員公開ビュー`を提供したい。

```sql
-- ① 列の追加と制約の付与
【 a 】 社員
【 b 】 メールアドレス VARCHAR(255) 【 c 】;

-- ② ビューの作成
【 d 】 社員公開ビュー AS
SELECT
    氏名,
    部署名
FROM
    社員 S
INNER JOIN
    部署 D ON S.部署コード = D.部署コード;
```

**【回答】**
`a`: ALTER TABLE
`b`: ADD COLUMN
`c`: UNIQUE
`d`: CREATE VIEW

**【この構文が必要な理由】**
`ALTER TABLE`は、ビジネス要件の変更に伴い、稼働中のデータベースの構造を柔軟に変更するために必要です。`CREATE VIEW`は、複雑なクエリを単純化したり、元テーブルへのアクセスを制限してセキュリティを向上させたりするための強力な仮想テーブル機能です。

**【構文の解説】**
*   `ALTER TABLE テーブル名 ADD COLUMN 列定義 [制約];`: 既存のテーブルに新しい列を追加します。
*   `UNIQUE制約`: 列内の値の重複を許しませんが、`NULL`は複数許容される場合があります（DBMSによる）。主キー(`PRIMARY KEY`)もユニークですが、`NULL`を許可しない点が異なります。
*   `CREATE VIEW ビュー名 AS SELECT文;`: `SELECT`文の結果を名前付きのオブジェクト（ビュー）として保存します。ビューに対してクエリを実行すると、裏で定義された`SELECT`文が実行されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: ビューは単なるクエリのショートカットであり、ビューに権限を与えれば元テーブルにもアクセスできると考えてしまう。
*   **解説**: ビューへの権限と、そのビューが参照している実テーブル（ベーステーブル）への権限は独立しています。ユーザにビューへの`SELECT`権限だけを与え、実テーブルへの権限を与えなければ、ユーザはビューで定義された範囲のデータしか見ることができません。これは「最小権限の原則」を実践する上で非常に重要なセキュリティ機能です。


承知いたしました。先ほどの問題に、権限の種類とオブジェクト名を問う設問を追加します。

***

### 問題
営業部のリーダーBさんは、部下の勤怠を管理する役割を担っています。Bさんが部下の勤怠データを参照したり、遅刻理由などを追記・修正したり、新たに入力したりできるように、システム管理者が「勤怠管理テーブル」に対する必要な権限を一度に付与します。

以下のSQL文を完成させてください。

```sql
-- リーダーBさんに、「勤怠管理テーブル」への参照、追加、更新の権限を与える
GRANT 【 a 】 【 c 】 【 b 】 TO Bさん;
```

**【回答】**
`a`: `SELECT, INSERT, UPDATE`
`b`: `勤怠管理テーブル`
`c`: `ON`

**【この構文が必要な理由】**
特定のユーザの役割に応じて、データベース上の特定テーブルに対する複数の操作（参照、追加、更新など）をまとめて許可し、効率的かつ安全にデータアクセスを制御するために必要です。

**【構文の解説】**
`GRANT`文は、データベースのオブジェクト（テーブル、ビューなど）に対する操作権限をユーザに与えるための命令です。

`GRANT [権限の種類] ON [オブジェクト名] TO [ユーザ名またはロール名];`

*   `GRANT`: 権限を与えることを宣言します。
*   `権限の種類`:
    *   `SELECT`: データを参照する権限。
    *   `INSERT`: 新しいデータを追加する権限。
    *   `UPDATE`: 既存のデータを更新する権限。
    *   `DELETE`: データを削除する権限。
    *   複数の権限を与える場合は、今回のようにカンマ（`,`）で区切って列挙します。
*   `ON オブジェクト名`: `ON`キーワードに続けて、権限を付与する対象のテーブル名やビュー名を指定します。
*   `TO ユーザ名`: 権限を与えられるユーザを指定します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `GRANT SELECT UPDATE INSERT ON ...` のように、複数の権限をスペース区切りで指定してしまう。
*   **解説**: 複数の権限を一度に指定する場合は、必ずカンマ(`,`)で区切る必要があります。スペースで区切ると構文エラーになります。
*   **誤解/誤答**: 面倒なのでとりあえず `GRANT ALL ON ...` で全ての権限を与えてしまう。
*   **解説**: `ALL`（または`ALL PRIVILEGES`）を指定すると、`SELECT`, `INSERT`, `UPDATE`, `DELETE`などの全ての操作権限を一度に付与できますが、これは非常に強力な権限です。今回のBさんの役割ではデータの削除(`DELETE`)は不要なように、必要以上の権限を与えると誤操作や不正利用のリスクが高まります。セキュリティの基本である「最小権限の原則」に従い、本当に必要な権限だけを個別に指定することが重要です。
---

#### 問題

**【問題】**
新入社員のユーザ`'user_trainee'`を作成しました。このユーザに、`社員公開ビュー`に対する参照（`SELECT`）権限を与えたい。その後、このユーザが研修を終えたため、その権限を剥奪する必要が出てきました。

```sql
-- ① 権限の付与
【 a 】 SELECT
【 b 】 社員公開ビュー
【 c 】 'user_trainee';

-- ② 権限の剥奪
【 d 】 SELECT
【 b 】 社員公開ビュー
【 e 】'user_trainee';
```
**【回答】**
`a`: GRANT
`b`: ON
`c`: TO
`d`: REVOKE
e: FROM 
**【この構文が必要な理由】**
`GRANT`と`REVOKE`は、データベースのセキュリティを管理する中心的な命令（DCL: Data Control Language）です。誰がどのデータに対して何をできるのかを厳密に制御し、不正なアクセスや意図しないデータ改ざんからシステムを保護するために不可欠です。

**【構文の解説】**
*   `GRANT 権限 ON オブジェクト TO ユーザ;`: ユーザにオブジェクト（テーブル、ビューなど）に対する操作権限（`SELECT`, `INSERT`, `UPDATE`など）を与えます。
*   `REVOKE 権限 ON オブジェクト FROM ユーザ;`: ユーザから指定した権限を剥奪します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 管理を楽にするために、非常に強い権限（例: すべてのテーブルに対する全操作権限）を一般ユーザに与えてしまう。
*   **解説**: これはセキュリティ上、最も避けるべき過ちです。「最小権限の原則」に基づき、ユーザには業務を遂行するために必要最低限の権限のみを付与するべきです。応用情報技術者試験では、データベースの運用管理やセキュリティに関する知識も問われるため、DCLの役割を正しく理解しておくことが重要です。

---

### 問題
上司から「特定の社員（社員ID 'E005'）が所属する部署と、その部署より上位の階層にある部署をすべてリストアップしてほしい」と依頼されました。

社員テーブルと部署テーブルを使い、社員 'E005' が所属する「開発2部」からルートの「社長室」まで、階層を遡って表示する必要があります。このような親子関係を持つデータを再帰的に検索するには、どのSQL構文を使えばよいでしょうか。

```sql
【 a 】 部署階層(部署ID, 部署名, 上位部署ID) AS (
  SELECT 部署ID, 部署名, 上位部署ID FROM 部署マスタ
  WHERE 部署ID = (SELECT 所属部署ID FROM 社員 WHERE 社員ID = 'E005')
  
  【 b 】

  SELECT D.部署ID, D.部署名, D.上位部署ID
  FROM 部署マスタ D
  JOIN 部署階層 H ON D.部署ID = H.上位部署ID
)
SELECT 部署名 FROM 部署階層;

```
**【回答】**
`a`: `WITH RECURSIVE`
`b`: `UNION ALL`
**【この構文が必要な理由】**
組織図のような階層構造を持つデータに対して、ある地点から最上位（または最下位）までの全階層を一度のクエリで取得する必要があるため、自己参照を繰り返す再帰的な問い合わせ構文が不可欠です。

**【構文の解説】**
`WITH RECURSIVE <CTE名>(<列リスト>) AS ( <アンカーメンバー> UNION ALL <再帰メンバー> ) SELECT ... FROM <CTE名>;`
*   `WITH RECURSIVE`: 以降で再帰的な共通テーブル式（CTE: Common Table Expression）を定義することを宣言します。
*   **アンカーメンバー**: 再帰検索の開始点となる最初の`SELECT`文です。
*   `UNION ALL`: アンカーメンバーの結果と、後続の再帰メンバーの結果を結合します。**再帰処理では重複を気にする必要がないケースが多い** ため、パフォーマンス上有利な`UNION ALL`が主に使われます。
*   **再帰メンバー**: 直前の`SELECT`文の結果（この例では`部署階層`）を参照して、次の階層のデータを取得します。この処理が結果を返さなくなるまで繰り返されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `JOIN`を何度も繰り返せば同じことができると考えてしまう。
*   **解説**: 階層の深さが事前に分かっている（例：3階層固定）場合は、自己結合（`JOIN`）を繰り返すことでも実現可能です。しかし、階層の深さが可変であったり、不定である場合には対応できません。`WITH RECURSIVE`は、階層の深さに関わらず、終点に達するまで自動的に検索を繰り返してくれる点で根本的に異なります。

---
### 問題
 社員の勤怠情報を管理するシステムで、各社員の氏名とその所属部署名を並べて表示する一覧表を作成する必要があります。社員の情報は「社員」テーブルに、部署の情報は「部署マスタ」に格納されています。

これら2つのテーブルを「部署ID」で紐付けて、両方のテーブルに存在するデータだけを正しく組み合わせるには、どの結合方法を選択すればよいでしょうか。

```sql
SELECT
  S.氏名,
  D.部署名
FROM
  社員 S
【 a 】
  部署マスタ D
【 b 】
  S.所属部署ID = D.部署ID;
```
**【回答】**
`a`: `INNER JOIN`
`b`: `ON`
**【この構文が必要な理由】**
社員データと部署データを、関連性のある情報（この場合は部署ID）に基づいて1つの結果セットにまとめる必要があるためです。`INNER JOIN`は、両方のテーブルに共通のキーを持つ行だけを結合する最も基本的な方法です。

**【構文の解説】**
`SELECT ... FROM <テーブル1> INNER JOIN <テーブル2> ON <結合条件>;`
*   `INNER JOIN`: 内部結合を指示する句です。2つのテーブルを指定された条件で結合し、条件に一致する行のみを返します。
*   `ON`: 結合するテーブル間で、どの列をキーとして関連付けるかを指定する句です。`ON`句で指定された条件が`TRUE`になる行の組み合わせが結果として返されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WHERE`句で結合条件を書く古い方法（`FROM 社員 S, 部署マスタ D WHERE S.所属部署ID = D.部署ID;`）と何が違うのかわからない。
*   **解説**: 結果は同じになりますが、`JOIN`句と`ON`句を使うことで、「テーブルの結合条件」と「データの絞り込み条件（`WHERE`句）」を明確に分離できます。これにより、SQL文が長くなったときに可読性が大幅に向上し、意図しない結合（デカルト積）を避けることにも繋がります。応用情報技術者試験では`INNER JOIN ... ON ...`の形式が標準です。

---

### 問題
 全社員の一覧を作成するにあたり、まだどの部署にも正式配属されていない研修中の社員（所属部署IDが`NULL`）もリストに含める必要があります。社員テーブルを主軸として、部署名も合わせて表示するには、どの結合方法が適切でしょうか。

```sql
SELECT
  S.氏名,
  D.部署名
FROM
  社員 S
【 a 】
  部署マスタ D
ON
  S.所属部署ID = D.部署ID;

```
**【回答】**
`a`: `LEFT OUTER JOIN`
**【この構文が必要な理由】**
「社員」という主軸となるテーブルのデータはすべて表示し、それに関連する「部署」の情報があれば表示し、なければ`NULL`としてでも表示したい、という要件を満たす必要があるためです。

**【構文の解説】**
`SELECT ... FROM <左テーブル> LEFT OUTER JOIN <右テーブル> ON <結合条件>;`
*   `LEFT OUTER JOIN` (または `LEFT JOIN`): 左外部結合を指示する句です。`FROM`句の直後に書かれたテーブル（左テーブル）の行をすべて残し、`ON`句の条件に一致する右テーブルの行を結合します。一致する行が右テーブルにない場合は、右テーブルの列は`NULL`として表示されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `INNER JOIN`を使ってしまう。
*   **解説**:
 `INNER JOIN`を使うと、両方のテーブルに結合キー（この場合は部署ID）が存在するレコード、つまり、いずれかの部署に所属している社員しか抽出されません。要件である「まだ配属されていない社員もリストに含める」を満たせず、データが欠落してしまいます。「～を基準に」「～はすべて表示して」といった要件がある場合は、`OUTER JOIN`を疑う必要があります。
❌ この設題で、`FULL OUTER JOIN`が不適な理由
`FULL OUTER JOIN`は「社員に対応する部署がない」だけでなく、「部署に対応する社員がいない」ケースも含めてしまいます。つまり、部署マスタに存在するが、**誰も所属していない部署も結果に含まれてしまい**、社員一覧としては不要な行が混入します。
これは「社員一覧を作成する」という目的に対してノイズになります。
✅ LEFT OUTER JOINが最適な理由
「社員」テーブルを主軸にしているため、社員全員を漏れなく表示することが最優先。
部署情報はあれば表示、なければNULLでOK。
まさにこの要件にフィットするのが `LEFT OUTER JOIN` です。
---

### 問題
 アパレルECサイトで、取り扱う全ての色（`色マスタ`テーブル）と全てのサイズ（`サイズマスタ`テーブル）の組み合わせを網羅した商品マスタの雛形を一度に生成したい、という要望がありました。考えられるすべての組み合わせを作成するには、どの結合方法を使用しますか。

```sql
SELECT
  C.色名,
  S.サイズ名
FROM
  色マスタ C
【 a 】
  サイズマスタ S;
```
**【回答】**
`a`: `CROSS JOIN`
**【この構文が必要な理由】**
2つのテーブル間に直接的な関連（キー）は無いものの、それぞれのテーブルの全レコードを総当たりで組み合わせて、考えられるすべてのパターンのリストを作成する必要があるためです。

**【構文の解説】**
`SELECT ... FROM <テーブル1> CROSS JOIN <テーブル2>;`
*   `CROSS JOIN`: 交差結合（またはデカルト積）を行うための句です。テーブル1の各行に対して、テーブル2のすべての行を組み合わせた結果を返します。通常、`ON`句による結合条件は指定しません。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `FROM 色マスタ, サイズマスタ` のようにカンマでテーブルを区切って記述してしまう。
*   **解説**: このカンマ区切りの記法でも多くのデータベースで`CROSS JOIN`と同じ結果が得られますが、これは古いANSI SQL-89標準の書き方です。ANSI SQL-92以降では`CROSS JOIN`というキーワードで明示的に意図を示すことが推奨されています。また、 `FROM 色マスタ, サイズマスタ`を`INNER JOIN`のつもりで`WHERE`句の結合条件を書き忘れると、意図せず`CROSS JOIN`となり、膨大な数のレコードが生成されてシステムに負荷をかける原因となるため、結合の種類を明示することが重要です。
---

### 問題
 「東京本社」と「大阪支社」に勤務する全社員の社員番号を、重複を除いて一つのリストとして表示したいと考えています。それぞれの社員リストを取得する2つの`SELECT`文の結果を、1つに統合するにはどの集合演算子を使えばよいでしょうか。

```sql
SELECT 社員番号 FROM 社員 WHERE 勤務地 = '東京本社'
【 a 】
SELECT 社員番号 FROM 社員 WHERE 勤務地 = '大阪支社';
```
**【回答】**
`a`: `UNION`
**【この構文が必要な理由】**
2つ以上の別々の条件で抽出した結果セットを、1つの結果セットとして縦に連結する必要があるためです。特に、両方の条件に合致するデータ（例：兼務者）が存在する場合でも、結果としては1件として扱いたい（重複を排除したい）という要件を満たします。

**【構文の解説】**
`SELECT ... FROM ... UNION SELECT ... FROM ...;`
*   `UNION`: 2つ以上の`SELECT`文の結果を結合するための集合演算子です。結合する際、自動的に結果セット全体から重複する行を取り除きます。
*   **注意**: `UNION`で結合する各`SELECT`文は、列の数と、対応する列のデータ型が一致している必要があります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: パフォーマンスを考えずに、常に`UNION`を使ってしまう。
*   **解説**: `UNION`は重複を排除するために、内部的にソート処理のような負荷のかかる処理を実行します。もし「重複があっても構わない、単純に結果を連結したいだけ」という要件であれば、重複排除を行わない `UNION ALL` を使うべきです。`UNION ALL`の方が高速に動作するため、要件に応じて適切に使い分けることが重要です。

---
### 問題
 ECサイトの売上ログを分析しています。4月度の売上履歴（`売上履歴_4月`テーブル）と5月度の売上履歴（`売上履歴_5月`テーブル）を、単純に縦に連結して一つの時系列データとして扱いたいと考えています。
このような場合に、2つの`SELECT`文の結果を高速に結合するには、どの集合演算子を使えばよいでしょうか。

```sql
SELECT 注文日, 商品ID, 金額 FROM 売上履歴_4月
【 a 】
SELECT 注文日, 商品ID, 金額 FROM 売上履歴_5月;
```
**【回答】**
`a`: `UNION ALL`
**【この構文が必要な理由】**
売上履歴が重複することはないので、まず、重複排除は不要だろう。
複数のテーブルや`SELECT`文の結果を、重複排除の処理を行わずに、そのまま高速に連結したい場合に最適だからです。ログデータのように、もともと重複という概念がない（あるいは重複していても問題ない）データを単純にまとめる際に使用されます。

**【構文の解説】**
`SELECT ... FROM ... UNION ALL SELECT ... FROM ...;`
*   `UNION ALL`: 2つ以上の`SELECT`文の結果を結合するための集合演算子です。`UNION`とは異なり、重複行の排除を行わず、すべての行をそのまま返します。そのため、`UNION`よりも処理負荷が低く、高速に動作します。
*   **注意**: `UNION ALL`で結合する各`SELECT`文も、`UNION`と同様に列の数とデータ型が一致している必要があります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `UNION`と`UNION ALL`は同じものだと思い、`UNION`を使ってしまう。
*   **解説**: 「重複を排除するかしないか」という明確な違いがあります。要件が「ユニークな一覧が欲しい」のであれば`UNION`、「すべてのデータを単純に連結したい」のであれば`UNION ALL`です。今回のシナリオで`UNION`を使うと、もし4月と5月に全く同じ内容（注文日、商品ID、金額）の売上があった場合に、それが1件にまとめられてしまい、正確な売上分析ができなくなる可能性があります。

---

### 問題
 商品の売上データを分析し、商品カテゴリごとの売上合計金額を算出することになりました。「売上明細」テーブルと「商品マスタ」テーブルを結合し、`商品カテゴリ`でデータを分類して集計するには、どの句を使用すればよいでしょうか。

```sql
SELECT
  P.商品カテゴリ,
  SUM(S.金額) AS カテゴリ別合計
FROM
  売上明細 S
INNER JOIN
  商品マスタ P ON S.商品ID = P.商品ID
【 a 】 P.商品カテゴリ;
```
**【回答】**
`a`: `GROUP BY`
**【この構文が必要な理由】**
行全体を特定の列（この場合は`商品カテゴリ`）の値に基づいてグループにまとめ、それぞれのグループに対して`SUM()`や`COUNT()`といった集約関数を適用し、要約されたデータを生成する必要があるためです。

**【構文の解説】**
`SELECT <グループ化列>, <集約関数> FROM ... GROUP BY <グループ化列>;`
*   `GROUP BY`: 指定された列の値が同じ行を一つのグループとしてまとめます。
*   `SELECT`句には、`GROUP BY`句で指定した列と、集約関数（`SUM()`, `COUNT()`, `AVG()`, `MAX()`, `MIN()`など）しか記述できません。これは、グループ化によって複数行が1行にまとめられるため、どの行の値を表示すればよいか不定になるからです。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `SELECT`句に、`GROUP BY`で指定していない列（例：`商品名`）を追加してしまう。
*   **解説**: `SELECT P.商品カテゴリ, P.商品名, SUM(S.金額) ... GROUP BY P.商品カテゴリ;` のようなSQLは多くのデータベースでエラーになります。なぜなら、「文房具」というカテゴリに「鉛筆」「消しゴム」があった場合、集計結果の1行に表示すべき`商品名`が特定できないからです。`SELECT`句に集約関数と通常の列を混在させる場合は、そのすべての通常列を`GROUP BY`句に含める必要があります。

---
### 問題
 社員名簿に、各社員の給与が全社内で何位にあたるのかを示す「給与ランキング」列を追加して表示したいと考えています。`GROUP BY`のように行をまとめることなく、各行に対してランキングを計算するには、どのような関数を使えばよいでしょうか。

```sql
SELECT
  氏名,
  給与,
  RANK() 【 a 】 (ORDER BY 給与 DESC) AS 給与ランキング
FROM
  社員;
```
**【回答】**
`a`: `OVER`
**【この構文が必要な理由】**
個々の行の情報を維持したまま、集団（この場合は全社員）の中での相対的な位置（ランキング）や累積値などを計算する必要があるためです。`GROUP BY`では行が集約されてしまうため、このような計算はできません。

**【構文の解説】**
`<ウィンドウ関数>() OVER (PARTITION BY <分割列> ORDER BY <順序列>)`
*   **ウィンドウ関数**: `RANK()`, `ROW_NUMBER()`, `SUM()`, `AVG()`など、集計を行う関数が使えます。
*   `OVER()`: ウィンドウ関数の計算対象となる行の範囲（ウィンドウ）を指定する句です。
*   `PARTITION BY <分割列>`: (オプション) `GROUP BY`のように、ここで指定した列の値ごとにデータをグループ分けし、そのグループ内でウィンドウ関数の計算を行います。
*   `ORDER BY <順序列>`: ウィンドウ内で、どの列を基準にどのような順序（`ASC`/`DESC`）で計算を行うかを指定します。ランキング計算では必須です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `RANK()`関数を知っていても、`OVER()`句を付け忘れる。
*   **解説**: `RANK()`や`SUM()`といった関数は、`OVER()`句を伴うことで「ウィンドウ関数」として機能します。`OVER()`句がない場合、`SUM()`などは通常の集約関数として扱われ、`GROUP BY`句が必要になります。`OVER()`句は、これらの関数に「どの範囲の行を対象に計算するか」を教える、非常に重要な役割を担っています。

---
### 問題
 特定のキャンペーン対象商品（商品IDが 'A001', 'B005', 'C012' のいずれか）の情報を「商品マスタ」から一度に取得したいと考えています。

`WHERE`句で、ある列の値が指定した複数の値のリストの「中に含まれる」かどうかを判定するには、どの演算子を使えばよいでしょうか。

```sql
SELECT
  商品名,
  単価
FROM
  商品マスタ
WHERE
  商品ID 【 a 】 ('A001', 'B005', 'C012');
```
**【回答】**
`a`: `IN`
= ANYも正解ではありますが、実用上はIN演算子の方が選択するのが適切（標準的かつ可読性の点で）
**【この構文が必要な理由】**
複数の`OR`条件（`WHERE 商品ID = 'A001' OR 商品ID = 'B005' OR ...`）を記述する代わりに、より簡潔で可読性の高い形で、値の集合との比較を行う必要があるためです。

**【構文の解説】**
`WHERE <列名> IN (<値1>, <値2>, ...)`
*   `IN`: 指定した列の値が、括弧内のリストに含まれるいずれかの値と等しい場合に`TRUE`を返します。
*   括弧内には直接値を列挙するだけでなく、`SELECT`文（サブクエリ）を記述して、その結果セットをリストとして使用することも可能です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `NOT IN (サブクエリ)` を使用する際に、サブクエリの結果に`NULL`が含まれていると意図しない結果になる。
*   **解説**: `WHERE 列名 NOT IN (1, 2, NULL)` のような条件は、`列名 <> 1 AND 列名 <> 2 AND 列名 <> NULL` とほぼ等価に評価されます。SQLでは`NULL`との比較（`<> NULL`）は「不明(UNKNOWN)」となり、結果として全体の条件式が`TRUE`にならないため、1行も返ってこないという現象が起こります。`NOT IN`でサブクエリを使う場合は、サブクエリ側で`NULL`を返さないように`WHERE ... IS NOT NULL`でフィルタリングするなどの注意が必要です。

---

## SQL UPDATE文での相関サブクエリ

### 問題
商品マスタテーブルで、各商品カテゴリ内の平均単価よりも高い商品に対して、備考欄に「カテゴリ内平均より高価格」という情報を更新したい。このとき、外側のクエリの各レコードに対応するカテゴリの平均単価を求めるために必要な構文は何か。

```sql
UPDATE 商品マスタ M1
SET 備考 = 'カテゴリ内平均より高価格'
WHERE
  M1.単価 > (
    【 a 】 AVG(M2.単価)
    FROM 商品マスタ M2
    WHERE M2.商品カテゴリ = M1.商品カテゴリ
  );
```

**【回答】**
`a`: SELECT

**【この構文が必要な理由】**
外側のクエリの各レコードに対して、そのレコードと同じカテゴリに属する商品の平均単価を動的に計算し、比較条件として使用するため、相関サブクエリとしてSELECT文が必要です。

**【構文の解説】**
`SELECT 集約関数(列名) FROM テーブル名 WHERE 相関条件`の形式で記述します。サブクエリ内のWHERE句で外側クエリのテーブル（M1）の値を参照することにより、外側の各レコードに対応した集計値を求めることができます。

**【初心者が陥りがちな誤解や誤答例】**
* **誤解/誤答**: AVG(M2.単価)だけを記述し、SELECT文を省略してしまう
* **解説**: サブクエリは完全なSELECT文である必要があり、集約関数だけでは構文エラーとなります。必ずSELECTキーワードから始める必要があります。

* **誤解/誤答**: 相関条件（WHERE M2.商品カテゴリ = M1.商品カテゴリ）を理解せず、単純にAVG(単価)で全商品の平均を求めてしまう
* **解説**: 相関条件がないと、各商品カテゴリごとの平均ではなく、全商品の平均単価が計算されてしまい、業務要件を満たすことができません。

---

### 問題
 現在の「売上明細」テーブルから、売上金額が10万円以上の高額取引のレコードだけを抽出し、新しく作成した「高額取引履歴」テーブルに丸ごとコピー（挿入）することになりました。

`SELECT`文の実行結果を、そのまま別のテーブルに挿入するには、どのような構文を使用すればよいでしょうか。

```sql
【 a 】 高額取引履歴 (注文ID, 顧客ID, 金額, 取引日)
【 b 】
  注文ID, 顧客ID, 金額, 取引日
FROM
  売上明細
WHERE
  金額 >= 100000;
  ```
**【回答】**
`a`: `INSERT INTO`
`b`: `SELECT`
**【この構文が必要な理由】**
あるテーブルから特定の条件で抽出したデータを、一行ずつではなく一括で効率的に別のテーブルにバックアップしたり、移し替えたりする必要があるためです。データ移行やバッチ処理などで頻繁に利用されます。

**【構文の解説】**
`INSERT INTO <テーブル名> (<列リスト>) SELECT <列リスト> FROM ...;`
*   `INSERT INTO ... SELECT ...`: `VALUES`句を使って1行ずつデータを指定する代わりに、`SELECT`文の実行結果セットをまるごと挿入データとして使用します。
*   **注意**: `INSERT`句の列リストの列数・データ型と、`SELECT`句の列リストの列数・データ型は、一致している必要があります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 挿入先のテーブル（高額取引履歴）が存在しない状態で実行しようとする。
*   **解説**: `INSERT INTO`文は、既にあるテーブルにデータを「追加」するための命令です。テーブル自体が存在しない場合は、まず`CREATE TABLE`文でテーブルの構造を定義しておく必要があります。データベース製品によっては`SELECT ... INTO <新テーブル>`という構文でテーブル作成とデータ挿入を同時に行えるものもありますが、標準SQLでは分けるのが一般的です。

---
### 問題
 よく利用する、社員情報と部署情報を結合した結果を、毎回長い`SELECT`文を書かずに、あたかも一つのテーブルのように手軽に参照できるようにしたいと考えています。
このような、保存された`SELECT`文である「仮想的なテーブル」を作成するには、どのDDL（データ定義言語）文を使用すればよいでしょうか。

```sql
【 a 】 社員部署一覧_V (社員名, 部署名, 内線番号) AS
SELECT
  S.氏名,
  D.部署名,
  S.内線番号
FROM
  社員 S
INNER JOIN
  部署マスタ D ON S.所属部署ID = D.部署ID;
```
**【回答】**
`a`: `CREATE VIEW`
**【この構文が必要な理由】**
複雑なSQLクエリや頻繁に利用する結合結果を、データベース内に名前を付けて保存しておくことで、再利用性を高め、クエリを単純化するためです。また、元のテーブルの一部の列だけを公開することで、セキュリティを高める目的でも使用されます。

**【構文の解説】**
`CREATE VIEW <ビュー名> (<ビューの列リスト>) AS <SELECT文>;`
*   `CREATE VIEW`: 新しいビューを定義します。ビューは実データを持たず、参照されるたびに内部的に`SELECT`文が実行されます。
*   `<ビューの列リスト>`: (オプション) ビューとして公開する列に別名を付けることができます。
*   `AS <SELECT文>`: ビューの元となる`SELECT`文を定義します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: ビューは実際のデータを持っているテーブルだと勘違いする。
*   **解説**: ビューは「保存されたクエリ」であり、実体は`SELECT`文そのものです。ビューに対してクエリを実行すると、データベースシステムがビューの定義（`SELECT`文）とユーザーのクエリを組み合わせて、元の実テーブルにアクセスします。そのため、元のテーブルのデータが更新されれば、ビューから見えるデータも即座に変わります。（注意：更新できるVIEWとできないものがある。ビューの更新可能性という問題）

---
### 問題
 システム開発の初期段階で、社員情報を格納するための新しいテーブル「社員」を作成することになりました。社員を一意に識別するための「社員ID」列を主キーとして設定し、社員の「氏名」は必須入力（`NULL`を許可しない）とします。

```sql
【 a 】 社員 (
  社員ID   CHAR(5)    【 b 】,
  氏名     VARCHAR(40) 【 c 】,
  所属部署ID CHAR(4)
);
```
**【回答】**
`a`: `CREATE TABLE`
`b`: `PRIMARY KEY`
c: NOT NULL
**【この構文が必要な理由】**
データベースにデータを格納するための器である「テーブル」の構造（スキーマ）を定義するために必要です。どのような列があり、それぞれのデータ型や制約（主キー、非NULLなど）はどうなっているかを定める、データ管理の基本となる命令です。

**【構文の解説】**
`CREATE TABLE <テーブル名> ( <列名1> <データ型> <制約>, <列名2> <データ型> <制約>, ... );`
*   `CREATE TABLE`: 新しいテーブルを作成します。
*   **列定義**: 列名、データ型（`CHAR`, `VARCHAR`, `INTEGER`, `DATE`など）、そしてその列に対する制約を記述します。
*   `PRIMARY KEY`: 主キー制約。その列の値がテーブル内で一意（重複不可）であり、かつ`NULL`であってはならないことを示します。テーブルの行を特定するための最も重要なキーです。
*   `NOT NULL`: 非NULL制約。その列に`NULL`値の格納を許可しないことを示します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 主キー(`PRIMARY KEY`)とユニークキー(`UNIQUE`)の違いを混同する。
*   **解説**: どちらも「重複を許可しない」という点は共通ですが、重要な違いがあります。一つのテーブルに`PRIMARY KEY`は一つしか設定できませんが、`UNIQUE`キーは複数設定できます。また、`PRIMARY KEY`は`NULL`を許可しませんが、`UNIQUE`制約は（製品によりますが）一般的に`NULL`を許可します（ただし`NULL`の重複は許さないなど挙動に差があります）。

---

### 問題
 データベースの設計変更で、既存の「売上明細」テーブルの「商品ID」列が、「商品マスタ」テーブルの「商品ID」を必ず参照するように、整合性を保つための制約（外部キー制約）を追加することになりました。

既存のテーブルの定義を変更して、制約を追加するにはどのDDL文を使用しますか。

```sql
【 a 】 売上明細
【 b 】 FK_商品ID
  FOREIGN KEY (商品ID) REFERENCES 商品マスタ(商品ID);
```
**【回答】**
`a`: `ALTER TABLE`
`b`: `ADD CONSTRAINT`
**【この構文が必要な理由】**
テーブルを一度作成した後で、業務要件の変更などに応じて、列を追加・削除したり、制約を追加・削除したりする必要があるためです。データベースの運用・保守において不可欠な命令です。

**【構文の解説】**
`ALTER TABLE <テーブル名> ADD CONSTRAINT <制約名> <制約定義>;`
*   `ALTER TABLE`: 既存のテーブルの構造を変更します。
*   `ADD CONSTRAINT`: テーブルに新しい制約を追加します。制約には名前（この例では`FK_商品ID`）を付けることが推奨されます。
*   `FOREIGN KEY (列名) REFERENCES <親テーブル>(列名)`: 外部キー制約を定義します。これにより、「売上明細」の「商品ID」列には、「商品マスタ」の「商品ID」列に存在する値しか登録できなくなり、データの整合性が保たれます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 外部キー制約を追加しようとしたらエラーになった。
*   **解説**: エラーになる最も一般的な原因は、制約を追加しようとしている子テーブル（売上明細）に、親テーブル（商品マスタ）に存在しない値がすでに入力されている場合です。例えば、商品マスタに存在しない商品ID 'X999' が売上明細に記録されていると、制約を追加した時点で整合性が崩れるため、データベースがエラーを返します。先に関連データを修正または削除する必要があります。

---

### 問題
 ログデータが、'20240901' のような `YYYYMMDD` 形式の文字列（`VARCHAR`型）でテーブルに格納されています。このログデータから、2024年9月1日以降のレコードを日付として正しく比較・抽出したいと考えています。

文字列を日付型などの別のデータ型に明示的に変換するには、どの関数を使用すればよいでしょうか。

```sql
SELECT
  ログ本文
FROM
  アクセスログ
WHERE
  【 a 】(記録日時 AS DATE) >= '2024-09-01';
```
**【回答】**
`a`: `CAST`
**【この構文が必要な理由】**
'20240901' のような文字列のままでは、日付としての大小比較や日付関数を使った計算ができません。データを適切なデータ型に変換することで、その型が持つ本来の機能（日付の比較、数値計算など）を利用できるようにするためです。

**【構文の解説】**
`CAST(<変換する値> AS <変換後のデータ型>)`
*   `CAST`: 値のデータ型を明示的に変換するための標準SQL関数です。
*   **変換後のデータ型**: `INTEGER`, `VARCHAR(n)`, `DATE`, `TIMESTAMP`など、変換したいデータ型を指定します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 型変換をせずに、`WHERE 記録日時 >= '20240901'` のように文字列のまま比較してしまう。
*   **解説**: この例では、文字列としての辞書順比較でも偶然正しい結果が得られます。しかし、日付のフォーマットが '01/09/2024' (DD/MM/YYYY) のような場合、文字列比較では '02/08/2024' の方が大きいと誤判定されてしまいます。また、'2024-9-1' のように桁数が違うと正しく比較できません。日付や数値の比較は、必ず適切なデータ型に変換してから行うのが鉄則です。

---
### 問題
 あるキャンペーン期間中に、商品を購入した顧客が「何人」いたのかを調べる必要があります。一人の顧客が期間中に複数回購入していても、1人と数えたいです。
「売上明細」テーブルから、重複を除いたユニークな顧客IDの数を数えるには、`COUNT`関数をどのように使えばよいでしょうか。

```sql
SELECT
  【 a 】 顧客ID) AS 購入顧客数
FROM
  売上明細
WHERE
  売上日 BETWEEN '2024-08-01' AND '2024-08-31';
```
**【回答】**
`a`: `COUNT(DISTINCT `
**【この構文が必要な理由】**
単純な行数（延べ人数）ではなく、対象となるエンティティ（この場合は顧客）の純粋な数（正味人数）を把握する必要があるためです。`DISTINCT`キーワードにより、集計前に対象列から重複値を取り除くことができます。

**【構文の解説】**
`COUNT(DISTINCT <列名>)`
*   `COUNT(<列名>)`: 指定した列の`NULL`でない行の数を数えます。
*   `COUNT(*)`: `NULL`を含めたすべての行の数を数えます。
*   `DISTINCT`: `COUNT`関数と組み合わせることで、集計対象の列から重複する値を除外してから、その件数を数えます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `COUNT(*)` や `COUNT(顧客ID)` を使ってしまう。
*   **解説**: `COUNT(*)`や`COUNT(顧客ID)`を使うと、売上の「件数」（延べ購入回数）がカウントされてしまいます。例えば、Aさんが3回、Bさんが2回購入した場合、`5`という結果が返ってきます。要件である「何人いたか（購入者数）」を調べるには、AさんとBさんの2人を数える必要があるので、`COUNT(DISTINCT 顧客ID)`を使い、`2`という結果を得るのが正解です。

---

### 問題

**【問題】**
「どの担当者が、どのカテゴリでいくら売り上げたか」を分析することにしました。
```sql
SELECT
    担当者名,
    カテゴリ,
    SUM(売上金額) AS 売上合計
FROM
    売上明細
【 a 】
    【 b 】;
```

**【回答】**
`a`: `GROUP BY`
`b`: `担当者名, カテゴリ`

**【この構文が必要な理由】**
「誰が」「何を」という2つの軸で集計を行うため、グループ化の基準（キー）としてその両方を指定する必要があるからです。`GROUP BY`は、これから行う集計計算の「切り口」を定義する重要な役割を担います。

**【構文の解説】**
`GROUP BY <列1>, <列2>, ...`
`SELECT`句に集約関数（`SUM`など）と非集約列（`担当者名`、`カテゴリ`）を混在させる場合、**すべての非集約列を`GROUP BY`句に指定しなければならない**という厳密なルールがあります。これにより、「`担当者名`と`カテゴリ`の値の組み合わせが同じ行」を一つのグループとして扱い、そのグループ内で`SUM`が計算されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `GROUP BY 担当者名` のように、非集約列の一部だけを指定してしまう。
*   **解説**: この場合、データベースは「`担当者名`でグループ化したはいいが、同じ担当者（例：佐藤さん）が複数のカテゴリ（PC、周辺機器）を売り上げている場合、`SELECT`句に表示すべき`カテゴリ`は一体どれなのか？」と混乱し、エラーを返します。`SELECT`句で表示する非集約列は、すべて集約のキーとして`GROUP BY`句に含めることで、結果の各行が一意に定まることを保証する必要があります。

---

### 問題6: 相対的な評価 〜 カテゴリ平均との比較

**【問題】**
最後の分析として、個々の商品の売上が、その商品が属するカテゴリ全体の平均売上と比較してどうなのかを評価し、隠れた優良商品やテコ入れが必要な商品を見つけたくなりました。`SELECT`句の中で、外側のクエリ（商品ごと）のカテゴリIDを使い、内側のクエリでそのカテゴリの平均売上を計算させるには、サブクエリ内で何を行えば「単一の値（1行1列）」を返すというルールを満たせるでしょうか。

---

### 🧩 空欄を追加したSQL文（S1・S2のエイリアス）

```sql
SELECT 商品名, 売上金額, 
       (SELECT AVG(売上金額) 
        FROM 売上明細 S2 
        WHERE 【 b 】.カテゴリID = 【 a 】.カテゴリID) AS カテゴリ平均売上 
FROM 売上明細 S1;
```

---

### ✅ 【回答】

| 空欄 | 内容   | 説明                                               |
|------|--------|----------------------------------------------------|
| a    | S1     | メインクエリのテーブルエイリアス（売上明細）       |
| b    | S2     | サブクエリのテーブルエイリアス（売上明細）         |

---

このようにすることで、**エイリアスの役割と参照関係**を問う良問になります。  
特に自己相関サブクエリの理解を深めるのに効果的ですね。

**【この構文が必要な理由】**
`SELECT`句に埋め込むサブクエリ（スカラサブクエリ）は、外側のクエリの各行に対して「一つの値」を返さなければならないという制約があるためです。集約関数（`AVG`, `MAX`等）を使うことで、サブクエリが返しうる複数行のデータを、ルールに適合する単一の値に集約できます。

**【構文の解説】**
`SELECT`句や`WHERE`句の比較演算子の右辺で使われる、単一の値を返すサブクエリを「スカラサブクエリ」と呼びます。外側のクエリの行（ここでは`S1`の各行）の値を、内側のサブクエリ（`S2`）の条件に使うものを特に「相関サブクエリ」と言います。この組み合わせにより、各商品の行ごとに、その商品が属するカテゴリの平均売上を動的に計算して横に並べることが可能になります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 集約関数を忘れ、平均ではなく個々の売上を返そうとしてしまう。
    ```sql
    -- エラーになる例
    (SELECT 売上金額 FROM 売上明細 S2 WHERE S2.カテゴリID = S1.カテゴリID)
    ```
*   **解説**: このサブクエリは、ある商品と同じカテゴリに属する**すべての**売上金額を返そうとします。通常、カテゴリには複数の売上記録があるため、サブクエリは複数行を返そうとして「サブクエリが複数の値を返しました」というエラーを引き起こします。各行に対して単一の「カテゴリ平均売上」という値を得るためには、`AVG()`関数で複数行のデータを集約し、必ず1行1列の結果を返すように保証する必要があります。