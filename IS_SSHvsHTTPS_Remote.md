KY
# SSH:操作
# HTTPS：送受信

***

# 遠隔サーバ管理：なぜSSHが標準であり、HTTPSで代替できないのか？

遠隔地にあるサーバにコマンドを送信し、安全に管理・操作する際、なぜSSHが標準的に利用され、同じく暗号化通信を行うHTTPSでは代替できないのか。この問いは、通信の目的とプロトコルの適合性を見極める上で非常に重要です。以下に、両者の役割、技術的な違い、そして実務的な使い分けについて体系的に解説します。

## 1. 結論：プロトコルの「目的」が根本的に異なる

両者の最も大きな違いは、その設計思想と目的にあります。

*   **SSH (Secure Shell)**：遠隔地のコンピュータを「**直接・対話的に操作する**」ために設計されたプロトコル。
*   **HTTPS (HTTP Secure)**：WebブラウザとWebサーバ間で「**データを安全に送受信する**」ために設計されたプロトコル。

どちらも**通信を暗号化するという点では共通**していますが、その暗号化された**通信路の上で何を行うかが全く異なり**ます。

## 2. SSH (Secure Shell) - 遠隔操作のスペシャリスト
SSHは、遠隔地のサーバに安全にログインし、コマンド操作やファイル転送を行うためのプロトコルです。

### 主な特徴と利点

*   **双方向・対話型通信**:
    *   コマンドラインシェル（`bash`, `zsh`など）を通じて、リアルタイムにサーバと対話しながら操作することが可能です。OSレベルでの対話型セッションを提供します。
*   **OSへの直接アクセス**:
    *   ファイルシステムや実行中のプロセスに直接アクセスし、詳細な管理作業を行えます。
*   **強力な認証方式**:
    *   パスワード認証も可能ですが、より安全で自動化にも適した**公開鍵認証**が標準的に利用されます。
*   **セキュアな通信**:
    *   認証情報から通信内容まで、セッション全体が強力に暗号化されます。
*   **多彩な機能**:
    *   コマンド実行だけでなく、`scp`, `rsync`, `sftp` といったセキュアなファイル転送機能も内包しています。
*   **専用ポート**:
    *   通常、TCPポート番号**22番**を使用し、ファイアウォールでのアクセス制御も明確です。

### 典型的な用途

*   サーバの設定ファイルの編集やサービスの再起動（例: `sudo systemctl restart nginx`）
*   ログファイルのリアルタイム監視（例: `tail -f /var/log/syslog`）
*   スクリプトの実行やソフトウェアのインストール
*   セキュアなファイル転送（`scp`, `sftp`）やディレクトリ同期（`rsync`）

## 3. HTTPS - Web通信の安全性を担うプロトコル

HTTPSは、HTTP通信をTLS（Transport Layer Security）プロトコルで暗号化し、WebブラウザとWebサーバ間のデータ通信を安全に行うためのものです。

### 主な特徴と限界点

*   **リクエスト/レスポンス型の通信**:
    *   基本はクライアント（ブラウザ）からの「要求（Request）」に対し、サーバが「応答（Response）」を返す一方向の通信モデルです。
*   **操作対象の限定**:
    *   サーバを直接操作するのではなく、WebアプリケーションやAPIを通じて間接的に操作します。どのような操作が可能かは、事前に設計・実装されたAPIや管理画面の機能に依存します。
*   **対話性の欠如**:
    *   リアルタイムでの継続的なコマンド実行や、インタラクティブな操作には向きません。
*   **専用ポート**:
    *   通常、TCPポート番号**443番**を使用します。

### 例外的に利用される場面

HTTPSがサーバ管理の文脈で使われるのは、以下のようなWebベースのインターフェースを通じた操作です。

*   **Webベースの管理画面**: AWS マネジメントコンソールや、各種SaaSのダッシュボードなど。
*   **REST API経由での操作**: 事前に定義されたAPIエンドポイントに対してリクエストを送り、サーバの状態変更や情報取得を行います（例: GitHub Actionsによるデプロイ）。

## 4. 技術的な比較：なぜ「同じ暗号化」でも役割が違うのか

「通信全体が暗号化されるなら、どちらも安全で同じではないか？」という疑問はもっともです。
その答えは、暗号化という土台の上にある「機能層」の違いにあります。

### 共通点：通信路の安全性

まず、暗号化通信という観点では両者は同等の安全性を目指しています。

| 項目 | SSH | HTTPS |
| :--- | :--- | :--- |
| **暗号化方式** | TLSまたは独自の暗号化 | TLS (SSLの後継) |
| **保護対象** | 認証情報、通信内容、セッション全体 | 認証情報、通信内容、セッション全体 |
| **攻撃耐性** | 中間者攻撃(MITM)、盗聴、改ざんに強い | 中間者攻撃(MITM)、盗聴、改ざんに強い |

つまり、**通信経路の安全性**という点においては、どちらも高いレベルのセキュリティを提供します。

### 本質的な違い：プロトコルの構造

違いの本質は、暗号化されたトンネルの中でどのような通信規約（プロトコル）が話されているか、です。

*   **SSH**: OSのシェルを直接操作するためのプロトコルが動いています。これにより、キー入力、画面出力、シグナル送信などがリアルタイムに行えます。
*   **HTTPS**: HTTPプロトコルが動いています。これは「このURLのリソースをください(GET)」「このデータを登録してください(POST)」といった、Webリソースのやり取りに特化した規約です。

### 分かりやすい例え

この違いは、以下のように例えることができます。

*   **SSH**: 遠隔地のオフィスに入るための**「セキュリティキー付きのドア」**です。一度中に入れば、部屋の中を自由に歩き回り、デスクの引き出しを開けたり、PCを直接操作したりできます。
*   **HTTPS**: オフィスの受付にある**「安全な郵便ポスト（または窓口）」**です。事前に決められた書式の依頼書（リクエスト）を投函すれば、受付担当者（Webサーバ）が中の人に用件を伝えてくれますが、自分で直接オフィスの中に入ることはできません。

どちらも通信の秘密は守られますが、**操作の自由度と直接性**が全く異なります。

### 比較一覧表

| 項目 | SSH | HTTPS |
| :--- | :--- | :--- |
| **主な用途** | サーバへの遠隔ログイン、コマンド実行、管理 | Webサイトの閲覧、Web API経由のアクセス |
| **通信方式** | **双方向・対話型** (セッション指向) | **リクエスト/レスポンス型** |
| **認証方式** | **公開鍵認証**、パスワード認証 | トークン認証、OAuth、クライアント証明書など |
| **自動化との相性** | **高い**。スクリプトやCI/CDツールと直接連携しやすい | **APIの設計が必要**。APIが提供されていれば連携可能 |
| **標準ポート** | TCP 22番 | TCP 443番 |

## 5. 実務における使い分けのポイント

以上の特性から、実務では以下のように使い分けられます。

| 目的・要件 | 最適なプロトコル | 理由 |
| :--- | :--- | :--- |
| **サーバのリアルタイム操作・デバッグ** | **SSH** | 対話型のシェルアクセスが不可欠なため。 |
| **CLIベースでのファイル転送** | **SSH (scp/sftp/rsync)** | 専用の効率的なファイル転送機能が組み込まれているため。 |
| **インフラの自動化・スクリプト連携** | **SSH** | 公開鍵認証により、非対話的かつ安全な自動実行が容易なため。 |
| **Webサービス経由での限定的な操作** | **HTTPS** | 事前に定義された安全なAPIを通じて操作を制御できるため。 |
| **WebベースのGUIでのサーバ管理** | **HTTPS** | ブラウザさえあれば操作できる利便性があるため。 |
| **ファイアウォール通過の容易さ** | **HTTPS** (の場合もある) | 多くのネットワーク環境でWebアクセス用の443番ポートは許可されているため。 |

### まとめ

SSHとHTTPSは、どちらも現代のネットワークに不可欠なセキュアなプロトコルですが、その役割は明確に異なります。
**サーバを「OSレベルで直接管理する」**という要件に対しては、そのために設計された**SSHが唯一無二の選択肢**となります。
一方で、Webアプリケーションとして提供される機能を通じて「間接的にサーバを操作する」場合には、**HTTPS**がその役割を担います。両者の特性を正しく理解し、目的に応じて適切に使い分けることが重要です。