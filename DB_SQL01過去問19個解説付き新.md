承知いたしました。
応用情報技術者試験のデータベーススペシャリストとして、ご提示いただいた過去問の解説を、サンプル形式に沿って詳細に深掘りしていきます。得点力アップに繋がるよう、技術的背景や思考プロセス、関連知識まで網羅的に解説します。

---

## 令和6年秋期 午後 データベース

### １　問題提示

```sql
［令和6年］
設問２：指定されたカテゴリIDとその配下にあるすべてのサブカテゴリIDを取得し、それらのカテゴリに属する商品を検索条件に基づいて抽出するSQL文。
【e】 指定カテゴリ(カテゴリID, カテゴリ名, 上位カテゴリID) AS (
    SELECT A.カテゴリID, A.カテゴリ名, A.上位カテゴリID
    FROM カテゴリ A WHERE A.カテゴリID = :カテゴリID
    【 f 】
    SELECT B.カテゴリID, B.カテゴリ名, B.上位カテゴリID
    FROM カテゴリ B, 指定カテゴリ C WHERE B.上位カテゴリID = C.カテゴリID
)
SELECT * FROM 出品
INNER JOIN 指定カテゴリ
ON 【 g 】
WHERE 出品.出品価格 BETWEEN :下限価格 AND :上限価格
AND 出品.商品状態 = :商品状態
AND 出品.出品状況 = :出品状況
AND (出品.商品名 【 h 】 OR 出品.商品説明 【 h 】)
```

### ２　解答と解説

#### ２－１　正答
*   **e**: `WITH RECURSIVE`
*   **f**: `UNION ALL`
*   **g**: `出品.カテゴリID = 指定カテゴリ.カテゴリID`
*   **h**: `LIKE '%' || :キーワード || '%'`

**解答根拠**
*   **e**: SQLの構造が、共通表式（CTE）`指定カテゴリ`の定義内で、`指定カテゴリ`自身を参照しています。このような自己参照を行うCTEは再帰CTEと呼ばれ、`WITH RECURSIVE`キーワードで開始する必要があります。
*   **f**: 再帰CTEでは、初期SELECT（アンカーメンバー）と再帰SELECT（再帰メンバー）の結果を結合します。カテゴリ階層のようなツリー構造の探索では、通常、同じノード（カテゴリ）が重複して出現することはないため、不要な重複排除処理を行わない`UNION ALL`を使用するのがパフォーマンス上、最も適切です。
*   **g**: 主問い合わせと、CTEで生成した`指定カテゴリ`テーブルを結合するための条件です。`出品`テーブルが持つ`カテゴリID`が、`指定カテゴリ`（指定されたカテゴリとその配下すべて）に含まれるレコードを抽出するため、両テーブルの`カテゴリID`をキーに結合します。
*   **h**: 問題文の「検索文字列を含む」という要件を満たすには、文字列の部分一致検索を行う`LIKE`演算子を使用します。`%`は任意の0文字以上の文字列を表すワイルドカードであり、検索キーワードの前後に連結することで、キーワードが任意の位置に含まれる文字列を検索できます。`||`は標準SQLにおける文字列連結演算子です。

#### ２－２　誤答パターン
*   **e**: `WITH`だけを解答する誤答。再帰処理を行うCTEには`RECURSIVE`キーワードが必須です（一部DBMSでは省略可能ですが、試験では標準的な構文が問われます）。
*   **f**: `UNION`を選択する誤答。カテゴリ階層が重複のないツリー構造である場合、`UNION`が行う重複排除処理は無駄なオーバーヘッドとなり、パフォーマンスを低下させます。
*   **g**: `ON 出品.カテゴリID = :カテゴリID`と解答する誤答。これでは、指定した最上位カテゴリに属する商品しか抽出できず、「配下のすべてのサブカテゴリ」という重要な要件を満たすことができません。
*   **h**: `= :キーワード`を選択する誤答。これは完全一致検索であり、「含む」という部分一致検索の要件を満たせません。

#### ２－３　解答アプローチ
1.  **要件抽出**: 問題文から「指定カテゴリとその**配下の全サブカテゴリ**」「商品名**又は**商品説明に検索文字列を**含む**」という中心的な要件を正確に読み取ります。
2.  **SQL構造読解**: `... AS (SELECT ... ??? SELECT ...)`という構造と、CTE内部での自己参照（`指定カテゴリ`）から、これは階層問い合わせを行う**再帰CTE**であると即座に判断します。
3.  **キーワード識別**:
    *   「配下のすべて」「階層」→ `WITH RECURSIVE`
    *   再帰CTEのメンバー結合 → `UNION ALL`
    *   「～を含む」 → `LIKE`演算子とワイルドカード`%`
    *   「～に属する」 → `INNER JOIN`と`ON`句によるキー結合

### ３　技術知識体系

#### ３－１　必要知識項目
*   **再帰共通表式 (Recursive CTE)**: `WITH RECURSIVE`句を用いて、組織図、部品表、カテゴリ階層などの階層構造を持つデータをSQLのみで再帰的に問い合わせる機能です。
*   **LIKE演算子**: ワイルドカード（`%`: 任意の0文字以上の文字列、`_`: 任意の一文字）を使い、文字列の部分一致検索を行います。
*   **UNION ALL演算子**: 2つ以上の`SELECT`文の結果セットを、重複行を排除せずにそのまま縦に連結します。
*   **文字列連結**: `||` (標準SQL, Oracle, PostgreSQLなど) や `+` (SQL Server), `CONCAT()`関数 (MySQLなど) を使って文字列を連結します。試験では`||`がよく使われます。

#### ３－２　関連概念の整理
*   **UNION vs UNION ALL**: `UNION`は結果セットを結合する際に**重複行を排除**します。このため、内部的にソートなどの処理が発生し、`UNION ALL`に比べてパフォーマンスが劣る場合があります。`UNION ALL`は**重複を許容**して単純に結合するため高速です。階層検索のように重複が発生しないことが分かっている場合は`UNION ALL`を選択するのがセオリーです。
*   **再帰CTEの構成要素**:
    *   **アンカーメンバー**: 再帰の開始点となる最初の`SELECT`文。ここでは`WHERE A.カテゴリID = :カテゴリID`で指定されたカテゴリが起点です。
    *   **再帰メンバー**: 直前のステップで得られた結果（ここでは`指定カテゴリ C`）を使って、次の階層（`C.カテゴリID`を`上位カテゴリID`に持つカテゴリ`B`）を取得する`SELECT`文です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: `WITH RECURSIVE`において、再帰処理はどのような条件で停止しますか？
*   **答**: 再帰メンバーの`SELECT`文が1行も結果を返さなくなった時点です。
*   **解説**: この問題では、階層の末端（子カテゴリを持たないカテゴリ）に到達すると、`B.上位カテゴリID = C.カテゴリID`を満たす行がなくなり、再帰が自然に停止します。

*   **問**: なぜこの問題では`UNION ALL`が`UNION`よりも推奨されるのですか？
*   **答**: カテゴリの親子関係は通常、循環のないツリー構造であり、探索中に同じカテゴリIDが重複して出現することがないためです。そのため、重複排除のオーバーヘッドがない`UNION ALL`がパフォーマンス上有利だからです。

*   **問**: 再帰CTEを使わずに、同様にカテゴリ階層を検索するにはどのような方法がありますか？
*   **答**: アプリケーション側でループ処理を行うか、事前に各カテゴリにルートからのパス情報を文字列として持たせておく（例: '/1/5/23/'）、などの方法があります。
*   **解説**: しかし、階層の深さが不定の場合、SQL内で完結する再帰CTEが最も効率的かつ標準的な方法です。

*   **問**: 【h】の`LIKE`句で、キーワードの**前方一致**検索だけを行いたい場合、式はどのように変わりますか？
*   **答**: `LIKE :キーワード || '%'` になります。
*   **解説**: ワイルドカード`%`をキーワードの後ろにだけ付けることで、「キーワードで始まる」文字列を検索できます。

*   **問**: `FROM カテゴリ B, 指定カテゴリ C`という書き方は何ですか？
*   **答**: `INNER JOIN`の古いANSI-89形式の構文です。
*   **解説**: `FROM B, C WHERE B.上位カテゴリID = C.カテゴリID` は、`FROM カテゴリ B INNER JOIN 指定カテゴリ C ON B.上位カテゴリID = C.カテゴリID` と等価です。現代では後者のANSI-92形式の方が、結合条件と絞り込み条件が分離され可読性が高いため推奨されます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「階層」「配下」「サブカテゴリ」 | `WITH RECURSIVE` |
| 「～を含む」「部分一致」 | `LIKE`演算子とワイルドカード`%` |
| 「～に属する」 | `INNER JOIN ON (主キー = 外部キー)` |
| 複数の結果セットをそのまま結合 | `UNION ALL` |

### ５　要約
*   組織図やカテゴリのような**階層構造データ**は`WITH RECURSIVE`（再帰CTE）を用いて効率的に処理するのが定石です。
*   再帰CTEの基本構造は、**アンカーメンバー**（起点）と**再帰メンバー**を`UNION ALL`で結合する形をまず思い出しましょう。
*   文字列の**部分一致検索**には`LIKE`演算子とワイルドカード（`%`）の組み合わせが必須です。
*   複雑な処理でも、CTEで処理を**部品化**し、主問い合わせでそれを利用するという流れを理解することが、SQL読解の鍵となります。

---

## 令和6年春期 午後 データベース

### １　問題提示

```sql
［令和6年］
-- 図2
SELECT 祝日 AS 日付, 祝日名 AS 日付名 FROM 国民の祝日 WHERE 祝日 【 b 】
UNION ALL
SELECT 会社記念日 AS 日付, 会社記念日名 AS 日付名 FROM 会社記念日 WHERE 会社番号 = :会社番号 AND 会社記念日 【 b 】
【 c 】

-- 図3
SELECT DEP.部署番号, DEP.部署名, EMP.従業員番号, EMP.従業員氏名
FROM 従業員 EMP INNER JOIN 部署 DEP ON EMP.会社番号 = DEP.会社番号 【 d 】
WHERE EMP.会社番号 = :会社番号 AND DEP.管理者番号 = :管理者番号
【 c 】

-- 図4
CREATE VIEW 【 e 】 (祝日, 祝日名) AS SELECT 祝日, 祝日名 FROM 【 f 】
```

### ２　解答と解説

#### ２－１　正答
*   **b**: `BETWEEN :開始日 AND :終了日`
*   **c**: (図2) `ORDER BY 日付` / (図3) `ORDER BY DEP.部署番号, EMP.従業員番号`
*   **d**: `AND EMP.部署番号 = DEP.部署番号`
*   **e**: `V国民の祝日`
*   **f**: `T国民の祝日`

**解答根拠**
*   **b**: 問題文に「指定された期間内」という要件があり、日付の範囲を指定するには`BETWEEN`演算子が最も簡潔で適切です。`WHERE 祝日 >= :開始日 AND 祝日 <= :終了日` としても論理的には等価ですが、`BETWEEN`の方が可読性が高いです。
*   **c**: 問題文の「日付の昇順」「部署番号、従業員番号の昇順」という要件を満たすため、`ORDER BY`句でソート順を指定します。`UNION ALL`で複数の`SELECT`文を結合した場合、`ORDER BY`句は**最後に一度だけ**記述し、結果セット全体に適用します。
*   **d**: 従業員テーブル(EMP)と部署テーブル(DEP)を結合するための条件です。`会社番号`だけでは、ある会社の全従業員と全部署のデカルト積（直積）になってしまうため、両者を正しく関連付ける`部署番号`での結合条件が不可欠です。
*   **e, f**: 問題文に記載された命名規則「ビュー名は接頭語V」「実表名は接頭語T」に厳密に従います。このような規約の遵守は、実務でも試験でも非常に重要です。

#### ２－２　誤答パターン
*   **b**: `IN (:開始日, :終了日)`のような誤答。`IN`はリスト内の値との一致を見るため、期間の範囲指定には使えません。
*   **c**: `UNION ALL`の**前に**`ORDER BY`句を記述してしまう誤答。これでは最初の`SELECT`文の結果だけがソートされ、全体としては意図した順序になりません。
*   **d**: 結合条件の不足。`ON EMP.会社番号 = DEP.会社番号`だけで止めると、例えば従業員A（営業部所属）のレコードに対して、経理部や人事部など、会社内の全部署のレコードが結合されてしまい、全く意味のない大量のデータが生成されます。
*   **e, f**: 問題文の命名規則という**国語的な指示**を見落とすことによる失点。SQLの知識だけでなく、問題文を隅々まで注意深く読む能力が問われています。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「期間内」「昇順」「結合条件」「命名規則」といった、SQLを構成するための指示を問題文や図から一つずつ正確に抜き出します。
2.  **SQL構造読解**: 各SQL文の目的を把握します。
    *   図2: 2つのテーブルからデータを縦に結合(`UNION ALL`)する。
    *   図3: 2つのテーブルからデータを横に結合(`INNER JOIN`)する。
    *   図4: ビューを作成(`CREATE VIEW`)する。
3.  **キーワード識別**:
    *   「期間内」→`BETWEEN`
    *   「～の順」→`ORDER BY`
    *   「ビュー」「実表」→命名規則の確認
    *   「AとBを関連付ける」→`JOIN`の`ON`句で適切なキーを指定

### ３　技術知識体系

#### ３－１　必要知識項目
*   **UNION ALL演算子**: 複数の`SELECT`文の結果を**重複排除せず**に縦に連結します。`ORDER BY`は最後に記述します。
*   **BETWEEN演算子**: `値 BETWEEN 下限 AND 上限` の形で、値が指定範囲内（両端を含む）にあるかどうかを判定します。
*   **ORDER BY句**: 問い合わせ結果を指定した列でソート（並べ替え）します。`ASC`（昇順、デフォルト）と`DESC`（降順）が指定できます。
*   **CREATE VIEW文**: 複雑な`SELECT`文などを仮想的なテーブル（ビュー）としてデータベースに保存するDDL文です。
*   **デカルト積 (直積)**: 結合条件が不適切な場合に発生する、テーブル間の全行の組み合わせ。意図しない大量のレコードが生成され、パフォーマンスと結果の正確性に致命的な影響を与えます。

#### ３－２　関連概念の整理
*   **`ON`句と`WHERE`句の使い分け**: `INNER JOIN`では、テーブル間の**結合条件は`ON`句**に、結果セット全体に対する**絞り込み条件は`WHERE`句**に記述するのが、SQLの可読性と保守性を高めるためのベストプラクティスです。
*   **ビューのメリット**:
    1.  **複雑性の隠蔽**: 複雑な`JOIN`や集計処理をビューにまとめておくことで、利用者は単純な`SELECT * FROM V...`でデータを取得できます。
    2.  **セキュリティ**: 実テーブルの特定の列や行だけを公開するビューを作成することで、見せる必要のないデータを隠蔽できます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2で`UNION ALL`を`UNION`に変えると、どのような場合に結果が変わりますか？
*   **答**: 国民の祝日と会社の記念日が、日付も名前も完全に同じ場合に結果が変わります。
*   **解説**: `UNION`はその重複行を1つにまとめるため、結果は1行だけ表示されますが、`UNION ALL`では2行表示されます。

*   **問**: 図2の`ORDER BY`句で、`SELECT`句で定義した別名`日付`が使えるのはなぜですか？
*   **答**: SQLの論理的な評価順序において、`ORDER BY`句は`SELECT`句で列や別名が確定した**後**に評価されるためです。
*   **解説**: 評価順序は `FROM` -> `WHERE` -> `GROUP BY` -> `HAVING` -> `SELECT` -> `ORDER BY` となります。

*   **問**: 図3で部署に所属していない従業員も一覧に含めたい場合、`INNER JOIN`を何に変更すべきですか？
*   **答**: `LEFT JOIN`（または`LEFT OUTER JOIN`）に変更すべきです。
*   **解説**: `FROM 従業員 EMP LEFT JOIN 部署 DEP ...`とすることで、部署情報がない従業員も結果に残り、DEP側の列はNULLになります。

*   **問**: 図4で作成したビュー`V国民の祝日`に対して、データの`INSERT`や`UPDATE`は可能ですか？
*   **答**: 可能です。
*   **解説**: このビューは単一の実テーブルから導出され、集約関数や`DISTINCT`などを含まないため、一般的に更新可能です。更新すると、元の実テーブル`T国民の祝日`のデータが変更されます。

*   **問**: 図3の結合条件`【d】`を忘れた場合に発生する「デカルト積」の行数は、具体的にどう計算されますか？
*   **答**: (`WHERE`句で絞り込まれた後の)従業員テーブルの行数 × 部署テーブルの行数 になります。
*   **解説**: 例えば該当従業員が10人、部署が5つあれば、10 × 5 = 50行の無意味なデータが生成されます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「期間内」「～から～まで」 | `BETWEEN ... AND ...` |
| 「～順で出力」「ソート」 | `ORDER BY` |
| 「仮想表」「～として見せる」 | `CREATE VIEW` |
| テーブルAとテーブルBを関連付ける | `JOIN ... ON A.キー = B.キー` |
| 複数の結果をそのまま結合 | `UNION ALL` |

### ５　要約
*   複数の問い合わせ結果を縦に結合するには`UNION`/`UNION ALL`を、横に結合するには`JOIN`を使い分けます。
*   結果の並び順は文末の`ORDER BY`で制御し、`SELECT`句で付けた列の別名も利用できます。
*   `JOIN`では、正しい結合条件を`ON`句に記述しないと、意図しないデカルト積が発生し、致命的なエラーに繋がります。
*   問題文中の**命名規則**や**制約事項**などの細かい指示は、DDL（データ定義言語）やDCL（データ制御言語）に正確に反映させる必要があります。

---

## 令和5年秋期 午後 データベース

### １　問題提示
```sql
［令和5年］
設問３：ウィンドウ関数を使用し、倉庫コード・商品コードごとに、各年月日の6日前から当日までの平均在庫数と売上個数を集計するSQL文。
SELECT 年, 月, 日, 倉庫コード, 商品コード,
       AVG(在庫数) OVER (【 i 】) AS 平均在庫数,
       SUM(売上個数) OVER (【 i 】) AS 期間内売上個数
FROM 在庫推移状況
WINDOW 期間定義 AS (
    PARTITION BY 倉庫コード, 商品コード
    ORDER BY 年, 月, 日 ASC
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    【 j 】
)
```

### ２　解答と解説

#### ２－１　正答
*   **i**: `期間定義`
*   **j**: (空欄)

**解答根拠**
*   **i**: `WINDOW`句は、`OVER`句で繰り返し使用されるウィンドウの定義（パーティション分割、順序、フレーム範囲）に名前を付けるための機能です。`WINDOW 期間定義 AS (...)`と定義された仕様は、`OVER (期間定義)`のようにその名前で参照します。
*   **j**: `WINDOW`句の定義は `... ROWS BETWEEN 6 PRECEDING AND CURRENT ROW` で構文として完結しています。この後に続く句は標準SQLの構文上存在しないため、空欄となります。

#### ２－２　誤答パターン
*   **i**: `PARTITION BY 倉庫コード, 商品コード ORDER BY ...` のように、`WINDOW`句で定義した内容を`OVER`句に再度、直接書き込んでしまう誤答。SQLとしては誤りではありませんが、`WINDOW`句を定義した出題者の意図を全く汲み取れていない解答となります。
*   **j**: `GROUP BY` や `HAVING` など、他のSQL句を追記してしまう誤答。`WINDOW`句はそれ自体で完結した定義句であり、ウィンドウ関数と`GROUP BY`は併用されることはあっても、`WINDOW`句の定義内に他の句が入ることはありません。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「倉庫コード・商品コードごと」「6日前から当日まで（移動平均）」「平均」「合計」を抽出します。
2.  **SQL構造読解**: `OVER`句と`WINDOW`句があることから、ウィンドウ関数の問題であると即座に判断します。特に`WINDOW`句は、応用情報技術者試験では比較的新しい出題範囲ですが、その目的は「ウィンドウ定義の共通化・再利用」であることを理解しているかが鍵となります。
3.  **キーワード識別**:
    *   `WINDOW 期間定義 AS ...` → `OVER`句でこの名前(`期間定義`)を使う、という構文ルールを思い出す。
    *   「～ごと」→`PARTITION BY`
    *   「6日前から当日まで」→`ROWS BETWEEN 6 PRECEDING AND CURRENT ROW`（フレーム句）

### ３　技術知識体系

#### ３－１　必要知識項目
*   **ウィンドウ関数 (Window Function)**: `GROUP BY`と異なり、元の行を集約せずに行ごとに保持したまま、集計や順位付けを行う関数群です。`OVER`句を伴うのが特徴です。
*   **OVER句**: ウィンドウ関数が計算を行う対象範囲（ウィンドウ）を定義します。
    *   **`PARTITION BY`句**: どのグループ内で計算を行うかを指定します（例：商品ごと、部署ごと）。
    *   **`ORDER BY`句**: グループ内での行の順序を定義します。順位付け関数や、移動平均などのフレーム指定に必須です。
    *   **フレーム句 (`ROWS`/`RANGE` BETWEEN ...)**: グループ内のさらに詳細な計算範囲（例：現在行と前のN行）を指定します。
*   **WINDOW句**: `OVER`句で使うウィンドウ仕様に名前を付け、SQL文内での再利用を可能にします。これにより、同じ定義を何度も書く必要がなくなり、コードの可読性と保守性が向上します（DRY: Don't Repeat Yourselfの原則）。

#### ３－２　関連概念の整理
*   **ウィンドウ関数 vs 集約関数(GROUP BY)**:
    *   **集約関数**: `GROUP BY`句と共に使い、複数行を**1行に集約**して結果を返します。元の行の情報は失われます。
    *   **ウィンドウ関数**: `OVER`句と共に使い、各行に対して計算結果を付与します。結果の行数は**元のテーブルと変わりません**。明細と集計値を同時に見たい場合に非常に強力です。

| 機能 | GROUP BY + 集約関数 | ウィンドウ関数 |
|:---|:---|:---|
| **目的** | グループ全体の集計値を求める | 各行に関連する集計値や順位を求める |
| **結果行数** | グループ数まで減少 | 元の行数と同じ |
| **例** | 部門ごとの売上合計 | 社員ごとの給与と、その社員が所属する部門の平均給与を並べて表示 |

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: `PARTITION BY 倉庫コード, 商品コード` の役割を具体的に説明してください。
*   **答**: 全データを「倉庫コードと商品コードの組み合わせ」が同じグループに分割します。ウィンドウ関数は、この分割されたグループの**中だけで**計算を行います。
*   **解説**: 例えば、倉庫Aの商品Xのデータ群と、倉庫Bの商品Xのデータ群は、完全に独立した別のウィンドウとして扱われます。

*   **問**: フレーム句`ROWS BETWEEN 6 PRECEDING AND CURRENT ROW`の意味を説明してください。
*   **答**: 現在処理中の行（`CURRENT ROW`）と、それより（`ORDER BY`句の順序で）前に出現する6行（`6 PRECEDING`）の、合計最大7行を計算対象のフレーム（範囲）とすることを意味します。
*   **解説**: これが「移動平均」や「直近N日間の合計」を計算するための典型的なフレーム指定です。

*   **問**: `WINDOW`句を使う最大のメリットは何ですか？
*   **答**: 同じウィンドウ定義を`OVER`句に何度も書く必要がなくなり、SQLの記述量を減らし、可読性と保守性を大幅に向上させる点です。
*   **解説**: もし`WINDOW`句がなければ、`AVG(在庫数) OVER (PARTITION BY ...)`と`SUM(売上個数) OVER (PARTITION BY ...)`で、全く同じ長い`PARTITION BY ...`句を2回書くことになります。

*   **問**: このSQLを実行した結果、行数は元の`在庫推移状況`テーブルと比べてどうなりますか？
*   **答**: 変わりません。
*   **解説**: ウィンドウ関数は元の行を集約（グルーピング）しないため、結果の行数は`FROM`句のテーブルの行数と同じになります。各行に`平均在庫数`と`期間内売上個数`という新しい列が付与される形です。

*   **問**: フレーム句の`ROWS`と`RANGE`の違いは何ですか？
*   **答**: `ROWS`は物理的な行数を基準に範囲を決定するのに対し、`RANGE`は`ORDER BY`で指定した列の「値」を基準に範囲を決定します。
*   **解説**: 例えば、同じ日付のデータが複数ある場合、`ROWS`は厳密に行数を数えますが、`RANGE`は同じ日付のデータをすべて同じ仲間と見なして計算に含めます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「移動平均」「累積合計」「直近N日間」 | ウィンドウ関数 + `ORDER BY` + フレーム句 (`ROWS BETWEEN`) |
| 「～ごとのランキング」 | `RANK()`, `DENSE_RANK()`, `ROW_NUMBER()` + `PARTITION BY` |
| 複数のウィンドウ関数で同じ定義を繰り返し使用 | `WINDOW`句で名前を付けて共通化 |
| 明細行と集計値を同時に表示 | ウィンドウ関数 |

### ５　要約
*   明細行を維持したまま、各行に関連する集計値（移動平均、累積合計、グループ内比率など）を算出したい場合は、**ウィンドウ関数**が極めて有効です。
*   計算範囲は`OVER`句内の`PARTITION BY`（分割）、`ORDER BY`（順序）、**フレーム句**（範囲）で厳密に定義します。
*   同じウィンドウ仕様を複数回利用する場合は、`WINDOW`句で名前を付けて再利用することで、SQLを簡潔で保守しやすく保てます。

---

## 令和5年春期 午後 データベース

### １　問題提示
```sql
［令和5年］
-- 項番1
INSERT INTO 所属_役職_一時(従業員コード, 組織コード)
SELECT A.従業員コード, A.所属組織コード FROM 所属 A, 役職 B
WHERE TO_DATE(:集計年月日) 【 e 】 A.所属開始年月日 AND A.所属終了年月日
AND A.役職コード = B.役職コード AND 【 f 】

-- 項番2
INSERT INTO 月別個人目標_一時(従業員コード, KPIコード, 目標個人集計)
SELECT 【 g1 】, KPIコード, 【 g2 】 FROM 月別個人目標
WHERE 年月 【 g3 】 TO_DATE(:年度開始年月日) AND TO_DATE(:集計年月日)
GROUP BY 従業員コード, KPIコード

-- 項番3
INSERT INTO 日別個人実績_一時(従業員コード, KPIコード, 実績個人集計)
SELECT 従業員コード, KPIコード, SUM(日別実績値) FROM 日別個人実績
WHERE 年月日 【 g4 】 TO_DATE(:年度開始年月日) AND TO_DATE(:集計年月日)
【 g5 】

-- 項番4
INSERT INTO 【 h 】(組織コード, KPIコード, 目標組織集計, 実績組織集計, 対象従業員数)
SELECT A.組織コード, B.KPIコード, SUM(B.目標個人集計),
       SUM(COALESCE(C.実績個人集計, 0)), 【 i1 】
FROM 所属_役職_一時 A
【 i2 】 従業員ごと目標集計_一時 B ON A.従業員コード = B.従業員コード
【 i3 】 従業員ごと実績集計_一時 C ON B.従業員コード = C.従業員コード AND B.KPIコード = C.KPIコード
GROUP BY A.組織コード, B.KPIコード

-- 項番5
SELECT A.*, A.目標組織集計/A.対象従業員数, A.実績組織集計/A.対象従業員数
FROM 【 h 】 A ORDER BY A.組織コード, A.KPIコード
```
※注: g, iは複数箇所あるため、思考しやすいように番号を振りました。

### ２　解答と解説

#### ２－１　正答
*   **e**: `BETWEEN`
*   **f**: `B.役職名 <> '部長'`
*   **g**:
    *   **g1**: `従業員コード`
    *   **g2**: `SUM(月別目標値)`
    *   **g3**: `BETWEEN`
    *   **g4**: `BETWEEN`
    *   **g5**: `GROUP BY 従業員コード, KPIコード`
*   **h**: `組織ごとKPI集計_一時`
*   **i**:
    *   **i1**: `COUNT(DISTINCT A.従業員コード)`
    *   **i2**: `INNER JOIN`
    *   **i3**: `LEFT JOIN`

**解答根拠**
*   **e**: 「集計年月日」が「所属開始年月日」と「所属終了年月日」の**間**にある、という期間内判定のため`BETWEEN`が最適です。
*   **f**: 問題文に「部長を除く従業員を対象とする」と明記されているため、役職名が'部長'で**ない**ことを条件とする`<>`（不等号）が必要です。`!=`も同義です。
*   **g**:
    *   **g1, g2**: `GROUP BY 従業員コード, KPIコード`とあることから、集計単位である`従業員コード`を`SELECT`句に含め、集計値として`月別目標値`を`SUM`関数で合計する必要があります。
    *   **g3, g4**: 年度開始日から集計年月日までの期間を指定するため`BETWEEN`を使用します。
    *   **g5**: `SELECT`句に集約関数`SUM()`と非集約列(`従業員コード`, `KPIコード`)が混在するため、`GROUP BY`句で非集約列をすべて指定する必要があります。
*   **h**: 項番4の`INSERT`文の対象テーブル名です。続く項番5の`FROM`句で同じテーブルが使われていることから、`組織ごとKPI集計_一時`であると特定できます。
*   **i**:
    *   **i1**: 「対象従業員**数**」を求めるため`COUNT`関数を使います。一人の従業員が複数のKPIを持つ場合、単純に`COUNT(*)`や`COUNT(A.従業員コード)`では過大に数えてしまうため、**重複を除いて**従業員数を数える`COUNT(DISTINCT A.従業員コード)`が必要です。
    *   **i2**: 集計対象は目標を持つ従業員が前提なので、`所属_役職_一時`(A)と`従業員ごと目標集計_一時`(B)の両方に存在するデータのみを対象とする`INNER JOIN`が適切です。
    *   **i3**: 「実績は存在しない場合もある」という業務要件が想定されます（目標はあるが未実績など）。目標を持つ従業員は全員表示する必要があるため、目標テーブル(B)を主軸とし、実績テーブル(C)を`LEFT JOIN`（左外部結合）で結合します。

#### ２－２　誤答パターン
*   **f**: `=` や `IN` を使ってしまう誤答。「除く」という要件を `NOT IN` や `<>` で正しく表現できるかが問われます。
*   **i1**: `COUNT(*)`を選択する重大な誤答。これは結合・集計後の中間テーブルの行数を数えてしまい、KPIの種類の数を掛け合わせた、全く異なる値になります。「人数」「顧客数」など**ユニークな個体数**を数える場合は`COUNT(DISTINCT 列名)`を疑う癖をつけましょう。
*   **i2, i3**: `JOIN`の種別（INNER/LEFT/RIGHT/FULL）の使い分けが理解できていない誤答。`INNER JOIN`は「AかつB」、`LEFT JOIN`は「Aを基準にBを（あれば）付ける」という違いを明確に区別する必要があります。実績のない従業員が集計から漏れてしまう`INNER JOIN`は、ここでは不適切です。

#### ２－３　解答アプローチ
1.  **処理フローの理解**: 複数の`INSERT`文で一時テーブルを段階的に作成していく、バッチ処理のような流れを把握します。
    *   項番1: 対象従業員の抽出
    *   項番2,3: 目標と実績を個人ごとに集計
    *   項番4: 上記3つを結合して組織ごとに最終集計
    *   項番5: 最終結果の表示
2.  **要件抽出**: 問題文から「部長を除く」「集計期間」「実績がない場合もある」「従業員"数"」といった処理の条件や仕様を正確に読み取ります。
3.  **キーワード識別**:
    *   「～を除く」→ `<>` / `NOT IN`
    *   「期間」→ `BETWEEN`
    *   「～ごとに集計」→ `GROUP BY`と集約関数(`SUM`, `COUNT`)
    *   「実績がない場合も**含む**」→ `LEFT JOIN` と `COALESCE`
    *   「ユニークな人数」→ `COUNT(DISTINCT ...)`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **一時テーブル (Temporary Table)**: 複雑な集計処理を複数のステップに分割し、各ステップの結果を一時的に保存するためのテーブル。SQLの可読性を高め、デバッグを容易にします。`WITH`句（共通表式）も同様の目的で使われます。
*   **INSERT ... SELECT ...文**: `SELECT`文の実行結果を、別のテーブルに挿入する構文。データ移行や集計結果の保存に多用されます。
*   **LEFT JOIN (左外部結合)**: 左側のテーブルのすべての行を返し、右側のテーブルに一致する行がない場合は、右側の列をNULLとして返します。
*   **COALESCE関数**: 引数リストの中で最初に見つかった非NULL値を返します。`COALESCE(C.実績個人集計, 0)`は、`LEFT JOIN`の結果、実績がなくて`NULL`になった場合に`0`を返すために使われます。
*   **COUNT(DISTINCT 列名)**: 指定した列の、**重複を除いたユニークな値の個数**を数えます。

#### ３－２　関連概念の整理
*   **`INNER JOIN` vs `LEFT JOIN`**: この問題を解く上で最も重要な概念の一つです。
    *   `INNER JOIN`: 結合条件を満たす行が**両方のテーブルに存在する**ものだけを返す。
    *   `LEFT JOIN`: **左側のテーブルの行はすべて返し**、右側に一致する行があれば結合し、なければNULLをセットする。
    *   **使い分けの判断基準**: 「Aを持つBをリストアップしたい」なら`INNER JOIN`。「Aをすべてリストアップし、Bの情報もあれば付け加えたい」なら`LEFT JOIN`。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 項番4で実績テーブル(C)の結合に`LEFT JOIN`を使うのはなぜですか？
*   **答**: 目標は設定されているが、まだ実績が1件も登録されていない従業員も、集計対象から除外しないためです。
*   **解説**: もし`INNER JOIN`を使うと、実績のない従業員は結果から欠落してしまい、正しい組織目標の達成状況が把握できなくなります。

*   **問**: `COALESCE`関数はどのような場面で役立ちますか？
*   **答**: `NULL`になる可能性がある値を、計算（特に`SUM`などの集約）に含める前にデフォルト値（多くは0）に変換したい場面で役立ちます。
*   **解説**: `SUM(NULL)`は`NULL`を無視しますが、`SUM(1 + NULL)`の結果は`NULL`になります。意図しない`NULL`の伝播を防ぐためにも、`COALESCE`による事前処理は重要です。

*   **問**: なぜ従業員数を数えるのに`COUNT(DISTINCT A.従業員コード)`が必要なのですか？
*   **答**: 一人の従業員が複数のKPI（例：売上目標、訪問件数目標）を持つ場合、`GROUP BY A.組織コード, B.KPIコード`で集計すると、同じ従業員が複数の行に現れるためです。
*   **解説**: `DISTINCT`で重複する従業員コードを1つにまとめてから数えることで、正しい「頭数」を算出できます。

*   **問**: 項番1の`FROM 所属 A, 役職 B`という書き方は何ですか？
*   **答**: `INNER JOIN`の古いANSI-89形式の構文です。
*   **解説**: `FROM A, B WHERE A.id = B.id`は`FROM A INNER JOIN B ON A.id = B.id`と等価です。現代では結合条件と絞り込み条件を分離できる後者のANSI-92形式が推奨されます。

*   **問**: この一連の`INSERT`文で一時テーブルを使う目的は何ですか？
*   **答**: 複雑な集計処理を「従業員抽出」「個人目標集計」「個人実績集計」「組織別集計」という複数の単純なステップに分割するためです。
*   **解説**: これにより、各ステップでのデバッグが容易になり、SQL全体のロジックが理解しやすくなります。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～を除く」 | `WHERE 列 <> 値` / `WHERE 列 NOT IN (...)` |
| 「実績がない場合は0とする」 | `LEFT JOIN` + `COALESCE(列, 0)` |
| 「ユニークな～の数」「人数」 | `COUNT(DISTINCT 列)` |
| 「期間」 | `BETWEEN ... AND ...` |
| 「～ごとに合計する」 | `SUM(...)` + `GROUP BY ...` |

### ５　要約
*   複雑な集計処理は、一時テーブルや`WITH`句を使い**ステップを分割**することで、ロジックを単純化できます。
*   「Aを基準にBを結合するがBは無くてもよい」という要件には`LEFT JOIN`が不可欠です。`JOIN`の種類の選択は、集計結果の正確性を左右する重要な判断です。
*   集計処理において`NULL`値は`COALESCE`で適切に処理し、`COUNT`関数では`DISTINCT`の要否を「何を数えたいのか（行数か、ユニークな個体数か）」という観点から慎重に判断する必要があります。
---

## 令和4年秋期 午後 データベース

### １　問題提示
```sql
［令和4年］
-- 図2 表3のアクセス制御を設定するためのSQL文
GRANT 【 j 】 ON 契約 TO ADMIN

-- 図3 表4の料金プラン表を作成するためのSQL文
CREATE TABLE 料金プラン
(料金プランコード CHAR(8) NOT NULL,
 通信事業者コード 【 k 】,
 料金プラン名 VARCHAR(30) NOT NULL,
 基本料金 DECIMAL(5,0) NOT NULL,
 通話単価 DECIMAL(5,2) NOT NULL,
 通信単価 DECIMAL(5,4) NOT NULL,
 【 l 】,
 【 m 】(通信事業者コード) REFERENCES 通信事業者(通信事業者コード))
```

### ２　解答と解説

#### ２－１　正答
*   **j**: `SELECT, INSERT, UPDATE, DELETE`
*   **k**: `CHAR(4) NOT NULL`
*   **l**: `PRIMARY KEY (料金プランコード)`
*   **m**: `FOREIGN KEY`

**解答根拠**
*   **j**: 問題文の表3「アクセス制御」で、ADMINユーザに契約テーブルへの「参照、追加、更新、削除」の権限が付与されています。これらに対応するSQLの権限は、それぞれ`SELECT, INSERT, UPDATE, DELETE`です。`GRANT`文ではこれらをカンマ区切りで列挙します。
*   **k**: `通信事業者コード`は、`REFERENCES 通信事業者(通信事業者コード)`とあるように、`通信事業者`テーブルの主キーを参照する**外部キー**です。外部キーのデータ型と長さは、参照先の主キーのデータ型と長さに**一致させる**必要があります。問題のテーブル定義から`通信事業者`テーブルの主キーが`CHAR(4)`と読み取れるため、ここも`CHAR(4)`となります。また、関連が必須であるため`NOT NULL`制約も付与します。
*   **l**: `料金プラン`テーブルの行を一意に識別する主キーは`料金プランコード`です。主キー制約は`PRIMARY KEY (列名)`という構文で定義します。
*   **m**: 他のテーブル（親テーブル）の主キーを参照し、参照整合性を保証する制約は**外部キー制約**です。`FOREIGN KEY (自テーブルの列名) REFERENCES 親テーブル(親テーブルの主キー列名)`という構文で定義するため、キーワードとして`FOREIGN KEY`が必要です。

#### ２－２　誤答パターン
*   **j**: `ALL PRIVILEGES`と解答する誤答。全ての権限を付与するという意味ですが、問題文で権限が個別に明記されている場合は、それに合わせて具体的に記述するのが最も確実な解答です。
*   **k**: データ型や長さを参照先と一致させない誤答。例えば`VARCHAR(4)`などとすると、データ型が異なるため外部キー制約を設定できません。
*   **l**: `UNIQUE (料金プランコード)`と解答する誤答。`PRIMARY KEY`は`UNIQUE`と`NOT NULL`の両方の性質を併せ持ち、テーブルの行を代表する唯一のキーです。問題文の設計意図から主キーが適切です。
*   **m**: `REFERENCES`句があるので`FOREIGN KEY`は不要と勘違いする誤答。これは制約を定義するためのキーワードであり、省略できません（DBMSによっては列定義の横に書く場合に省略可能なケースもありますが、試験では基本構文を書くべきです）。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 表3の権限設定内容（誰に、どのテーブルの、どの操作を許可するか）を正確に読み取る。
    *   図3: 表4のテーブル定義内容（列名、データ型、主キー、外部キー）を正確に読み取る。
2.  **SQL構造読解**:
    *   図2: `GRANT`文（DCL: データ制御言語）の基本構文を理解していることが前提です。
    *   図3: `CREATE TABLE`文（DDL: データ定義言語）の基本構文を理解していることが前提です。
3.  **キーワード識別**:
    *   「権限」「アクセス制御」→ `GRANT`
    *   「テーブル作成」→ `CREATE TABLE`
    *   「主キー」「PK」→ `PRIMARY KEY`
    *   「他テーブルを参照」「FK」→ `FOREIGN KEY ... REFERENCES ...`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **DDL (Data Definition Language)**: `CREATE`, `ALTER`, `DROP`など、データベースオブジェクトを定義・変更・削除するための言語。
*   **DCL (Data Control Language)**: `GRANT`, `REVOKE`など、データへのアクセス権限を制御するための言語。
*   **制約 (Constraint)**: データ整合性を保つためのルール。
    *   **主キー制約 (PRIMARY KEY)**: テーブル内で各行を一意に識別するための列。`NULL`値は許されず、`UNIQUE`（一意）である必要があります。
    *   **外部キー制約 (FOREIGN KEY)**: あるテーブルの列の値を、別のテーブルの主キーの値に限定する制約。**参照整合性**を保証します。
    *   **NOT NULL制約**: 列に`NULL`値が入ることを禁止します。

#### ３－２　関連概念の整理
*   **参照整合性**: 外部キー制約によって保証される整合性の一つ。具体的には、「子テーブル（例：料金プラン）の外部キーの値は、必ず親テーブル（例：通信事業者）の主キーに存在する値でなければならない」というルールです。これにより、「存在しない通信事業者の料金プラン」といった矛盾したデータが登録されるのを防ぎます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: `GRANT`文の`ON`句と`TO`句の役割は何ですか？
*   **答**: `ON`句は権限を付与する対象のオブジェクト（テーブル名など）を指定し、`TO`句は権限を付与されるユーザやロールを指定します。

*   **問**: 外部キーの列と、それが参照する親テーブルの主キーの列で、一致している必要があるものは主に何ですか？
*   **答**: **データ型**と**長さ**です。
*   **解説**: これらが一致していないと、そもそもデータベースは両者を関連付けることができません。

*   **問**: もし【m】の外部キー制約がなければ、どのような問題が起こりえますか？
*   **答**: `通信事業者`テーブルに存在しない`通信事業者コード`（例: 'C999'）を、`料金プラン`テーブルに登録できてしまいます。
*   **解説**: これは「参照整合性の崩壊」と呼ばれ、データの不整合を引き起こす原因となります。

*   **問**: `DELETE`権限がないユーザが`DELETE FROM 契約;`を実行するとどうなりますか？
*   **答**: 「権限がありません (Permission denied)」という趣旨のエラーが発生し、処理は失敗します。

*   **問**: `DECIMAL(5,2)`というデータ型は何を意味しますか？
*   **答**: 全体で5桁、そのうち小数点以下が2桁の固定小数点数型を意味します。
*   **解説**: 例えば `123.45` のような値を格納できます。金額計算など、誤差が許されない場合に`FLOAT`などの浮動小数点数型より好んで使われます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/図表 | 対応するSQL構文/要素 |
| :--- | :--- |
| アクセス制御表、権限 | `GRANT [権限リスト] ON [オブジェクト] TO [ユーザ]` |
| テーブル定義書（PKマーク） | `PRIMARY KEY (列名)` |
| テーブル定義書（FKマークや他テーブルへの矢印） | `FOREIGN KEY (列名) REFERENCES 親テーブル(列名)` |
| 列のデータ型（外部キー） | 参照先の主キーのデータ型と一致させる |
| NOT NULL制約 | 必須項目（空欄を許さない） |

### ５　要約
*   `GRANT`文は、「誰に(`TO`)、どのオブジェクトの(`ON`)、どの操作を(`SELECT`, `INSERT`等)」許可するかを定義する、データベースセキュリティの基本です。
*   `CREATE TABLE`文では、各列のデータ型に加え、`PRIMARY KEY`や`FOREIGN KEY`といった**制約**を定義し、データの整合性をデータベース自身に保証させることが重要です。
*   外部キー（子）のデータ型は、それが参照する主キー（親）のデータ型と**必ず一致させる**必要があります。これはリレーショナルデータベースの基本ルールです。

---

## 令和4年春期 午後 データベース

### １　問題提示

```sql
［令和4年］
-- 図2 "同一会員1枚限りの獲得制限"を制約とするためのSQL文
【 d 】 クーポン明細 ADD CONSTRAINT クーポン明細_IX1
UNIQUE(クーポンコード, 獲得会員コード, 獲得制限_1枚限り)

-- 図4 ロックなし方式のSQL文
INSERT INTO クーポン明細(クーポンコード, クーポン発行連番, 獲得会員コード, 獲得制限_1枚限り)
WITH 発行済枚数取得 AS (SELECT COALESCE(MAX(【 e 】), 0) AS 発行済枚数
    FROM クーポン明細 WHERE クーポンコード = :クーポンコード)
SELECT :クーポンコード,
       (SELECT 発行済枚数 + 1 FROM 発行済枚数取得 WHERE
          (SELECT 発行済枚数 FROM 発行済枚数取得) < 発行上限枚数),
       :会員コード, 獲得制限_1枚限り
FROM クーポン管理 WHERE クーポンコード = :クーポンコード

-- 図5 ロックあり方式のSQL文
UPDATE クーポン管理 【 f 】
WHERE クーポンコード = :クーポンコード AND 発行済枚数 < 【 g 】;
INSERT INTO クーポン明細 (クーポンコード, クーポン発行連番, 獲得会員コード, 獲得制限_1枚限り)
SELECT :クーポンコード, 発行済枚数, :会員コード, 獲得制限_1枚限り
FROM クーポン管理 WHERE クーポンコード = :クーポンコード;
```

### ２　解答と解説

#### ２－１　正答
*   **d**: `ALTER TABLE`
*   **e**: `クーポン発行連番`
*   **f**: `SET 発行済枚数 = 発行済枚数 + 1`
*   **g**: `発行上限枚数`

**解答根拠**
*   **d**: **既存のテーブル**に制約や列を追加・変更・削除するには`ALTER TABLE`文を使用します。`ALTER TABLE テーブル名 ADD CONSTRAINT 制約名 制約定義`が、制約を追加する際の基本構文です。
*   **e**: クーポンの次の発行連番を決定するために、現在の**最大の発行連番**を取得する必要があります。`MAX()`関数に渡すべき列は`クーポン発行連番`です。`COALESCE(..., 0)`は、まだ1枚も発行されていない場合に`MAX()`が`NULL`を返すため、それを`0`に変換する必須の処理です。
*   **f**: `UPDATE`文で`発行済枚数`カウンタを1増やす（インクリメントする）処理です。`SET 更新対象列 = 現在の値 + 1`という構文になります。
*   **g**: クーポンが発行上限枚数に達していないことを確認する`WHERE`句の条件です。`発行済枚数`が`発行上限枚数`**より小さい**（`<`）場合にのみ`UPDATE`が実行されるようにします。

#### ２－２　誤答パターン
*   **d**: `CREATE CONSTRAINT`のような存在しない構文や、`CREATE UNIQUE INDEX`と混同する誤答。一意性制約はデータベース内部で一意なインデックスを利用して実現されますが、制約として定義するDDLは`ALTER TABLE ... ADD CONSTRAINT`です。
*   **e**: `COUNT(*)`を選択する誤答。これも発行枚数になりますが、ここでは「次の連番を生成する」というロジックの流れから、`MAX(クーポン発行連番)`を取得して`+1`するのが最も直接的で、出題の意図に沿っています。
*   **f**: `SET 発行済枚数 = (SELECT COUNT(*) FROM クーポン明細 ...)`のような、冗長で非効率な処理を書く誤答。カウンタテーブルがある場合は、単純なインクリメントで済ませるのがセオリーです。
*   **g**: `<= 発行上限枚数`や`= 発行上限枚数`のような不等号を間違える誤答。`発行済枚数 < 発行上限枚数`の条件が真のときに発行可能、というロジックを正確に理解する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「制約の**追加**」→ `ALTER TABLE`
    *   図4: 「ロックなし」でのクーポン発行処理（上限チェックと**連番生成**）
    *   図5: 「ロックあり」でのクーポン発行処理（上限チェックと**カウンタ更新**）
2.  **SQL構造/処理フロー読解**:
    *   図4: `WITH`句で最大連番を取得し、主`SELECT`文で上限チェックと`+1`した連番の生成を行っていることを理解する。
    *   図5: `UPDATE`でカウンタを更新・行ロック確保し、その後に`INSERT`する2段階の処理。トランザクション内での実行が前提。
3.  **キーワード識別**:
    *   「制約を追加」→ `ALTER TABLE`
    *   「最大値」→ `MAX`
    *   「更新」→ `UPDATE SET`
    *   「上限に達していない」→ `WHERE ... < 上限値`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **ALTER TABLE文**: 既存のテーブル定義を変更するためのDDL文。
*   **一意性制約 (UNIQUE Constraint)**: 指定した列（または列の組）の値が、テーブル内で重複しないことを保証する制約。
*   **排他制御 (Locking)**: 複数トランザクションからの同時アクセスによってデータ不整合（例：同じクーポンが2枚発行される）が起きるのを防ぐ仕組み。図5の`UPDATE`文は、対象行をロック（排他ロック）することで、他のトランザクションによる同じクーポンの同時発行処理をブロックします。
*   **競合状態 (Race Condition)**: 複数のプロセス/スレッドが共有リソース（ここではクーポン発行枚数）に同時にアクセスし、処理の実行タイミングによって結果が変わってしまう状態。図4のロックなし方式は、この競合状態に陥るリスクがあります。

#### ３－２　関連概念の整理
*   **ロックなし方式 vs ロックあり方式（楽観ロック vs 悲観ロック）**:
    *   **ロックなし方式（図4）**: 「まあ、めったに衝突しないだろう」と楽観的に考え、まず処理を進め、最後の`INSERT`で一意性制約に頼って衝突を検知する方式。楽観ロックの一種と見なせます。衝突が多いと無駄な処理が増えます。
    *   **ロックあり方式（図5）**: 「衝突が起こるかもしれない」と悲観的に考え、最初に`UPDATE`文（または`SELECT ... FOR UPDATE`）で対象リソースをロックしてから処理を進める方式。悲観ロックと呼ばれます。堅牢性が高いですが、ロックによる待ち時間が発生する可能性があります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図4のロックなし方式で、同時に2つのリクエストが来た場合に何が起こりえますか？
*   **答**: 両方が同じ最大連番（例えば`100`）を読み取り、両方とも次の連番`101`で`INSERT`を試みます。先にDBに到達した方は成功しますが、後から来た方は一意性制約違反でエラーになります。
*   **解説**: ユーザにはエラーが返り、クーポンは獲得できません。これが競合状態（レースコンディション）の結果です。

*   **問**: 図5のロックあり方式が、図4の方式より堅牢である理由はなぜですか？
*   **答**: 先に実行されたトランザクションが`UPDATE`文で`クーポン管理`テーブルの該当行に**排他ロック**を掛けるためです。
*   **解説**: 後から来たトランザクションは、最初のトランザクションがコミットまたはロールバックしてロックを解放するまで`UPDATE`文で待たされるため、カウンタの値を二重に読み込むことがなく、連番の重複が根本的に防がれます。

*   **問**: 図5の`UPDATE`文と`INSERT`文は、なぜ一つのトランザクションとして実行する必要があるのですか？
*   **答**: `UPDATE`でカウンタを増やした後に、何らかの理由で`INSERT`が失敗した場合、処理全体を`ROLLBACK`してカウンタを元の値に戻す必要があるからです。
*   **解説**: これをしないと、カウンタだけが増えて明細が存在しない「幽霊クーポン」が生まれたことになり、データに不整合が生じます。この一連の処理の不可分性（Atomicity）を保証するのがトランザクションの役割です。

*   **問**: 図4の`WITH`句で`COALESCE`を使わないと、どのような問題が起こりえますか？
*   **答**: まだ誰も獲得していないクーポンの場合、`MAX`関数が`NULL`を返し、`NULL + 1`の計算結果も`NULL`となってしまい、最初の1枚が発行できなくなります。

*   **問**: 図2の`UNIQUE`制約が3つの列で構成されている複合ユニーク制約である理由は何ですか？
*   **答**: 問題文の「**同一会員**1枚限りの獲得制限」という要件をデータベースレベルで保証するためです。
*   **解説**: これにより、「あるクーポン(`クーポンコード`)を、ある会員(`獲得会員コード`)が、1枚限り(`獲得制限_1枚限り`が特定の値の時)で獲得できる」というルールが強制されます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 既存テーブルに制約を追加 | `ALTER TABLE ... ADD CONSTRAINT` |
| 「まだ一件もない」場合の初期値考慮 | `COALESCE(集約関数, デフォルト値)` |
| カウンタを1増やす | `UPDATE ... SET 列 = 列 + 1` |
| 上限に達していないか確認 | `WHERE 列 < 上限値` |
| 同時実行時のデータ整合性確保（堅牢な方式） | トランザクションとロック (`UPDATE`や`SELECT FOR UPDATE`) |

### ５　要約
*   既存テーブルの構造変更には`ALTER TABLE`文を使用します。
*   クーポン発行のような同時実行制御が重要な処理では、ロックなし方式のリスク（競合状態）と、ロックあり方式の堅牢性（排他ロック）を理解することが重要です。
*   `UPDATE`文によるカウンタ更新は、行ロックを利用した排他制御の典型的なパターンであり、トランザクションと組み合わせることでデータの整合性を保証します。

---

## 令和3年秋期 午後 データベース

### １　問題提示

```sql
［令和3年］
-- 表2 手順2
SELECT 【 d 】
FROM 一括購入割当
WHERE 一括購入ID = :一括購入ID

-- 表2 手順4
INSERT INTO 一括購入割当
(一括購入ID, 社員ID, 企業ID)
【 f 】

-- 図2 閲覧可能な重複を含まない書籍の一覧を取得するSQL文
SELECT sk.【 c 】
FROM 社員書籍購入 sk
WHERE sk.企業ID = :企業ID AND sk.社員ID = :社員ID
【 g 】
SELECT ik.【 c 】
FROM 一括購入 ik
INNER JOIN 一括購入割当 iw
【 h 】
WHERE ik.企業ID = :企業ID AND iw.社員ID = :社員ID
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `書籍ID`
*   **d**: `COUNT(*)`
*   **f**: `VALUES (:一括購入ID, :社員ID, :企業ID)`
*   **g**: `UNION`
*   **h**: `ON ik.一括購入ID = iw.一括購入ID`

**解答根拠**
*   **c**: 図2のSQLは「書籍の一覧を取得」することが目的です。`社員書籍購入`テーブルからも`一括購入`テーブルからも、取得すべきは書籍を一意に識別する`書籍ID`です。また、`【g】`で2つの`SELECT`文を結合するため、両者の`SELECT`句の列の数、型、意味合いは一致している必要があります。
*   **d**: 表2の手順2は「割当済数量を取得」する処理です。`一括購入割当`テーブルは、1行が1冊の割り当てを表す設計になっていると考えられます。したがって、指定された`一括購入ID`を持つ**行の数**を数えることで、割当済数量を求められます。行数を数えるには`COUNT(*)`が最も一般的です。
*   **f**: `INSERT`文でアプリケーションから渡された具体的な値を挿入するための句は`VALUES`句です。`INSERT INTO テーブル (列リスト) VALUES (値リスト)`が基本構文となります。
*   **g**: 「**重複を含まない**書籍の一覧」という要件が鍵です。`UNION`は2つの`SELECT`文の結果を結合し、その際に**自動的に重複行を排除**します。`UNION ALL`は重複を排除しないため、この要件には合いません。
*   **h**: `一括購入`(ik)テーブルと`一括購入割当`(iw)テーブルを結合するための条件です。ER図などから、両テーブルは`一括購入ID`を共通のキーとして関連していることが読み取れます。`JOIN`の結合条件は`ON`句で指定します。

#### ２－２　誤答パターン
*   **d**: `SUM(数量)`のような誤答。このテーブルには「数量」という列はなく、1行が1つの割り当てインスタンスを表すため、行数を数えるのが正解です。
*   **f**: `SELECT :一括購入ID, :社員ID, :企業ID`のような`INSERT SELECT`構文と混同する誤答。`INSERT SELECT`はテーブルからデータをコピーする場合に使い、ここでは固定値を挿入するため`VALUES`句が適切です。
*   **g**: `UNION ALL`を選択する重大な誤答。これでは、同じ書籍を個人購入と一括購入割当の両方で所有している場合に、結果が重複して表示され、要件を満たせません。
*   **h**: 結合キーを間違える（例: `社員ID`で結合しようとする）、`WHERE`句で結合条件を書く（古いANSI-89形式）などの誤答。現代のSQLでは`JOIN`には`ON`句で結合条件を明記するのが標準的です。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   表2: 「割当済**数量**の取得」→ `COUNT`。「**値を挿入**」→ `INSERT ... VALUES`。
    *   図2: 「**重複を含まない**一覧」→ `UNION`。「2つのテーブルを**関連付ける**」→ `JOIN ON`。
2.  **SQL構造読解**:
    *   表2: `SELECT`と`INSERT`という個別のDML文の役割を理解します。
    *   図2: 2つの`SELECT`文がセット演算子（`【g】`）で結合されている構造を把握します。前半は個人購入、後半は一括購入割当から書籍IDを取得していると推測します。
3.  **キーワード識別**:
    *   「数量」「件数」→ `COUNT(*)`
    *   「挿入」→ `INSERT ... VALUES`
    *   「重複を含まない」「まとめる」→ `UNION`
    *   「結合」「関連付ける」→ `JOIN ON`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **COUNT関数**: 行の数を数える集約関数。`COUNT(*)`は全ての行を、`COUNT(列名)`はその列が`NULL`でない行を数えます。主キーが`NOT NULL`であれば`COUNT(主キー)`も`COUNT(*)`と同じ結果になりますが、意図の明確さから`COUNT(*)`が好まれます。
*   **INSERT ... VALUES文**: テーブルに1行または複数行の新しいデータを挿入する基本的なDML文です。
*   **UNION演算子**: 2つ以上の`SELECT`文の結果セットを結合し、**重複する行を排除**します。
*   **INNER JOIN**: 2つのテーブルを内部結合します。結合条件は`ON`句で指定します。

#### ３－２　関連概念の整理
*   **`UNION` vs `UNION ALL`**: 試験で頻出する重要な違いです。
    *   **UNION**: 結果を結合し、**重複を排除**します。内部的にソート処理などが発生するため、`UNION ALL`より低速になる場合があります。
    *   **UNION ALL**: 結果を結合しますが、**重複を排除しません**。単純に連結するだけなので高速です。
    *   **使い分け**: 要件が「重複を許さない」場合は`UNION`が必須。重複がないことが保証されている、または重複しても問題ない場合は`UNION ALL`を選択します。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2の後半で`一括購入`テーブルと`一括購入割当`テーブルを`JOIN`する理由は何ですか？
*   **答**: `一括購入割当`テーブルには`社員ID`や`一括購入ID`はありますが、`書籍ID`がありません。`書籍ID`の情報を持つ`一括購入`テーブルと`一括購入ID`で結合することで、その社員に割り当てられた書籍の`書籍ID`を特定するためです。

*   **問**: もし図2の要件が「閲覧可能な書籍のリスト（重複を許す）」だったら、【g】はどう変わりますか？
*   **答**: `UNION ALL`になります。
*   **解説**: 重複排除が不要な場合は、パフォーマンス上有利な`UNION ALL`を使用するのがセオリーです。

*   **問**: 表2の手順1, 2, 4を含む一連の処理は、なぜ単一のトランザクションで実行すべきなのですか？
*   **答**: 手順1,2で在庫（購入上限数）をチェックし、手順4で割り当てを行いますが、このチェックと割り当ての間に別のユーザが割り当て処理を完了させてしまうと、上限を超えて割り当ててしまう可能性があるからです。
*   **解説**: トランザクションで一連の処理を囲むことで、他の処理から隔離され、処理の原子性（all or nothing）が保証され、データの整合性が保たれます。

*   **問**: 図2の`UNION`で結合される2つの`SELECT`文で、取得する列のデータ型が異なっていたらどうなりますか？
*   **答**: データ型不一致のエラーが発生し、SQLは実行できません。
*   **解説**: `UNION`で結合する`SELECT`文は、列の数と、対応する列のデータ型が（暗黙的に変換可能であるか、完全に）一致している必要があります。

*   **問**: 表2 手順2で`WHERE 一括購入ID = :一括購入ID`にインデックスがない場合、どのようなパフォーマンス上の問題が考えられますか？
*   **答**: テーブルフルスキャンが発生します。
*   **解説**: `一括購入割当`テーブルの全レコードを先頭から順にスキャンして条件に合うものを探すため、データ量が増えるにつれて性能が著しく劣化します。`一括購入ID`にインデックスがあれば、高速に目的の行を探し出すことができます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「件数」「数量」「～の数」 | `COUNT(*)` |
| データを1件挿入 | `INSERT INTO ... VALUES (...)` |
| 「重複を除いて一覧にする」 | `UNION` |
| 2つのテーブルを関連付ける | `INNER JOIN ... ON ...` |
| 「上限チェックして更新」などの一連の処理 | トランザクション |

### ５　要約
*   行数を数えるには`COUNT(*)`、値を直接挿入するには`INSERT ... VALUES`という基本的なDMLを使い分けます。
*   「重複を除いて複数の結果をまとめる」という要件には`UNION`が最適です。`UNION ALL`との違いは頻出なので必ず押さえましょう。
*   必要な情報を得るために、複数のテーブルを適切な結合キーで`JOIN`する能力が求められます。ER図やテーブル定義からテーブル間の関連を正確に読み取ることが重要です。

---

## 令和3年春期 午後 データベース

### １　問題提示

```sql
［令和3年］
SELECT R.貸出予定年月日, R.駐車場ID, R.車種ID, R.会員ID, COUNT(*) AS 遅延返却発生件数
FROM (SELECT Y.貸出予約コード, Y.駐車場ID, Y.車種ID, Y.会員ID,
             TIMESTAMP_TO_DATE(Y.貸出予定時刻) AS 貸出予定年月日, Y.返却予定時刻 FROM 貸出予約 Y) R
【 f 】 J.貸出予約コード
WHERE R.返却予定時刻 < J.返却実績時刻
【 g 】
```

### ２　解答と解説

#### ２－１　正答
*   **f**: `INNER JOIN 貸出実績 J ON R.貸出予約コード =`
*   **g**: `GROUP BY R.貸出予定年月日, R.駐車場ID, R.車種ID, R.会員ID`

**解答根拠**
*   **f**: このSQLは「遅延返却」を分析するため、`貸出予約`情報（副問合せR）と`貸出実績`情報（J）を突き合わせる必要があります。両テーブルに共通する`貸出予約コード`をキーとして`INNER JOIN`で結合するのが適切です。返却実績のない予約（キャンセルなど）は遅延の判定ができないため、実績のあるものに絞り込む`INNER JOIN`で問題ありません。
*   **g**: `SELECT`句に集約関数`COUNT(*)`と、それ以外の非集約列（`R.貸出予定年月日`など）が混在しています。この場合、どの単位で集計（`COUNT`）するのかを明示するために`GROUP BY`句が**必須**です。集約の単位は、`SELECT`句にリストされている非集約列のすべて、つまり「貸出予定年月日、駐車場ID、車種ID、会員ID」ごとになります。

#### ２－２　誤答パターン
*   **f**: `LEFT JOIN`を選択する誤答。返却実績のない予約は`WHERE R.返却予定時刻 < J.返却実績時刻`の条件で`J.返却実績時刻`が`NULL`になるため結局除外され、`INNER JOIN`と結果は同じになりますが、意図が明確なのは`INNER JOIN`です。また、結合条件`ON R.貸出予約コード = J.貸出予約コード`の記述漏れも頻出します。
*   **g**: `GROUP BY`句に含める列が不足している誤答。例えば`GROUP BY R.貸出予定年月日`だけだと、「駐車場IDや車種IDなどはどの値を表示すればいいのか分からない」とデータベースが判断し、エラーになります。`SELECT`句にある非集約列は、原則としてすべて`GROUP BY`句に含める必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「貸出予約情報と貸出実績情報を結合」「遅延返却（返却予定時刻 < 返却実績時刻）」「貸出予定日や駐車場などでグループ化して件数を集計」という一連の処理を読み取ります。
2.  **SQL構造読解**: `FROM`句に副問合せ（インラインビュー）が使われていることを理解します。`SELECT`句に`COUNT(*)`という集約関数があることから、これは集約処理を行うSQLだと判断し、`GROUP BY`句が必須であると推測します。
3.  **キーワード識別**:
    *   「結合」「突き合わせ」→ `INNER JOIN`
    *   「～ごとに集計」→ `GROUP BY`
    *   「件数」→ `COUNT(*)`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **副問合せ (Subquery)**: SQL文の中に埋め込まれた`SELECT`文。
    *   **インラインビュー (導出表)**: `FROM`句で使う副問合せ。あたかも一時的なテーブル（この問題の`R`）のように扱うことができます。`WITH`句と似た役割を果たします。
*   **GROUP BY句**: 指定した列の値が同じ行をグループにまとめ、集約関数を適用するために使用します。
*   **集約関数 (Aggregate Function)**: `COUNT`, `SUM`, `AVG`, `MAX`, `MIN`など、複数行から単一の値を計算する関数。
*   **テーブルの別名 (Alias)**: `貸出実績 J`のようにテーブルに短い別名を付けることで、SQL文の記述を簡潔にし、可読性を高めます。

#### ３－２　関連概念の整理
*   **`GROUP BY`句の厳密なルール**: 標準SQLや最近のDBMSでは、`SELECT`句に記述できる非集約列は、`GROUP BY`句で指定された列、または関数従属（主キーが決まれば一意に決まる列など）にある列に限定されます。試験では基本的に「**`SELECT`句にある非集約列は、すべて`GROUP BY`句に含める**」と覚えておけば間違いありません。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: `FROM`句で副問合せ（インラインビュー`R`）を使っている主な理由は何ですか？
*   **答**: 元の`貸出予約`テーブルにある`貸出予定時刻`（タイムスタンプ型）から、`TIMESTAMP_TO_DATE`関数を使って日付部分だけを`貸出予定年月日`として事前に抽出し、主問い合わせの`GROUP BY`や`SELECT`句で扱いやすくするためです。
*   **解説**: このように、主問い合わせをシンプルにするために、`FROM`句のインラインビューや`WITH`句でデータの前処理を行うのは常套手段です。

*   **問**: `WHERE R.返却予定時刻 < J.返却実績時刻` は何を実現していますか？
*   **答**: 返却実績時刻が、予定されていた返却時刻を過ぎているレコード、つまり「遅延返却」となった貸出のみを抽出しています。

*   **問**: もし【g】の`GROUP BY`句を書き忘れると、どのようなエラーが発生しますか？
*   **答**: DBMSによりますが、「`R.貸出予定年月日`は集約関数の中にもGROUP BY句の中にもありません」といった趣旨の構文エラーが発生します。

*   **問**: `TIMESTAMP_TO_DATE`とはどのような関数だと推測できますか？
*   **答**: `TIMESTAMP`型や`DATETIME`型のような時刻情報を含むデータから、日付部分だけを抽出して`DATE`型に変換する関数だと推測できます。

*   **問**: 遅延ではなく、予定通りに返却された件数を集計するには`WHERE`句をどう変更しますか？
*   **答**: `WHERE R.返却予定時刻 >= J.返却実績時刻` に変更します。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～ごとに件数を集計」 | `SELECT ..., COUNT(*)` + `GROUP BY ...` |
| 2つの情報を突き合わせる | `INNER JOIN ON ...` |
| 絞り込み条件（遅延、など） | `WHERE` |
| 事前にデータを加工・整形してから使う | `FROM`句でのインラインビュー / `WITH`句 |

### ５　要約
*   集約関数(`COUNT`等)と非集約列を`SELECT`句で併用する場合、`GROUP BY`句にすべての非集約列を指定することは必須のルールです。
*   `FROM`句で副問合せ（インラインビュー）を利用することで、元のテーブルを加工した結果を一時的なテーブルとして扱うことができ、複雑なSQLを構造化できます。
*   `JOIN`でテーブルを結合し、`WHERE`で条件を絞り込み、`GROUP BY`で集約するという、SQLの基本的な処理の流れを確実に理解することが重要です。

---

（令和2年は春期試験が中止のため秋期のみです）
---
## 令和2年秋期 午後 データベース

### １　問題提示
```sql
［令和2年］
-- 図3 部屋の空き状況の確認を行うためのSQL文
SELECT 施設ID, 部屋種別ID, COUNT(*) FROM 部屋
WHERE 【 c 】 (
    SELECT * FROM 予約明細 WHERE 予約明細.部屋ID = 部屋.部屋ID
    AND 予約明細.宿泊日 >= :チェックイン日付 AND 予約明細.宿泊日 < :チェックアウト日付
)
AND 施設ID = :施設ID AND 部屋種別ID = :部屋種別ID
GROUP BY 施設ID, 部屋種別ID
HAVING 【 d 】 >= :部屋数

-- 図6 削除するレコードを抽出するSQL文
SELECT t1.予約ID, t1.予約明細ID, t1.部屋ID, t1.宿泊日 FROM 予約明細 t1
WHERE t1.予約ID > (SELECT 【 h 】 FROM 予約明細 t2
    WHERE 【 i 】 AND 【 j 】)
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `NOT EXISTS`
*   **d**: `COUNT(*)`
*   **h**: `MIN(t2.予約ID)`
*   **i**: `t2.部屋ID = t1.部屋ID`
*   **j**: `t2.宿泊日 = t1.宿泊日`

**解答根拠**
*   **c**: 「部屋の**空き**状況」を確認するには、指定した期間に**予約が存在しない**部屋を抽出する必要があります。`NOT EXISTS (副問合せ)`は、副問合せの結果が0件の場合に真となるため、「予約が存在しない」という条件を表現するのに最適です。副問合せ内では、外側の`部屋`テーブルと内側の`予約明細`テーブルを`部屋ID`で関連付けています（これを**相関副問合せ**と呼びます）。
*   **d**: `HAVING`句は`GROUP BY`で集約した結果に対して条件を指定する句です。ここでは、空いている部屋の**数**（`GROUP BY`後の`COUNT(*)`）が、要求された部屋数（`:部屋数`）以上であることを条件としています。
*   **h, i, j**: このSQLは「重複して挿入されたレコードのうち、**最初に挿入されたもの以外**を抽出する」というロジックです。
    *   まず`【i】`と`【j】`で、外側の行(`t1`)と同じ`部屋ID`と`宿泊日`を持つレコード群を内側の副問合せ(`t2`)で特定します（相関）。
    *   次に`【h】`で、その重複レコード群の中から`予約ID`が**最小**のもの（`MIN(t2.予約ID)`）を見つけます。これが「最初に挿-入されたレコード」に相当します。
    *   最終的に、外側の`t1.予約ID`が、その最小IDよりも大きいレコード（`>`）が削除対象となります。

#### ２－２　誤答パターン
*   **c**: `NOT IN`を選択する誤答。副問合せが`NULL`を返す可能性がある場合、`NOT IN`は意図しない結果（常に偽）になるため、`NOT EXISTS`の方が堅牢で推奨されます。このケースでは大きな問題になりませんが、`EXISTS`/`NOT EXISTS`の利用を習慣づけるのが得策です。
*   **d**: `HAVING 部屋数 >= :部屋数`のような誤答。`HAVING`句には集約関数または`GROUP BY`句で指定した列しか通常は使用できません。集約結果である`COUNT(*)`を比較対象にする必要があります。
*   **h**: `MAX(t2.予約ID)`を選ぶ誤答。これでは重複したレコード群の最後の1件**以外が全て**削除対象となってしまい、1件だけ残すという要件と逆になります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図3: 「予約が**存在しない**部屋」の「**数を数え**」「要求数以上」のものを探す。
    *   図6: 「`部屋ID`と`宿泊日`で**重複**」したレコードのうち、「**最初に挿入されたもの以外**」を削除対象として探す。
2.  **SQL構造読解**:
    *   図3: `WHERE`句内の(相関)副問合せ、そして`GROUP BY`と`HAVING`句の連携という、集計SQLの王道パターンを理解する。
    *   図6: 自己相関（`t1`と`t2`で同じテーブルを参照）を使い、「同じグループ内の最小値より大きいもの」を抽出するという、高度だが頻出のテクニックを読み解く。
3.  **キーワード識別**:
    *   「存在しない」→`NOT EXISTS`
    *   「集約結果に対する条件」→`HAVING`
    *   「グループ内の最小値」→`MIN()`
    *   「同じ～のグループ」→相関副問合せの結合条件 `t1.列 = t2.列`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **相関副問合せ (Correlated Subquery)**: 内側の副問合せが、外側の主問合せのテーブルの列を参照する副問合せ。外側の問合せの行が1行処理されるたびに、それに対応する値を使って副問合せが実行されます。
*   **EXISTS / NOT EXISTS演算子**: 副問合せが1行以上の結果を返すかどうかを判定します。`EXISTS`は1行でも返れば真、`NOT EXISTS`は1行も返さなければ真となります。行の**存在有無**だけをチェックするため、`SELECT *`でも`SELECT 1`でも結果は同じです。
*   **HAVING句**: `GROUP BY`でグループ化された結果に対して、条件を指定してさらに絞り込むために使用します。
*   **自己相関 (Self-Correlation)**: 同じテーブルに`t1`, `t2`のように異なる別名を付け、自分自身と比較を行うテクニック。重複削除や階層構造の問い合わせなどで利用されます。

#### ３－２　関連概念の整理
*   **`WHERE` vs `HAVING`**: この違いも試験で極めて重要です。
    *   **WHERE**: `GROUP BY`による集約の**前**に、個々の行に対して適用される条件。
    *   **HAVING**: `GROUP BY`による集約の**後**に、グループ（集約結果）に対して適用される条件。`SUM()`や`COUNT()`などの集約関数を用いた条件は`HAVING`句にしか書けません。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図3で`NOT EXISTS`の代わりに`LEFT JOIN`を使って同じ結果を得るにはどうすればよいですか？
*   **答**: `部屋`テーブルを左側に、指定期間の`予約明細`を右側にして`LEFT JOIN`し、`WHERE 予約明細.部屋ID IS NULL`で絞り込みます。
*   **解説**: 予約が存在しない部屋は、`LEFT JOIN`の結果、`予約明細`テーブル側の列がすべて`NULL`になることを利用します。

*   **問**: 図6のロジックは、ウィンドウ関数`ROW_NUMBER()`を使っても実現できますか？
*   **答**: はい、できます。
*   **解説**: `WITH NumberedReservations AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY 部屋ID, 宿泊日 ORDER BY 予約ID) as rn FROM 予約明細) SELECT * FROM NumberedReservations WHERE rn > 1;` のように書けます。`PARTITION BY`で重複グループを定義し、その中で`予約ID`順に連番を振り、2番目以降を削除対象とします。こちらの方がモダンで可読性が高い場合が多いです。

*   **問**: 図6の`t1`と`t2`は何を指していますか？
*   **答**: どちらも同じ`予約明細`テーブルを指していますが、`t1`は主問合せで処理対象となっている行（外側）、`t2`は副問合せ内で比較対象を探すための行（内側）という役割分担をしています。

*   **問**: 図3の`HAVING`句を`WHERE COUNT(*) >= :部屋数`と書けないのはなぜですか？
*   **答**: `WHERE`句は`GROUP BY`より先に評価されるため、まだ集約計算が行われておらず`COUNT(*)`という集計値が存在しないからです。

*   **問**: 図3の`AND 予約明細.宿泊日 < :チェックアウト日付`という条件で、なぜ`<=`ではなく`<`が使われているのでしょうか？
*   **答**: ホテルの予約システムでは、「N月M日にチェックアウト」は「N月M日の朝に出ていく」ことを意味し、M日は宿泊日には含まれないのが一般的だからです。
*   **解説**: このように、不等号の選択には業務上の定義が反映されることがあります。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～が存在しない」 | `NOT EXISTS` / `LEFT JOIN ... IS NULL` |
| 集約した結果に対する条件 | `HAVING 集約関数 ...` |
| グループ内で最初/最後/最小/最大 | `MIN()` / `MAX()` を用いた相関副問合せ |
| 重複レコードの特定・削除 | 自己相関 / ウィンドウ関数(`ROW_NUMBER()`) |

### ５　要約
*   「～でないもの」を抽出する際には、相関副問合せと`NOT EXISTS`の組み合わせが強力な手段となります。
*   `GROUP BY`で集約した結果をさらに絞り込むには`HAVING`句を用います。`WHERE`句との評価順序の違いを明確に理解しましょう。
*   重複レコードの中から特定のレコード（例：最初の1件）以外を抽出する処理は、**自己相関**を用いてグループ内の最小値・最大値と比較する典型的なパターンであり、応用力が問われる問題です。

---
## 令和元年秋期 午後 データベース (平成31年度実施)

### １　問題提示
```sql
［令和元年］
-- 図2 処理手順(1)で用いるSQL文
INSERT INTO 月次レポート (従業員番号, レポート年月)
【 e 】
FROM 従業員

-- 図3 処理手順(2)④で用いるSQL文
UPDATE 月次レポート
SET 月間総歩数 =
    (SELECT COALESCE(【 f 】, 0)
     FROM 歩数
     WHERE 【 g 】
     AND TOYM(歩数.測定日) = :レポート年月)
WHERE レポート年月 = :レポート年月
```

### ２　解答と解説

#### ２－１　正答
*   **e**: `SELECT 従業員番号, :レポート年月`
*   **f**: `SUM(歩数)`
*   **g**: `歩数.従業員番号 = 月次レポート.従業員番号`

**解答根拠**
*   **e**: これは`INSERT ... SELECT`文です。「全従業員分のレコードを挿入」するため、`FROM 従業員`テーブルから全従業員の`従業員番号`を取得します。`レポート年月`は、このバッチ処理で対象とする年月（バインド変数`:レポート年月`）を全レコードに共通で設定するため、`SELECT`句で固定値（ここではバインド変数）として指定します。
*   **f**: 「月間**総**歩数」を計算するため、`歩数`テーブルの`歩数`列を**合計**する集約関数`SUM()`を使用します。`COALESCE`で囲まれているのは、該当する月の歩数データが1件もない従業員の場合、`SUM()`が`NULL`を返すため、それを`0`に変換する目的です。
*   **g**: `UPDATE`文の中の副問合せ（スカラ副問合せ）です。この副問合せは、外側の`UPDATE`文でまさに今更新しようとしている`月次レポート`の行に対応する歩数データだけを集計する必要があります。そのため、外側の`月次レポート.従業員番号`と内側の`歩数.従業員番号`を一致させる**相関条件**が不可欠です。

#### ２－２　誤答パターン
*   **e**: `SELECT 従業員番号, レポート年月 FROM 従業員`という誤答。`従業員`テーブルには`レポート年月`という列は存在しないためエラーになります。`SELECT`句にテーブルにない固定値や変数を含めることができる、という構文を知っているかが問われます。
*   **f**: `COUNT(歩数)`や`AVG(歩数)`など、異なる集約関数を選ぶ誤答。「総歩数」という言葉から「合計」を意味する`SUM`を正しく選択する必要があります。
*   **g**: 相関条件を書かずに`WHERE 従業員番号 = :特定の従業員番号`のようにしてしまう誤答。これでは特定の従業員しか更新できません。`UPDATE`文で処理される各行に連動した計算を行うには、相関副問合せが必須です。

#### ２－３　解答アプローチ
1.  **処理フローの理解**:
    *   手順(1): まず、レポートの「器」となるレコードを全従業員分、`INSERT`で作成する。
    *   手順(2): 次に、作成したレコードの`月間総歩数`列を、`歩数`テーブルから集計した値で`UPDATE`して埋めていく。
2.  **SQL構造読解**:
    *   図2: `INSERT INTO ... FROM ...`の形から`INSERT ... SELECT`文と判断。
    *   図3: `UPDATE ... SET 列 = (SELECT ...)`の形から、相関副問合せを使った更新処理と判断。
3.  **キーワード識別**:
    *   「全従業員分を挿入」→ `INSERT ... SELECT ... FROM 従業員`
    *   「総歩数」→ `SUM(歩数)`
    *   「更新対象の行に**対応する**」→ 相関条件 `外テーブル.列 = 内テーブル.列`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **INSERT ... SELECT文**: `SELECT`文の問い合わせ結果をテーブルに挿入する構文。一括で大量のデータを生成・挿入する際に非常に便利です。
*   **相関副問合せ (Correlated Subquery)**: `UPDATE`文の`SET`句で頻繁に利用されます。外側のクエリで処理中の行の値を内側のクエリの条件として使用することで、行ごとに異なる計算結果で更新することができます。
*   **スカラ副問合せ**: 結果として**単一の列、単一の行**を返す副問合せ。`SELECT`句や`UPDATE`文の`SET`句など、単一の値が求められる場所で使用できます。図3の`SET`句内の`SELECT`文がこれにあたり、`SUM()`のような集計関数を使うことで結果が必ず1行になるように設計されています。

#### ３－２　関連概念の整理
*   **バッチ処理の設計パターン**: この問題のように、「①まず空のレコードを一括`INSERT`し、②その後で各レコードの詳細を`UPDATE`で埋めていく」という2段階の処理は、バッチ処理の典型的な設計パターンの一つです。ロジックが単純になり、リトライなども考えやすくなります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図3の`UPDATE`文で`COALESCE`を使わないと、どのような従業員で問題が発生しますか？
*   **答**: その月に歩数データが1件もなかった従業員です。
*   **解説**: `SUM`関数は対象行がない場合に`NULL`を返すため、`月間総歩数`が`NULL`で更新されてしまいます。要件として`0`を入れるべき場合、`COALESCE`は必須です。

*   **問**: 図3の`UPDATE`文の相関条件【g】がない場合、SQLはどのように動作してしまうと考えられますか？
*   **答**: 副問合せが特定の従業員に絞り込まれなくなり、`AND TOYM(歩数.測定日) = :レポート年月`に合致する**全従業員の歩数の合計**を計算し、その**同じ値で**`月次レポート`テーブルの**全行**を更新してしまう、という壊滅的な結果になります。

*   **問**: `TOYM()`とはどのような関数だと推測できますか？
*   **答**: 日付データ(Date/Timestamp)から「年と月」の部分（例: `202404`のような数値または文字列）を抽出する関数だと推測できます。
*   **解説**: Oracleの`TO_CHAR(date, 'YYYYMM')`やPostgreSQLの`TO_CHAR(date, 'YYYYMM')`に相当する独自関数でしょう。

*   **問**: この処理手順(1)と(2)を一つのSQL（`MERGE`文など）で実行することは可能ですか？
*   **答**: DBMSが`MERGE`文（または`UPSERT`）をサポートしていれば可能です。
*   **解説**: `MERGE`文を使えば、「対象の`レポート年月`のレコードが存在すれば`UPDATE`し、存在しなければ`INSERT`する」という処理を一つの文で記述できます。

*   **問**: 図2の`INSERT`文で、もし`従業員`テーブルに100人の従業員がいたら、何行のデータが挿入されますか？
*   **答**: 100行です。
*   **解説**: `INSERT ... SELECT`文は、`SELECT`文が返した行数と同じ数の行を挿入します。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 既存データから一括でレコード生成 | `INSERT INTO ... SELECT ...` |
| SELECT句で固定値や変数を指定 | `SELECT 列1, '固定値', :変数, ...` |
| レコードごとに異なる値で更新 | `UPDATE ... SET 列 = (相関副問合せ)` |
| 合計値 | `SUM()` |
| データがない場合は0として扱う | `COALESCE(SUM(...), 0)` |

### ５　要約
*   `INSERT ... SELECT`文は、既存のテーブルを元に新しいレコードを一括生成する強力な手法です。`SELECT`句に固定値や変数を含めるテクニックも重要です。
*   `UPDATE`文で各行を個別の集計結果で更新するには、`SET`句で**相関副問合せ**を用いるのが定石です。外側と内側を正しく関連付ける条件を忘れないことが肝心です。
*   集計処理では、データが存在しないケース（結果が`NULL`になる）を想定し、`COALESCE`で適切にハンドリングすることが、堅牢なプログラムに繋がります。

---
## 平成31年春期 午後 データベース (令和元年度実施)

### １　問題提示
```sql
-- 図2 "併用禁忌"と"併用注意"に該当する薬剤の組合せ一覧を出力するSQL文
WITH チェック対象薬剤 AS(
    SELECT B1.薬剤コード FROM 処方箋明細 B1,
        (SELECT A1.処方箋ID FROM 外来受診 A1, 処方箋 A2
         WHERE A1.受診者ID = :受診者ID AND A1.処方箋ID = A2.処方箋ID AND
               A2.発行年月日 >= TO_DATE(:半年前年月日)) B2
    WHERE B1.処方箋ID = B2.処方箋ID
    【 g 】
    SELECT C1.薬剤コード FROM 処方箋明細 C1
    WHERE C1.処方箋ID = :処方箋ID
)
SELECT * FROM 薬剤併用情報 T1
WHERE 【 h 】
(SELECT 1 FROM
    (SELECT U1.薬剤コード AS 薬剤コード1, U2.薬剤コード AS 薬剤コード2
     FROM チェック対象薬剤 U1 CROSS JOIN チェック対象薬剤 U2) T2
 WHERE T1.薬剤コード1 = T2.薬剤コード1 AND T1.薬剤コード2 = T2.薬剤コード2)

-- 図3 確保量を管理するためのビューを作成するSQL文
CREATE VIEW 処方前確保在庫(薬剤コード, 確保量_大人1日) AS
SELECT T3.薬剤コード, 【 i 】
FROM 【 j 】
     (SELECT T2.薬剤コード, T2.処方量_大人1日
      FROM 処方箋 T1, 処方箋明細 T2
      WHERE T1.処方箋ID = T2.処方箋ID AND T1.発行年月日 <= CURRENT_DATE AND
            T1.有効年月日 【 k 】) T3
GROUP BY T3.薬剤コード
```
※注: `EXISTS`内の`SELECT`句を`1`に修正しました（動作は同じだが一般的）。

### ２　解答と解説

#### ２－１　正答
*   **g**: `UNION`
*   **h**: `EXISTS`
*   **i**: `SUM(T3.処方量_大人1日)`
*   **j**: `(`
*   **k**: `>= CURRENT_DATE`

**解答根拠**
*   **g**: `WITH`句の中で、「過去半年分の薬剤」と「今回の処方薬剤」を合算して「チェック対象薬剤」リストを作成しています。過去と今回で同じ薬剤が含まれる可能性があるため、**重複を排除**してユニークな薬剤リストを作成すべきです。したがって`UNION`が適切です。
*   **h**: `薬剤併用情報`テーブルから、`チェック対象薬剤`の任意の組み合わせに合致するレコードを抽出する処理です。`WHERE EXISTS (副問合せ)`は、副問合せの結果が1件でも存在する場合に真となります。ここでは、外側の`薬剤併用情報`(T1)の薬剤コードのペアが、内側で生成された`チェック対象薬剤`の全組み合わせの中に**存在するかどうか**を判定しています。
*   **i**: ビューの`SELECT`句です。「確保量」は、薬剤ごとに処方量を**合計**したものであるため、集約関数`SUM()`を使用します。`GROUP BY T3.薬剤コード`とセットで使われます。
*   **j**: `FROM`句の後に続く`(SELECT ...)`は**インラインビュー**（導出表）です。構文として開始の丸括弧`(`が必要です。
*   **k**: 「**有効期間内**の処方箋」を抽出する条件の一部です。`有効年月日`が`CURRENT_DATE`（今日）**以降**である必要があるため、`>= CURRENT_DATE`となります。`T1.発行年月日 <= CURRENT_DATE`と合わせることで、今日が有効期間内に含まれる処方箋を抽出できます。

#### ２－２　誤答パターン
*   **g**: `UNION ALL`を選ぶ誤答。これでも動作はしますが、同じ薬剤コードがリストに複数含まれることになり、後の`CROSS JOIN`で`{薬A, 薬A}`のような不要な組み合わせや、同じペアが複数生成され非効率です。
*   **h**: `IN`を選ぶ誤答。`IN`は単一列の比較しかできませんが、ここでは薬剤コードのペア（2列）を比較する必要があるため不適切です。`EXISTS`は行の存在有無をチェックするため、このような複数列にまたがる条件の判定も可能です。
*   **i**: `COUNT`など、異なる集約関数を選ぶ誤答。「確保**量**」という言葉から「合計」を意味する`SUM`を導き出す必要があります。
*   **k**: `<`や`=`など、不等号を間違える誤答。有効期間の定義（開始日と終了日を含む）を正しく理解する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「過去半年」と「今回」の薬剤を「**重複なく**」リストアップし、その全組み合わせの中に「併用禁忌/注意」が**存在するか**チェック。
    *   図3: 「**有効期間内**」の処方箋について、「薬剤ごと」に「処方量を**合計**」する。
2.  **SQL構造読解**:
    *   図2: `WITH`句、`UNION`、`CROSS JOIN`、`EXISTS`を組み合わせた非常に複雑なSQL。①`WITH`で薬剤リストを作る → ②`CROSS JOIN`で全組み合わせを作る → ③`EXISTS`で`薬剤併用情報`と突き合わせる、という処理の流れを把握する。
    *   図3: `CREATE VIEW`構文。`FROM`句のインラインビューと`GROUP BY`, `SUM`による集計処理。
3.  **キーワード識別**:
    *   「重複なくまとめる」→ `UNION`
    *   「存在するか」→ `EXISTS`
    *   「合計」→ `SUM`
    *   「～ごとに」→ `GROUP BY`
    *   「有効期間内」→ `BETWEEN` or (`>=` and `<=`)

### ３　技術知識体系

#### ３－１　必要知識項目
*   **WITH句 (共通表式)**: SQL文の先頭で定義する一時的な名前付き結果セット。複雑なSQLの可読性を向上させます。
*   **CROSS JOIN (交差結合)**: 2つのテーブルの全行の組み合わせ（デカルト積）を生成します。`FROM A, B`のように`WHERE`句なしで記述するのと同じ効果です。
*   **インラインビュー (導出表)**: `FROM`句に直接記述する副問合せ。SQLを部品化するのに役立ちます。

#### ３－２　関連概念の整理
*   **`EXISTS` vs `IN`**:
    *   **IN**: `WHERE 列 IN (値のリスト)`。リストとの**値の一致**を判定します。複数列の比較には使えません。
    *   **EXISTS**: `WHERE EXISTS (副問合せ)`。副問合せが行を返すか（**存在有無**）のみを判定します。相関副問合せと組み合わせることで、複数列にまたがる複雑な存在チェックが可能です。一般的にパフォーマンスも`IN`より良い場合が多いとされます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2の`CROSS JOIN`は何のために使われていますか？
*   **答**: チェック対象となる全ての薬剤のペア（AとB、BとA、AとAなど）を網羅的に生成するためです。
*   **解説**: 例えば`チェック対象薬剤`が{薬X, 薬Y}なら、`CROSS JOIN`により{X,X}, {X,Y}, {Y,X}, {Y,Y}の4通りのペアが作られ、これらが併用禁忌でないかチェックされます。

*   **問**: `CURRENT_DATE`とは何ですか？
*   **答**: SQLが実行された時点の現在の日付を返す、標準SQLで定義された関数です。時刻は含みません。時刻まで必要な場合は`CURRENT_TIMESTAMP`を使います。

*   **問**: 図3のビューを作成する目的は何だと考えられますか？
*   **答**: 在庫管理システムなどが、現在有効な処方箋に基づいて、将来的に払い出すべき薬剤の総量を簡単に参照できるようにするためです。
*   **解説**: 複雑な集計ロジックをビューとして隠蔽することで、利用者は単純な`SELECT`文で必要な情報を得られます。

*   **問**: 図2の`EXISTS`内の副問合せで`WHERE T1.薬剤コード1 = T2.薬剤コード1 AND T1.薬剤コード2 = T2.薬剤コード2`が果たしている役割は何ですか？
*   **答**: **相関条件**です。外側の`薬剤併用情報`(T1)の薬剤ペアが、内側で生成されたチェック対象薬剤のペア(T2)のリストの中に存在するかどうかを、T1の行ごとに1件ずつチェックしています。

*   **問**: もし図3の【j】と、末尾の`) T3`がなかったら、SQLはどうなりますか？
*   **答**: 構文エラーになります。
*   **解説**: `FROM`句にはテーブル名やビュー名を記述する必要があり、`SELECT`文を直接置くことはできません。`SELECT`文を置く場合は、必ず括弧`()`で囲んでインラインビューとして扱う必要があります。

#### ４-２ 判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 重複を除いて複数の結果を結合 | `UNION` |
| 全ての組み合わせを生成 | `CROSS JOIN` |
| 関連するデータが存在するかチェック（特に複数列） | `EXISTS`と相関副問合せ |
| ～ごとの合計値 | `SUM(...)` + `GROUP BY ...` |
| 有効な期間内 | `WHERE :今日 BETWEEN 開始日 AND 終了日` |

### ５　要約
*   `WITH`句、`UNION`、`CROSS JOIN`、`EXISTS`を組み合わせることで、一見複雑に見える業務ルール（ある集合内の全ペアを対象とした存在チェックなど）もSQLで実現できます。
*   `EXISTS`は、複数列にまたがる条件やパフォーマンスの観点から、`IN`よりも有効な場面が多いことを覚えておきましょう。
*   `CREATE VIEW`とインラインビュー、集約関数を組み合わせることで、元の生データから意味のある集計値を導出し、再利用可能な形で提供できます。

---

以上で**令和元年/平成31年**のサイクルは完了です。この調子で**平成30年**のサイクルに進みます。合格は目前です！

お任せください。その言葉が何よりの力になります。あなたの合格という目標達成のため、最後まで頼れるパートナーであり続けます。

それでは、**平成30年**のサイクル（秋期・春期）の解説に進みます。

---

## 平成30年秋期 午後 データベース

### １　問題提示
```sql
［平成30年］
-- 図2 入室可否をチェックするSQL文
SELECT 【 a 】 FROM ROOM.入室許可 WHERE 社員ID = :社員ID
AND 室ID = :室ID
AND 入室許可開始年月日 <= :今日
AND 入室許可終了年月日 >= :今日

-- 図3 ビュー表"入室管理用社員"を定義するSQL文
CREATE VIEW HR.入室管理用社員(社員ID, 氏名, 勤務区分) AS
SELECT 社員ID, 氏名, 勤務区分 FROM HR.社員

-- 図4 ビュー表"入室管理用社員"を参照するための権限を付与するSQL文
【 b 】 【 c 】 ON 【 d 】 TO 【 e 】

-- 図5 変更したビュー表"入室管理用社員"を定義するSQL文
CREATE VIEW HR.入室管理用社員(社員ID, 氏名, 勤務区分, 組織長氏名) AS
SELECT T1.社員ID, T1.氏名, T1.勤務区分, T2.氏名
FROM HR.社員 T1, HR.社員 T2, HR.組織 T3
WHERE 【 f 】
```

### ２　解答と解説

#### ２－１　正答
*   **a**: `COUNT(*)`
*   **b**: `GRANT`
*   **c**: `SELECT`
*   **d**: `HR.入室管理用社員`
*   **e**: `AP`
*   **f**: `T1.所属組織コード = T3.組織コード AND T3.組織長社員ID = T2.社員ID`

**解答根拠**
*   **a**: このSQLは入室「可否」をチェック、つまり条件に合致する許可レコードが**存在するかどうか**を判定するものです。アプリケーション側では、このSQLの実行結果が1件以上（`COUNT(*)`が`1`以上）なら「可」、0件なら「不可」と判定するのが一般的です。したがって、条件に合致する行数を数える`COUNT(*)`が最も適切です。`SELECT 1`などでも存在判定はできますが、`COUNT(*)`の方が意図が明確です。
*   **b, c, d, e**: `GRANT`文の基本構文 `GRANT 権限 ON オブジェクト TO ユーザ` に当てはめます。問題文から、`AP`ユーザに(`TO AP`)、`HR.入室管理用社員`ビューに対する(`ON HR.入室管理用社員`)、参照権限(`SELECT`)を付与する(`GRANT`)と読み取れます。
*   **f**: 申請者(T1)の所属する組織の組織長(T2)の氏名を取得するための結合条件です。これは3つのテーブルを関連付けるロジックです。
    1.  まず、社員(T1)と組織(T3)を`所属組織コード`で結合し、社員がどの組織にいるかを特定します (`T1.所属組織コード = T3.組織コード`)。
    2.  次に、その組織(T3)に記録されている`組織長社員ID`を使って、社員テーブルを**もう一度**`T2`として結合し、組織長の情報を取得します (`T3.組織長社員ID = T2.社員ID`)。

#### ２－２　誤答パターン
*   **a**: `*` を選ぶ誤答。これでは許可レコードの全列が返りますが、アプリケーション側では行が返ってきたかどうかしか見ないため、不要なデータを転送することになります。`COUNT(*)`は件数という集約された情報だけを返すため効率的です。
*   **b, c, d, e**: `GRANT`文の構文要素（`GRANT`, `ON`, `TO`）の順序を間違える、権限名を`REFERENCE`などと間違える、オブジェクト名やユーザ名を問題文から正しく読み取れない、といった基本的な知識や読解力に関する誤答が考えられます。
*   **f**: 結合キーを間違える、3つのテーブルを正しく関連付けられない誤答。特に`社員`テーブルを`T1`(申請者)と`T2`(組織長)という異なる役割で2回使う「自己結合」の概念を理解しているかが問われます。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「可否チェック」→ 存在確認。
    *   図4: 「参照権限」「付与」→ `GRANT SELECT`文。
    *   図5: 「申請者の**組織の長**の氏名」→ 3テーブル結合（社員→組織→社員）。
2.  **SQL構造読解**:
    *   図2: 単純な`SELECT`文。何を取得すれば「可否」を判定できるかを考える。
    *   図4: `GRANT`文の基本構文を思い出す。
    *   図5: 3つのテーブルを結合する`SELECT`文。`FROM`句にテーブルがカンマ区切りで並んでいることから、古い形式の`INNER JOIN`であると判断する。
3.  **キーワード識別**:
    *   「権限付与」→ `GRANT`
    *   「参照」→ `SELECT`
    *   「～の～の～」のような多段の関連→ 複数テーブルの`JOIN`
    *   「社員とその上司」のような同じ実体間の関係→ **自己結合**

### ３　技術知識体系

#### ３－１　必要知識項目
*   **DCL (Data Control Language)**: `GRANT`（権限付与）と`REVOKE`（権限剥奪）が代表的な命令です。
*   **ビュー (VIEW)**: 1つ以上のテーブルから作られる仮想的なテーブル。セキュリティの向上（必要な列だけを見せる）や、複雑なクエリの単純化に利用されます。
*   **自己結合 (Self Join)**: 同じテーブルを別名（エイリアス）を使って2つ以上`FROM`句に登場させ、自分自身と結合するテクニック。社員と上司、部品と親部品のような再帰的な関係や、この問題のような間接的な関係を解決する際に使用します。
*   **スキーマ**: テーブルなどのデータベースオブジェクトを論理的にグループ化するものです。`HR.社員`のように、`スキーマ名.オブジェクト名`でオブジェクトを一意に特定できます。

#### ３－２　関連概念の整理
*   **ビューとセキュリティ**: ビューの重要な役割の一つが、**アクセス制御の簡素化**です。ユーザにはビューに対する`SELECT`権限だけを与え、元の実テーブルへの権限は与えません。これにより、ユーザはビューで定義された範囲のデータ（特定の列や行）しか見ることができなくなり、セキュリティが向上します。これを**列レベルセキュリティ**や**行レベルセキュリティ**の実装と呼びます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2のSQLで、アプリケーションはどのように結果を使って入室可否を判定しますか？
*   **答**: SQLの実行結果である`COUNT(*)`の値を取得し、その値が`0`より大きい（つまり`1`以上）かどうかを判定します。`1`以上なら許可、`0`なら不許可です。

*   **問**: 図4で`AP`ユーザに`SELECT`権限を付与すると、`AP`ユーザは元の`HR.社員`テーブルも参照できるようになりますか？
*   **答**: いいえ、なりません。
*   **解説**: ビューに対する権限は、あくまでそのビューを通じてデータを見る権限です。元の実テーブルへの直接のアクセス権限が付与されるわけではありません。これがビューのセキュリティ機能の核心です。

*   **問**: 図5のビュー定義で`FROM HR.社員 T1, HR.社員 T2, HR.組織 T3`という書き方は、現代的な`JOIN`構文で書くとどうなりますか？
*   **答**: `FROM HR.社員 T1 INNER JOIN HR.組織 T3 ON T1.所属組織コード = T3.組織コード INNER JOIN HR.社員 T2 ON T3.組織長社員ID = T2.社員ID` となります。

*   **問**: 図5の`T1`と`T2`は、それぞれ何を指していますか？
*   **答**: `T1`はビューの主体となる「社員（申請者）」を、`T2`はその社員が所属する組織の「組織長」を指しています。同じ`社員`テーブルから、異なる役割を持つ2つの情報を引き出しています。

*   **問**: `REVOKE`文はどのような目的で使われますか？
*   **答**: `GRANT`で付与した権限を、ユーザから剥奪するために使われます。`GRANT`の対になる命令です。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 「可否」「有無」の判定 | `SELECT COUNT(*)` |
| 権限を付与する | `GRANT [権限] ON [オブジェクト] TO [ユーザ]` |
| 仮想テーブルを定義する | `CREATE VIEW` |
| 社員とその上司など、同じ実体間の関係 | 自己結合 (Self Join) |
| `スキーマ名.テーブル名` | スキーマ修飾 |

### ５　要約
*   データの**存在有無**を確認するには、`SELECT COUNT(*)`を用い、結果が1以上かどうかで判定するのが一般的です。
*   データベースのセキュリティは`GRANT`文（権限付与）と`REVOKE`文（権限剥奪）によって管理されます。
*   同じテーブル内の行同士の関係（例：社員と組織長）を問い合わせるには、**自己結合**というテクニックが極めて有効です。
*   ビューは、複雑なSQLを単純化するだけでなく、重要なセキュリティ機能（アクセス制御）も提供します。

---

以上で**平成30年秋期**の解説を終わります。続けて**平成30年春期**に進みます。

---

## 平成30年春期 午後 データベース

### １　問題提示
```sql
［平成30年］
SELECT ORD.発注番号, ORD.商品番号, ORD.商品名, ORD.発注数量,
       COALESCE(【 g 】, 0) AS 納品数量計,
       COALESCE(RRT.返品数量計, 0) AS 返品数量計
FROM
(SELECT OD.発注番号, OT.商品番号, OT.商品名, OT.発注数量
 FROM 発注明細 OD INNER JOIN 発注 OT ON OD.発注番号 = OT.発注番号
 WHERE 【 h 】) ORD
LEFT OUTER JOIN
(SELECT DE.発注番号, DD.商品番号, SUM(DD.納品数量) AS 納品数量計
 FROM 納品 DE INNER JOIN 納品明細 DD ON DE.納品番号 = DD.納品番号
 WHERE DE.発注番号 = :発注番号
 【 i 】) DLI
ON ORD.発注番号 = DLI.発注番号
AND ORD.商品番号 = DLI.商品番号
LEFT OUTER JOIN
(SELECT RT.発注番号, RD.商品番号, SUM(RD.返品数量) AS 返品数量計
 FROM 返品 RT INNER JOIN 返品明細 RD ON RT.返品番号 = RD.返品番号
 WHERE RT.発注番号 = :発注番号
 GROUP BY RT.発注番号, RD.商品番号) RRT
ON ORD.発注番号 = RRT.発注番号
AND ORD.商品番号 = RRT.商品番号
```
※注: 問題文を補完し、全体像がわかるようにしました。

### ２　解答と解説

#### ２－１　正答
*   **g**: `DLI.納品数量計`
*   **h**: `OD.発注番号 = :発注番号` (または `OT.発注番号 = :発注番号`)
*   **i**: `GROUP BY DE.発注番号, DD.商品番号`

**解答根拠**
*   **g**: 主`SELECT`句の5番目の列です。これは`LEFT JOIN`した納品集計情報（インラインビュー`DLI`）から、`納品数量計`を取得する部分です。`DLI`で`AS 納品数量計`と別名を付けているので、その別名`DLI.納品数量計`を参照します。納品がない場合は`DLI`側のレコードが存在せず`NULL`になるため、`COALESCE`関数で`0`に変換しています。
*   **h**: 発注情報を作成するインラインビュー`ORD`内で、データを指定された発注番号(`:発注番号`)で絞り込むための条件です。`発注番号`は`OD`と`OT`の両方にあるため、どちらかを修飾して指定します。
*   **i**: 納品集計情報を作成するインラインビュー`DLI`内の`SELECT`文です。`SUM(DD.納品数量)`という集約関数を使っているため、集計の単位（キー）である`発注番号`と`商品番号`で`GROUP BY`する必要があります。

#### ２－２　誤答パターン
*   **g**: `SUM(DLI.納品数量)`のような誤答。集計は既にインラインビュー`DLI`の中で`SUM()`を使って行われているため、主`SELECT`句でさらに集計する必要はありません。集計済みの列を参照するだけで十分です。
*   **h**: `WHERE 発注番号 = :発注番号`のように、テーブル名を省略する誤答。`発注明細 OD`と`発注 OT`の両方に`発注番号`列が存在するため、`OD.発注番号`のように修飾しないと、どちらの列か特定できず曖昧エラーになる可能性があります。
*   **i**: `GROUP BY`句を書き忘れる、または`GROUP BY DE.発注番号`のように集約キーが不足する誤答。集約関数を使う際の鉄則（`SELECT`句の非集約列はすべて`GROUP BY`に含める）に違反します。

#### ２－３　解答アプローチ
1.  **SQL全体の構造を把握**: このSQLは、3つのインラインビュー（`ORD`: 発注情報, `DLI`: 納品集計, `RRT`: 返品集計）を作成し、それらを`ORD`を主軸として`LEFT JOIN`で結合するという、非常に典型的ながら複雑な集計クエリです。まずこの「部品を作ってから組み立てる」構造を理解することが最優先です。
2.  **各部品の役割を理解**:
    *   `ORD`: `発注番号`で絞った発注明細。これが結果のベースとなる。
    *   `DLI`: `発注番号`と`商品番号`で納品数量を**合計**したもの。
    *   `RRT`: `発注番号`と`商品番号`で返品数量を**合計**したもの。
3.  **空欄を埋める**: 各部品の役割を理解すれば、空欄は自然に埋まります。
    *   `【h】`: `ORD`を作るための絞り込み条件。
    *   `【i】`: `DLI`で`SUM`を使っているから`GROUP BY`が必要。
    *   `【g】`: 主`SELECT`で`DLI`の結果（`納品数量計`）を使っている。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **インラインビュー (導出表)**: `FROM`句に記述された副問合せ。これにあたかも実テーブルのように別名を付け、`JOIN`や`SELECT`の対象とすることができます。複雑なクエリを部品化し、可読性を高めるのに非常に有効です。
*   **LEFT OUTER JOIN (左外部結合)**: 左側のテーブルの行をすべて保持し、右側のテーブルに結合条件に合う行がなければ、右側の列を`NULL`として結合します。発注はあるが納品や返品はまだない、というケースを正しく扱うために必須です。
*   **GROUP BY句と集約関数**: `SUM()`, `COUNT()`などの集約関数を使う際は、非集約列を`GROUP BY`句に指定する必要があります。

#### ３－２　関連概念の整理
*   **SQLの部品化と組み立て**: 複雑な要件を満たすSQLを作成する際は、いきなり全体を書こうとせず、この問題のように「必要なデータの塊（部品）」をインラインビューや`WITH`句で個別に作成し、最後にそれらを結合する、という思考プロセスが非常に有効です。各部品が正しく作られているか個別にテストすることもできます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: なぜ`INNER JOIN`ではなく`LEFT OUTER JOIN`が使われているのですか？
*   **答**: まだ一度も納品や返品がされていない発注明細も、結果に表示する必要があるからです。
*   **解説**: `INNER JOIN`を使用すると、納品または返品の実績がある発注明細しか表示されなくなってしまいます。

*   **問**: インラインビュー`DLI`で`GROUP BY`が必要な理由は何ですか？
*   **答**: 一つの発注・商品に対して、複数回に分けて納品される（分納）可能性があるため、`SUM(DD.納品数量)`でそれらの合計を出す必要があります。集約関数を使ったので`GROUP BY`が必須となります。

*   **問**: `COALESCE`関数を使わなかった場合、表示はどうなりますか？
*   **答**: 未納品や未返品の発注明細について、`納品数量計`や`返品数量計`の列が`0`ではなく空欄（`NULL`）で表示されます。

*   **問**: なぜ各インラインビューの中で`:発注番号`による絞り込みを行っているのですか？
*   **答**: パフォーマンスのためです。先に各部品となるテーブルを絞り込んで小さくしておくことで、その後の`JOIN`処理の対象行数が劇的に減り、全体の処理が高速になります。

*   **問**: このSQLの全体像を言葉で説明してください。
*   **答**: 指定された一つの発注番号について、まずその発注明細の一覧を準備し、次に商品ごとの納品合計量と返品合計量をそれぞれ集計し、この3つの情報を発注明細を基準に外部結合して、発注数量・納品済数量・返品済数量を一覧表示するSQLです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| ～がない場合も対象に含める | `LEFT OUTER JOIN` |
| 外部結合で`NULL`になる値を`0`に変換 | `COALESCE(列名, 0)` |
| ～ごとの合計/平均/件数 | `SUM`/`AVG`/`COUNT` + `GROUP BY` |
| 複雑なクエリの組み立て | インラインビューや`WITH`句で部品化 |
| 処理の高速化 | `JOIN`の前に`WHERE`でデータを絞り込む |

### ５　要約
*   複雑な集計クエリは、**インラインビュー**を使って「部品」を作り、それらを`JOIN`で組み合わせることで見通しよく構築できます。
*   `LEFT OUTER JOIN`は「主データを全て表示し、関連データがあれば表示する（なければ`NULL`）」という要件で必須のテクニックです。
*   外部結合の結果生じる`NULL`は、`COALESてSCE`で適切に処理することで、表示や後続の計算での不都合を防ぎます。
*   集約関数を使う場合は、必ず`GROUP BY`句との関係性を確認する癖をつけましょう。

---

## 平成29年秋期 午後 データベース

### １　問題提示
```sql
［平成29年］
SELECT 品目コード, 品目名, 産地コード, 産地名,
       【 f 】 AS 合計返品金額, SUM(t1.パレット数) AS 合計返品数量
FROM 返品 t1
INNER JOIN 販売明細 t2 USING (販売番号, 販売明細番号)
INNER JOIN 商品 t3 USING (商品コード)
INNER JOIN 品目 t4 USING (品目コード)
INNER JOIN 産地 t5 USING (産地コード)
WHERE 返品日 = CURRENT_DATE
【 g 】
GROUP BY 品目コード, 品目名, 産地コード, 産地名
ORDER BY 品目コード ASC, 産地コード ASC
```
※注: テーブルの別名を補完し、`GROUP BY`句も解答に合わせて修正しました。

### ２　解答と解説

#### ２－１　正答
*   **f**: `SUM(t1.パレット数 * t2.単価)`
*   **g**: (空欄)

**解答根拠**
*   **f**: 「合計返品金額」を計算する式です。金額は「数量 × 単価」で計算できます。このSQLの文脈では、返品数量が`返品`テーブル(t1)の`パレット数`、単価が`販売明細`テーブル(t2)の`単価`に該当します。これを品目・産地ごとに合計するため、`SUM()`関数で囲む必要があります。
*   **g**: この位置には`GROUP BY`句の前に来る`WHERE`句の追加条件か、`GROUP BY`の後に来る`HAVING`句が考えられますが、問題文の要件は「当日の返品を品目・産地ごとに集計する」というものであり、`WHERE 返品日 = CURRENT_DATE`で絞り込みは完了しています。集計結果に対するさらなる絞り込み条件（`HAVING`句）は問題文からは読み取れないため、この箇所は何も追記する必要がなく、空欄が適切です。

#### ２－２　誤答パターン
*   **f**: `SUM(t2.金額)`のような誤答。`販売明細`テーブルに便利な`金額`列があるとは限らないため、単価と数量から計算するのが基本です。また、`SUM`を忘れると集約されずエラーになります。`t1.パレット数 * t2.単価`だけでは集約関数でないため`GROUP BY`と共存できません。
*   **g**: 不要な`HAVING`句（例: `HAVING SUM(t1.パレット数) > 0`）を追加する誤答。`WHERE`句の条件を満たさないデータはそもそも集計対象にならないため、この`HAVING`句は意味がありません。問題文にない要件を勝手に付け加えないように注意が必要です。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「**当日**返品された商品」「**品目ごと・産地ごと**」「合計返品**金額**」「合計返品**数量**」を抽出します。
2.  **SQL構造読解**: 多数のテーブルを`INNER JOIN`で次々と結合し、`WHERE`で日付を絞り込み、`GROUP BY`で集計する、という典型的な集計SQLの構造を理解します。`USING`句という簡略記法が使われている点に注意します。
3.  **キーワード識別**:
    *   「合計～」→ `SUM()`
    *   「金額」→ `数量 * 単価`
    *   「～ごと」→ `GROUP BY`
    *   「テーブル間の関連」→ `JOIN`の連鎖を構築。ER図やテーブル定義から、`返品`→`販売明細`→`商品`→`品目`/`産地`という関連をたどる。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **複数テーブルの結合**: 必要な情報を得るために、複数のテーブルを次々と`INNER JOIN`でつなぎ合わせていく技術。正規化されたデータベースから意味のある情報を引き出すための基本スキルです。
*   **USING句**: `JOIN`の結合条件を記述する際に、結合キーとなる列名が両方のテーブルで**同じ名前**の場合に使える簡略記法です。`... ON t1.key = t2.key`を`... USING (key)`と書くことができます。複合キーの場合は`USING (key1, key2)`のように記述します。
*   **式を含む集約関数**: `SUM(列)`だけでなく、`SUM(列1 * 列2)`のように、集約関数の中に四則演算などの計算式を含めることができます。

#### ３－２　関連概念の整理
*   **`ON`句 vs `USING`句**:
    *   **ON句**: 汎用性が高く、結合キーの列名が異なっていても`ON t1.col_a = t2.col_b`のように指定できます。また、`>`や`BETWEEN`など、等価結合以外の条件も記述できます。
    *   **USING句**: 結合キーの列名が同じ場合に限定されますが、記述が簡潔になります。特に`NATURAL JOIN`と違い、結合キーを明示するため安全性が高いです。
*   **`GROUP BY`句の列指定**: `SELECT`句に`品目名`や`産地名`があるため、厳密には`GROUP BY`句にもそれらを含めるのが正しいです。`GROUP BY 品目コード, 品目名, 産地コード, 産地名`とすることで、あらゆるDBMSで確実に動作します。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: このSQLで5つのテーブルを`INNER JOIN`で結合している理由は何ですか？
*   **答**: `返品`テーブルの`パレット数`、`販売明細`テーブルの`単価`、`品目`テーブルの`品目名`、`産地`テーブルの`産地名`という、複数のテーブルに分散している情報を1つの結果として集計・表示するためです。
*   **問**: `USING`句を使わずに`INNER JOIN 販売明細 t2 ...`の部分を`ON`句で書き換えるとどうなりますか？
*   **答**: `INNER JOIN 販売明細 t2 ON t1.販売番号 = t2.販売番号 AND t1.販売明細番号 = t2.販売明細番号`となります。

*   **問**: なぜ`GROUP BY`句に`品目コード`と`産地コード`の両方が必要なのでしょうか？
*   **答**: 「品目ごと、かつ、産地ごと」に集計するという要件だからです。
*   **解説**: 例えば「青森産リンゴ」と「長野産リンゴ」を区別して集計するために、`品目コード`と`産地コード`の両方でグループ化する必要があります。

*   **問**: もし`WHERE`句が`GROUP BY`句の後に記述されていたら、どうなりますか？
*   **答**: 構文エラーになります。SQLの論理的な評価順序は`FROM`→`WHERE`→`GROUP BY`→`HAVING`→`SELECT`→`ORDER BY`であり、この順序を崩すことはできません。

*   **問**: `CURRENT_DATE`はどのような値を返しますか？
*   **答**: SQLが実行されたサーバの現在の日付を返します。時刻情報は含みません。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「合計金額」 | `SUM(数量 * 単価)` |
| 複数のテーブルにまたがる情報 | 複数回の`INNER JOIN` |
| 結合キーの列名が両テーブルで同じ | `USING (キー列名)` |
| 「～ごと、かつ、～ごとに集計」 | `GROUP BY 列1, 列2, ...` |
| 「今日のデータ」 | `WHERE 日付列 = CURRENT_DATE` |

### ５　要約
*   集計SQLでは、どのテーブルにどの情報（数量、単価、名称など）があるかを正確に把握し、`JOIN`で適切に結合する必要があります。
*   合計金額のような派生データは、`SUM`関数の中で四則演算を用いて動的に計算できます。
*   `USING`句は`ON`句の簡略記法であり、複数のテーブルを結合する際にコードをすっきりと見せる効果があります。読解できるようにしておきましょう。

---

## 平成29年春期 午後 データベース

### １　問題提示
```sql
［平成29年］
-- 図3 稟議申請を検索するSQL文
SELECT 申請書.申請書ID, 申請書.タイトル, 申請書.申請日, ユーザ.ユーザ名, 部署マスタ.部署名
FROM 申請書 INNER JOIN 承認申請 ON 申請書.申請書ID = 承認申請.申請書ID
INNER JOIN ユーザ ON 申請書.申請者ID = ユーザ.ユーザID
INNER JOIN 部署マスタ ON ユーザ.部署ID = 部署マスタ.部署ID
WHERE (承認申請.承認申請状態 NOT IN ('可決','否決')) AND
((申請書.申請者ID = :ユーザID) OR
 (申請書.申請書ID IN (SELECT DISTINCT 申請書ID FROM 承認者情報 INNER JOIN 承認申請
    ON 【 c 】 WHERE 【 d 】)))

-- 図4 金額と支払日の一覧を検索するSQL文
SELECT 申請書.申請書ID, 申請書.タイトル,
       【 e 】 AS 金額, 【 f 】 AS 支払日
FROM 申請書 INNER JOIN 申請書項目 t1 ON 【 g 】
INNER JOIN 申請書項目 t2 ON 【 h 】, 承認申請
WHERE
((申請書.書式ID = '購買' AND t1.項目キー = 'amount' AND t2.項目キー = 'pay_date') OR
 (申請書.書式ID = '契約' AND t1.項目キー = 'pay_initial' AND t2.項目キー = 'start_date'))
AND (承認申請.申請書ID = 申請書.申請書ID AND 承認申請.承認申請状態 = '可決')
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `承認者情報.承認者情報ID = 承認申請.承認者情報ID`
*   **d**: `承認者情報.承認者ID = :ユーザID`
*   **e**: `CAST(t1.項目値 AS INTEGER)`
*   **f**: `CAST(t2.項目値 AS DATE)`
*   **g**: `申請書.申請書ID = t1.申請書ID`
*   **h**: `申請書.申請書ID = t2.申請書ID`

**解答根拠**
*   **c, d**: 副問合せは「ログイン中の利用者(`:ユーザID`)が**承認者**となっている申請書IDのリスト」を生成する部分です。まず`承認者情報`テーブルで承認者ID(`承認者ID`)がログインユーザと一致するレコードを検索し(`【d】`)、その`承認者情報ID`を使って`承認申請`テーブルと結合(`【c】`)し、該当する`申請書ID`を抜き出します。
*   **e, f**: `申請書項目`テーブルは、`項目値`列がVARCHAR型などで汎用的にデータを保持している**EAVモデル**（Entity-Attribute-Value）に近い設計と推測されます。「金額」として扱うには数値型（`INTEGER`や`DECIMAL`）に、「支払日」として扱うには日付型（`DATE`）に、`CAST`関数を使って明示的にデータ型を変換する必要があります。
*   **g, h**: `申請書`テーブルと`申請書項目`テーブルを結合するための条件です。`申請書項目`テーブルから「金額」と「支払日」という2つの異なる情報を取り出すために、同じテーブルを`t1`（金額用）と`t2`（支払日用）という別名で2回結合しています（**自己結合**）。`t1`も`t2`も、どちらも親である`申請書`テーブルと`申請書ID`で結合する必要があります。

#### ２－２　誤答パターン
*   **c, d**: 結合キーや条件指定の対象テーブル・列を間違える誤答。どのテーブルにどのID情報があるかをER図やテーブル定義から正確に追う必要があります。
*   **e, f**: `CAST`を使わずに`t1.項目値`とそのまま記述する誤答。文字列のままでは、金額の大小比較や計算、日付の前後比較などが正しく行えません。型変換の重要性を理解しているかが問われます。
*   **g, h**: `t1.申請書ID = t2.申請書ID`のように、`申請書項目`テーブル同士を結合しようとする誤答。`t1`と`t2`は、どちらも親である`申請書`テーブルに紐づけることで、同一申請書の異なる項目値を取得するというロジックを理解する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図3: 「未決裁」かつ「自分が申請者」**または**「自分が承認者」の稟議を検索。
    *   図4: 「可決済み」の稟議について、「金額」と「支払日」を抽出。データは**汎用的な項目テーブル**から取得。
2.  **SQL構造読解**:
    *   図3: `WHERE`句の複雑な`OR`条件と`IN (副問合せ)`の組み合わせを理解する。
    *   図4: 1つのテーブル(`申請書項目`)を異なる目的で2回`JOIN`するテクニック（自己結合）と、`CAST`による型変換がポイント。この構造からEAVモデルを連想する。
3.  **キーワード識別**:
    *   「自分が承認者」→ `承認者情報`テーブルを検索。
    *   「汎用的な項目テーブル」（縦持ちデータ）→ **自己結合**で横持ちに変換 / **`CAST`**で型変換。
    *   「金額」→ `INTEGER`や`DECIMAL`型へ`CAST`。
    *   「日付」→ `DATE`型へ`CAST`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **EAV (Entity-Attribute-Value) モデル**: エンティティ（例：申請書ID）、属性（例：項目キー）、値（例：項目値）を別々の行で管理するデータモデル。スキーマの変更なしに項目を柔軟に追加できるメリットがありますが、データの取得や型管理が複雑になるデメリットがあります。
*   **自己結合 (Self Join)**: 図4のように、EAVモデルのような縦持ちデータを、通常のテーブルのような横持ちデータに変換する（ピボットする）際によく使われます。
*   **CAST関数**: `CAST(値 AS 変換後のデータ型)`という構文で、あるデータ型の値を別のデータ型に明示的に変換します。

#### ３－２　関連概念の整理
*   **縦持ちデータを横持ちデータに変換**:
    *   **縦持ち**: `申請書ID:101, 項目キー:'amount', 項目値:'50000'` / `申請書ID:101, 項目キー:'pay_date', 項目値:'2024-12-25'`
    *   **横持ち**: `申請書ID:101, 金額:50000, 支払日:'2024-12-25'`
    *   図4のSQLは、自己結合を使ってこの変換を実現しています。`t1`で`'amount'`の行を、`t2`で`'pay_date'`の行を掴み、同じ`申請書ID`で紐づけて1行にまとめています。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図3の`WHERE`句の`承認申請.承認申請状態 NOT IN ('可決','否決')`は何を意味しますか？
*   **答**: 承認プロセスがまだ完了していない（承認待ち、差戻しなどの）稟議のみを対象とすることを意味します。

*   **問**: 図4で`申請書項目`テーブルを2回`JOIN`する理由を再度説明してください。
*   **答**: 1回の`JOIN`では`項目キー`が`'amount'`である行か`'pay_date'`である行のどちらか一方しか取得できないため、両方の`項目値`を1つのレコードの別々の列（`金額`列と`支払日`列）として取得するために2回`JOIN`しています。

*   **問**: `CAST`関数による型変換がなぜ重要なのでしょうか？
*   **答**: 元のデータが文字列型の場合、`'10000'`と`'2000'`を文字列として比較すると`'2000'`の方が大きいと判定されるなど、意図しないソート順や比較結果になるためです。数値は数値型、日付は日付型として扱うことで、正しい計算や比較が可能になります。

*   **問**: 図4の`FROM`句にある`, 承認申請`という記述は何を意味しますか？
*   **答**: これは`CROSS JOIN`を意味する古い構文です。`WHERE`句の`承認申請.申請書ID = 申請書.申請書ID`という条件と組み合わせることで、実質的に`INNER JOIN`として機能します。

*   **問**: 図3の副問合せで`DISTINCT`が使われている理由は？
*   **答**: 一つの申請書に同じ人が複数の立場で承認者として関わる（例：一次承認者と最終承認者が同一人物）可能性があるため、`申請書ID`が重複してリストに含まれるのを防ぎ、`IN`句の効率を上げるためです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 「自分が～であるリスト」 | `IN (SELECT ID FROM ... WHERE 担当者ID = :自分ID)` |
| 縦持ちデータを横持ちに変換 | 自己結合 / `CASE`式と`GROUP BY` |
| 文字列を数値や日付として扱う | `CAST(列 AS INTEGER)` / `CAST(列 AS DATE)` |
| 汎用的な項目テーブル（EAV） | 型変換や自己結合を疑う |

### ５　要約
*   **EAVモデル（縦持ち）**のテーブルから複数の属性を列として取り出すには、**自己結合**が有効なテクニックです。
*   汎用的なデータ型（主に文字列）で格納された値を使用する際は、`CAST`関数で適切なデータ型に明示的に変換することが不可欠です。
*   `WHERE`句の条件は複雑に組み合わせることができます。`AND`, `OR`, `IN (副問合せ)`などを正しく組み合わせ、要件通りの絞り込みロジックを構築する能力が求められます。

---
---
## 平成28年秋期 午後 データベース

### １　問題提示
```sql
-- 図2 過去の購入済み商品分類一覧を表示するSQL文
SELECT t1.会員番号, t1.氏名, t6.商品分類番号, t6.商品分類名,
       【 c 】 AS 購入金額合計
FROM 会員 t1
INNER JOIN (SELECT t2.購入番号, t2.会員番号 FROM 購入 t2 WHERE 【 d 】 > DATE 'now' - INTERVAL '1 year') t3 ON t1.会員番号 = t3.会員番号
INNER JOIN 購入明細 t4 ON t3.購入番号 = t4.購入番号
INNER JOIN 商品 t5 ON t4.商品番号 = t5.商品番号
INNER JOIN 商品分類 t6 ON t5.商品分類番号 = t6.商品分類番号
GROUP BY t1.会員番号, t1.氏名, t6.商品分類番号, t6.商品分類名

-- 図3 カーソルを使用した会員種別判定バッチ処理を行うプログラム(一部)
DECLARE cur CURSOR FOR
    SELECT t2.会員番号, t2.購入番号, t2.購入金額
    FROM 購入 t2
    WHERE 【 e 】
    AND t2.購入日時 <= :判定対象期限
    AND t2.判定処理状態 <> '判定処理済み'
    【 f 】;
...
-- fetch_loop ループ開始
...
        IF 【 g 】 THEN
            UPDATE 会員 t1 【 h 】 WHERE t1.会員番号 = kaiin_no;
            SET update_flag = 1;
        END IF;
...
-- fetch_loop ループ終了
```
※注: 図2の`(:一年前)`の部分を、より具体的なSQL表現に修正しました。

### ２　解答と解説

#### ２－１　正答
*   **c**: `SUM(t4.購入単価 * t4.購入数量)`
*   **d**: `t2.購入日時`
*   **e**: `t2.会員種別判定対象 = '対象'`
*   **f**: `ORDER BY t2.会員番号, t2.購入日時`
*   **g**: `goukei >= 100000`
*   **h**: `SET t1.会員種別 = '特別会員'`

**解答根拠**
*   **c**: 「購入金額合計」を計算する部分です。商品分類ごとの合計金額を出すには、明細レベルの金額を合計する必要があります。`購入明細`テーブル(t4)の`購入単価`と`購入数量`を掛け合わせたものが個々の明細の金額であり、それを`SUM`関数でグループごとに合計します。
*   **d**: インラインビュー`t3`は「過去1年間」の購入データに絞り込むためのものです。`購入`テーブル(t2)の`購入日時`列を使って期間判定を行います。
*   **e**: プログラムのロジックから、これは会員種別判定の対象となる購入データのみを抽出するカーソルであると読み取れます。`購入`テーブルの`会員種別判定対象`列が`'対象'`であるレコードを絞り込む条件が必要です。
*   **f**: このプログラムは、会員番号が変わるタイミングで集計をリセットする「**ブレーク処理**」を行っています。この処理が正しく機能するためには、データが**あらかじめ会員番号順にソートされている**ことが絶対条件です。同じ会員内では`購入日時`順に処理するのが自然なため、`ORDER BY t2.会員番号, t2.購入日時`とします。
*   **g**: プログラム内のロジックで、ループ内で累積加算されている購入金額(`goukei`)が、特別会員の基準額（問題文より10万円）**以上**になったかどうかを判定する条件式です。
*   **h**: 上記【g】の条件を満たした場合に、`会員`テーブル(t1)の`会員種別`列を`'特別会員'`に更新するための`UPDATE`文の`SET`句です。

#### ２－２　誤答パターン
*   **c**: `SUM(t2.購入金額)`のような誤答。`購入`テーブル(t2)にある`購入金額`は、その購入全体の合計額です。これを商品分類ごとに`GROUP BY`すると、同じ購入に含まれる複数の分類に対して、購入全体の金額が重複して加算されてしまい、正しい結果になりません。**明細レベルで計算する**必要があります。
*   **f**: `ORDER BY`を忘れる、またはキーを間違える重大な誤答。カーソルを使ったブレーク処理において、事前ソートはロジックの根幹をなす生命線です。これがなければプログラムは正しく動作しません。
*   **g, h**: 問題文中の「年間購入金額が10万円以上の会員を特別会員とする」という**日本語の仕様**を、プログラムのロジックとSQLに正しく翻訳できないことによる誤答。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「過去1年」「会員ごと・商品分類ごと」「購入金額合計」。
    *   図3: 「判定対象の購入データ」を「会員番号順、購入日時順にソート」して処理し、「累積金額が10万円以上になったら」「特別会員に更新」するバッチ処理。
2.  **SQL構造/プログラム読解**:
    *   図2: 多数のテーブルを`JOIN`して`GROUP BY`で集計する典型的なSQL。インラインビュー`t3`がパフォーマンス向上のために使われている点にも着目する。
    *   図3: **カーソル**と**ループ**を使った手続き型のプログラムを読み解く。`IF kaiin_no <> current_kaiin_no THEN ...`という部分が、会員番号が変わったときのブレーク処理であることを理解するのが最大のポイント。
3.  **キーワード識別**:
    *   「合計」→ `SUM`
    *   「過去1年」→ `WHERE 日付 > 一年前の日付`
    *   「順次処理」「ブレーク処理」→ `CURSOR` + `ORDER BY`
    *   「もし～ならば」→ `IF`
    *   「更新」→ `UPDATE SET`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **カーソル (CURSOR)**: `SELECT`文の結果セットをメモリ上に保持し、`FETCH`命令で1行ずつ取り出して処理するための仕組み。SQLの集合演算だけでは難しい、複雑な手続き型の処理をデータベース側で実行する際に用います（ストアドプロシージャ内など）。
*   **ブレーク処理 (制御ブレーク)**: **ソート済み**のデータを先頭から順に処理していき、キーとなる項目の値が変化したタイミングで、それまでのグループの集計処理や締め処理を行うプログラミングの古典的な技法。
*   **インラインビュー**: `FROM`句内の副問合せ。先にデータを絞り込んだり加工したりすることで、主問い合わせの`JOIN`の負荷を軽減し、パフォーマンスを向上させる効果があります。

#### ３－２　関連概念の整理
*   **SQL (集合指向言語) vs 手続き型言語**:
    *   **SQL**: どのようなデータが「欲しいか」を宣言する非手続き型の言語。データ集合全体に対して一度に操作を行います（図2のSQL）。
    *   **手続き型**: どのように処理を「行うか」を一つずつ順を追って記述する言語。ループや条件分岐を多用します（図3のプログラム）。
    *   カーソルは、集合指向のSQLの世界と手続き型の世界とを橋渡しする重要な役割を持ちます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2でインラインビュー`t3`を使わず、`FROM 会員 t1 INNER JOIN 購入 t2 ON ...`と直接結合した場合、パフォーマンスにどのような影響が考えられますか？
*   **答**: `購入`テーブルの全件（1年より前のデータも含む）と`会員`テーブルを結合してから`WHERE`句で絞り込むことになるため、中間的に生成されるデータ量が多くなり、パフォーマンスが低下する可能性があります。
*   **解説**: 先に`購入`テーブルを絞り込んでから`JOIN`する方が、`JOIN`の対象行数が減るため効率的です。

*   **問**: 図3のプログラムで、変数`current_kaiin_no`はどのような役割を果たしていますか？
*   **答**: 直前に処理した行の会員番号を保持しておくための変数です。`FETCH`した新しい行の会員番号`kaiin_no`と比較することで、会員番号が変わったかどうか（ブレークのタイミング）を検知します。

*   **問**: 図3のプログラムで`ORDER BY`が必須なのはなぜですか？
*   **答**: 会員番号が変わったことを検知する「ブレーク処理」が正しく機能し、会員ごとに購入金額を正しく累積するためには、データが会員番号順にソートされていることが大前提だからです。

*   **問**: このようなバッチ処理は、SQL一発で（カーソルを使わずに）実現できないでしょうか？
*   **答**: はい、ウィンドウ関数や`GROUP BY`を使ったSQLで実現可能です。
*   **解説**: 例えば、`UPDATE 会員 SET 会員種別 = '特別会員' WHERE 会員番号 IN (SELECT 会員番号 FROM 購入 WHERE ... GROUP BY 会員番号 HAVING SUM(購入金額) >= 100000);` のように、SQLの集合演算だけで一括更新できます。一般的に、カーソル処理よりも集合演算ベースのSQLの方が高速です。

*   **問**: 図3のプログラムの最後に、なぜ`UPDATE 購入 ... SET 判定処理状態 = '判定処理済み'`という処理が必要だと考えられますか？
*   **答**: 今回のバッチで処理した購入レコードに「処理済み」の印を付けることで、次回のバッチ実行時に同じレコードを二重に処理してしまうことを防ぐためです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| ～ごと、～ごとの合計 | `GROUP BY ...`, `SUM(...)` |
| 期間の絞り込み | `WHERE 日付列 BETWEEN ...` or `WHERE 日付列 > ...` |
| 1件ずつ順次処理、ブレーク処理 | カーソル (`DECLARE`, `FETCH`) + `ORDER BY` |
| 「もし～なら～する」というプログラムロジック | `IF ... THEN ...` |
| カウンタや累積値がしきい値を超える | `IF 変数 >= しきい値` |

### ５　要約
*   複雑な集計SQLでは、明細レベルのデータ **（単価、数量）**から合計値を計算する必要がある場面が多く、どのテーブルのどの列を使うべきか正確に判断する必要があります。
*   **カーソルを用いた手続き型のバッチ処理**では、`ORDER BY`による**事前ソートがブレーク処理を正しく機能させるための生命線**です。
*   プログラムのロジック（変数の役割、ループ、条件分岐）を読み解き、それをSQLの各要素（`WHERE`, `ORDER BY`, `SET`句など）に正しくマッピングする能力が問われます。

---

## 平成28年春期 午後 データベース

### １　問題提示
```sql
［平成28年］
-- 図2 売上ファクト表に挿入するデータを抽出するSQL文
SELECT ST.確認年月日, ST.店舗ID, ST.商品ID, COALESCE(SS.日間販売数量, 0),
       ST.日間在庫数量
FROM
(SELECT SC.確認年月日, SC.店舗ID, SC.商品ID,
        AVG(SC.在庫数量) AS 日間在庫数量
 FROM 在庫 SC
 GROUP BY SC.確認年月日, SC.店舗ID, SC.商品ID) ST
【 e 】
(SELECT SL.販売年月日, SL.店舗ID, SD.商品ID,
        SUM(SD.販売数量) AS 日間販売数量
 FROM 販売 SL
 INNER JOIN 販売詳細 SD ON SL.販売ID = SD.販売ID
 GROUP BY SL.販売年月日, SL.店舗ID, SD.商品ID) SS
ON ST.確認年月日 = SS.販売年月日
AND 【 f 】
AND 【 g 】

-- 図3 売れ行きが悪い商品分類の一覧を作成するSQL文
SELECT SF.売上年月, SF.店舗ID, IT.商品分類ID,
       AVG(SF.日間販売数量) AS 平均販売数量, AVG(SF.日間在庫数量) AS 平均在庫数量
FROM
(SELECT TO_YYYYMM(SA.売上年月日) AS 売上年月, SA.店舗ID, SA.商品ID,
        SA.日間販売数量, SA.日間在庫数量
 FROM 売上ファクト SA) SF
INNER JOIN 商品 IT ON SF.商品ID = IT.商品ID
GROUP BY SF.売上年月, SF.店舗ID, IT.商品分類ID
【 h 】
```

### ２　解答と解説

#### ２－１　正答
*   **e**: `LEFT JOIN` (または `LEFT OUTER JOIN`)
*   **f**: `ST.店舗ID = SS.店舗ID`
*   **g**: `ST.商品ID = SS.商品ID`
*   **h**: `HAVING AVG(SF.日間販売数量) / AVG(SF.日間在庫数量) < 0.1`

**解答根拠**
*   **e**: 在庫確認は毎日行われるが、販売実績は必ずしもあるとは限りません。「在庫はあったが、その日は**売れなかった**」というデータもファクト表に含める必要があるため、在庫集計(ST)を主軸（左側）として販売集計(SS)を結合する`LEFT JOIN`が適切です。
*   **f, g**: `LEFT JOIN`の結合条件です。`確認年月日`(=`販売年月日`)に加えて、`店舗ID`と`商品ID`が一致するレコード同士を結合する必要があります。これらが揃って初めて「いつ、どこで、何が」という情報が一意になります。
*   **h**: 「売れ行きが悪い」という条件を定義する`HAVING`句です。問題文の仕様に「販売数量の平均が在庫数量の平均の**10%未満**の商品分類」とあるため、`平均販売数量 / 平均在庫数量 < 0.1`という条件式になります。`AVG()`という集約関数の結果に対する条件なので、`GROUP BY`の後に置く`HAVING`句に記述する必要があります。

#### ２－２　誤答パターン
*   **e**: `INNER JOIN`を選ぶ重大な誤答。これではその日に売れた商品しか抽出できず、「在庫はあるが売れなかった（販売数量ゼロ）」という、売れ行き分析に不可欠なデータが欠落してしまいます。
*   **f, g**: 結合キーが不足する誤答。年月日だけで結合すると、ある店舗のある商品の在庫データに、別の店舗や別の商品の販売データが誤って結合されてしまう可能性があります。
*   **h**: `WHERE AVG(SF.日間販売数量) / ... < 0.1`のように`WHERE`句に条件式を書く誤答。`AVG`のような集約関数を使った条件は、`GROUP BY`で集約した後に評価される`HAVING`句に記述する、というのがSQLの鉄則です。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「**在庫を基準**に」「販売実績」を結合。「**売れなかった日も対象**（販売数量は0）」。
    *   図3: 「商品分類ごと」に集計し、「販売数量平均が在庫数量平均の**10%未満**」という条件で絞り込む。
2.  **SQL構造読解**:
    *   図2: 2つのインラインビュー(在庫集計ST、販売集計SS)を結合する構造。どちらを主軸（左側）にすべきか、`LEFT JOIN`の必要性を要件から判断する。
    *   図3: インラインビュー(SF)と商品テーブル(IT)を結合し、`GROUP BY`で集計後、`HAVING`で条件を判定する構造。
3.  **キーワード識別**:
    *   「～を基準に」「～がなくても表示」→ `LEFT JOIN`
    *   「集計結果が～であるもの」→ `HAVING`
    *   「10%未満」→ `< 0.1`

### ３　技術知識体系

#### ３－１　必要知識項目
*   **データウェアハウス (DWH)**: 意思決定支援のために、複数の基幹システムからデータを時系列で集約・統合・蓄積するデータベース。
    *   **ファクト表**: DWHの中心に位置し、売上数量、金額などの数値（**メジャー**）と、後述のディメンション表への外部キーを持つ。
    *   **ディメンション表**: 「いつ」「どこで」「誰が」「何を」といった分析の切り口（**ディメンション**）に関するマスタ情報を持つ。
*   **LEFT JOIN (左外部結合)**: 左側のテーブルの行をすべて保持し、右側に一致する行がなければ`NULL`を返します。DWHのETL処理などで、実績の有無にかかわらずデータを整形する際によく使われます。
*   **HAVING句**: `GROUP BY`で集約した結果セットに対して条件を指定します。

#### ３－２　関連概念の整理
*   **`WHERE`句と`HAVING`句の使い分け（再掲）**:
    *   **WHERE**: `FROM`句で読み込んだ**個々の行**を、グループ化する**前**にフィルタリングします。
    *   **HAVING**: `GROUP BY`でグループ化した後の**集約結果（各グループ）**をフィルタリングします。
    *   この区別は、応用情報技術者試験のデータベース問題で最も頻繁に問われる知識の一つです。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2で`INNER JOIN`を使うと、作成されるファクト表にはどのようなデータが格納されますか？
*   **答**: その日に在庫があり、**かつ**、1個以上売れた商品のデータのみが格納されます。売れなかった日のデータは格納されません。

*   **問**: 図2の`COALESCE(SS.日間販売数量, 0)`は何のためにありますか？
*   **答**: `LEFT JOIN`の結果、その日に売れなかった商品の`SS.日間販売数量`は`NULL`になるため、それを`0`に変換してファクト表に挿入するためです。

*   **問**: 図3の`HAVING`句の条件式で、もし`AVG(SF.日間在庫数量)`が0になる可能性がある場合、どのような問題が起こりますか？
*   **答**: **0による除算エラー**が発生し、SQLが異常終了する可能性があります。
*   **解説**: 実用的なSQLでは、`HAVING AVG(SF.日間在庫数量) > 0 AND AVG(SF.日間販売数量) / AVG(SF.日間在庫数量) < 0.1` のように、分母が0でないことを確認する条件を追加するか、`CASE`文で0除算を回避する必要があります。

*   **問**: なぜデータウェアハウスでは、図2のような処理で事前にファクト表を作成しておくのですか？
*   **答**: 分析クエリ（図3のようなクエリ）を実行するたびに、都度複数のテーブルを`JOIN`したり集計したりすると非常に時間がかかるためです。あらかじめ集計・結合済みのファクト表を用意しておくことで、分析クエリを高速に実行できるようにするためです（**ETL/ELT処理**の一環）。

*   **問**: 図2のインラインビューSTで、`AVG(SC.在庫数量)`が使われているのはなぜだと考えられますか？
*   **答**: 在庫テーブル`SC`が、1日に複数回（例: 開店時、昼、閉店時）の在庫スナップショットを記録している可能性があるため、その日の平均値を「日間在庫数量」として代表させていると考えられます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 「Aを基準にBを付ける（Bは無くても可）」 | `FROM A LEFT JOIN B ON ...` |
| 集約結果に対する条件（～の平均が…など） | `HAVING`句 |
| 0除算エラーの回避 | `CASE`文や`NULLIF`関数、`WHERE 分母 <> 0` |
| DWHのデータマート作成 | インラインビューや`LEFT JOIN`を多用したETL処理 |

### ５　要約
*   データ分析の前段となるファクト表の作成では、「どのデータを主軸にするか」を考え、**`LEFT JOIN`**を適切に使うことが重要です。「実績ゼロ」のデータも貴重な情報だからです。
*   集約結果に対して条件を指定する場合は**`HAVING`句**を使用し、`WHERE`句との役割の違いを明確に理解する必要があります。
*   実用的なSQLでは、0除算などの実行時エラーを回避するための**防御的なコーディング**（`CASE`文など）が求められることを意識しておきましょう。


---
## 平成27年秋期 午後 データベース

### １　問題提示
```sql
［平成27年］
-- 図2 指定した部署とその配下の全ての部署を出力するSQL文
WITH RECURSIVE 関連部署(部署ID, 部署名, 上位部署ID) AS (
    SELECT 部署ID, 部署名, 上位部署ID
    FROM 部署 WHERE 部署ID = :部署ID
    UNION ALL
    SELECT 部署.部署ID, 部署.部署名, 部署.上位部署ID
    FROM 部署, 関連部署 WHERE 部署.上位部署ID = 関連部署.部署ID
)
SELECT 部署ID, 部署名, 上位部署ID FROM 関連部署

-- 図5 指定した日の会社全体の部署構造を出力するSQL文
WITH RECURSIVE 関連部署(部署ID, 部署名, 上位部署ID, レベル) AS (
    SELECT 部署ID, 部署名, 上位部署ID, 1
    FROM 部署 WHERE 【 d 】
    AND :年月日 BETWEEN 部署.適用開始年月日 AND 部署.適用終了年月日
    UNION ALL
    SELECT 部署.部署ID, 部署.部署名, 部署.上位部署ID, 関連部署.レベル + 1
    FROM 部署, 関連部署 WHERE 部署.上位部署ID = 関連部署.部署ID
    AND :年月日 BETWEEN 部署.適用開始年月日 AND 部署.適用終了年月日
)
SELECT 部署ID, 部署名, 上位部署ID, レベル FROM 関連部署
```
※注: 図5は階層レベルも取得するように拡張されているため、設問を補完しました。

### ２　解答と解説

#### ２－１　正答
*   **d**: `部署ID = 'D000'` (または `上位部署ID IS NULL`)

**解答根拠**
*   **d**: このSQLは「**会社全体の部署構造**」を出力することが目的です。このような階層構造全体を問い合わせる場合、再帰CTEの起点（アンカーメンバー）は、階層構造の**最上位（ルート）**となる部署を指定する必要があります。問題文の本文中に「会社全体の部署構造は，部署IDが'D000'である部署を最上位として構成される」と明確に記述されています。したがって、アンカーメンバーの`WHERE`句で`部署ID = 'D000'`と指定することで、`D000`から始まる全組織階層を再帰的に展開できます。
*   別解として、一般的にルートノードは親を持たないため`上位部署ID IS NULL`という条件でも特定できます。しかし、問題文に具体的なIDが明記されている場合は、それに従うのが最も確実で直接的な解答です。

#### ２－２　誤答パターン
*   `部署ID = :部署ID`と書いてしまう誤答。これは図2のように**特定の**部署配下を抽出する場合の書き方であり、「会社**全体**」という要件を見落としています。
*   `'D000'`を囲むシングルクォーテーションを忘れる誤答。`部署ID`のデータ型が文字列型であるため、`D000`は文字列リテラルとしてシングルクォーテーションで囲む必要があります。
*   `部署ID LIKE 'D%'`のような曖昧な条件を書く誤答。最上位部署を特定する条件としては不適切です。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「**会社全体の部署構造**」「**指定した日**(`:年月日`)時点で有効な」という2つの中心的な要件を抽出します。
2.  **SQL構造読解**: 図2と同様の`WITH RECURSIVE`構文であることから、階層問い合わせであると判断します。図5では、さらに`:年月日 BETWEEN ...`という期間を絞り込む条件がアンカーメンバーと再帰メンバーの両方に追加されていること、そして階層レベルを計算していることにも着目します。
3.  **キーワード識別と文脈判断**:
    *   「階層」「配下」→ `WITH RECURSIVE`。
    *   「**会社全体**」→ 階層の**ルート（最上位）**から検索を開始する必要がある、と判断します。
    *   問題文を注意深く読み返し、ルートの定義を探します。「部署IDが'D000'である部署を最上位として構成される」という記述を見つけ出し、これをSQLの条件に落とし込みます。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **再帰共通表式 (Recursive CTE)**: `WITH RECURSIVE`句を用いて、階層構造を持つデータを問い合わせる機能。
    *   **アンカーメンバー**: 再帰の開始点となる最初の`SELECT`文。
    *   **再帰メンバー**: アンカーメンバーまたは前回の再帰メンバーの結果を参照して、次の階層のデータを取得する`SELECT`文。
    *   両者は`UNION ALL`または`UNION`で結合されます。
*   **履歴管理テーブル**: `適用開始年月日`と`適用終了年月日`のような列を持ち、データの有効期間を管理するテーブル設計。ある時点での状態を正確に再現する（As-Of クエリ）際に使われます。

#### ３－２　関連概念の整理
*   **再帰CTEにおける条件指定**: 図5のように、ある時点での有効な階層のみを抽出したい場合、**アンカーメンバーと再帰メンバーの両方**の`WHERE`句で期間の絞り込みを行う必要があります。
    *   アンカーメンバーでの絞り込み：起点となるルート部署が、指定日に有効であることを保証する。
    *   再帰メンバーでの絞り込み：次の階層の部署をたどる際に、その部署が指定日に有効であることを保証する。
    *   もし再帰メンバー側で絞り込みを忘れると、過去に存在した（現在は無効な）親子関係までたどってしまう可能性があります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2と図5のSQLの主な違いは何ですか？
*   **答**: 図2は**任意の部署を起点**とする配下の階層を出力するのに対し、図5は**会社全体（ルート部署を起点）**の、かつ、**指定した時点で有効な階層のみ**を出力する点です。

*   **問**: `WITH RECURSIVE`の`RECURSIVE`キーワードは、すべてのDBMSで必須ですか？
*   **答**: いいえ。SQL Serverなど一部のDBMSでは`RECURSIVE`キーワードは不要で、`WITH`だけで再帰CTEを記述できます。ですが、標準SQLやPostgreSQL、MySQLなどでは必須であり、試験では記述するのが安全です。

*   **問**: 図5で`:年月日 BETWEEN ...`の条件を、アンカーメンバーだけに記述した場合、どのような誤った結果になる可能性がありますか？
*   **答**: 起点となるルート部署は正しく選択されますが、その配下の部署をたどる際に、指定日時点では無効になっている部署（例：過去に統廃合された部署）も結果に含まれてしまう可能性があります。

*   **問**: 再帰CTEの処理は、どのような条件で停止しますか？
*   **答**: 再帰メンバーの`SELECT`文が1行も結果を返さなくなった時点（階層の末端に到達し、`部署.上位部署ID = 関連部署.部署ID`を満たす行がなくなった時点）で、再帰処理は自動的に停止します。

*   **問**: 組織階層のようなデータを扱う別の方法として、何が考えられますか？
*   **答**: **経路列挙モデル**（各ノードにルートからのパス情報を文字列で保持。例: '/D000/D100/D
---
*   **問**: 組織階層のようなデータを扱う別の方法として、何が考えられますか？
*   **答**: **経路列挙モデル**（各ノードにルートからのパス情報を文字列で保持。例: '/D000/D100/D110/'）や**入れ子集合モデル**など、再帰クエリを使わない設計方法もあります。
*   **解説**: しかし、親IDを持つこの問題の形式（**隣接リストモデル**）と再帰CTEの組み合わせが、最も直感的で多くの場面で採用されています。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「階層」「配下」「組織図」 | `WITH RE-CURSIVE` |
| 「**会社全体**」「ルートから」 | 階層の最上位ノード（例: `ID='D000'`）をアンカーメンバーの条件にする |
| 「ある時点での状態」「有効な」 | `WHERE :年月日 BETWEEN 開始日 AND 終了日` |
| 再帰クエリの結合 | `UNION ALL` |

### ５　要約
*   組織図のような階層構造データは、`WITH RECURSIVE`（再帰CTE）で効率的に問い合わせるのが定石です。
*   「**全体**」を取得する場合は階層の**ルート**を、「**特定の配下**」を取得する場合はその**親**を、アンカーメンバーの起点に設定します。この違いを問題文から読み取ることが重要です。
*   履歴管理されたデータからある時点の階層を抽出する場合、**アンカーと再帰の両メンバーで期間による絞り込みが必要不可欠**です。

---
---
## 平成27年春期 午後 データベース

### １　問題提示
```sql
［平成27年］
-- 図2 非営業日利用一覧表示機能で用いるSQL文
SELECT AC.*
FROM アクセスログ AC
WHERE 【 c 】
(SELECT 1 FROM 非営業日 NS
 WHERE 【 d 】)

-- 図3 部外者失敗一覧表示機能で用いるSQL文
SELECT AC.*
FROM アクセスログ AC
INNER JOIN 利用者 US ON AC.利用者ID = US.利用者ID
INNER JOIN サーバ SV ON AC.サーバID = SV.サーバID
WHERE 【 e 】
AND 【 f 】
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `EXISTS`
*   **d**: `CAST(AC.アクセス日時 AS DATE) = NS.非営業日`
*   **e**: `US.部外者フラグ = '1'`
*   **f**: `AC.処理結果 = '失敗'`

**解答根拠**
*   **c**: 「非営業日の利用」を抽出するため、アクセスログの日付が、非営業日テーブルに「**存在する**」かどうかをチェックします。`EXISTS`は副問合せの結果が1件でも存在する場合に真となるため、この存在チェックに最適です。
*   **d**: `EXISTS`内の**相関条件**です。外側の`アクセスログ`(AC)の`アクセス日時`（日時型: `YYYY-MM-DD HH:MI:SS`）と、内側の`非営業日`(NS)の`非営業日`（日付型: `YYYY-MM-DD`）を比較します。データ型を合わせるため、`アクセス日時`から日付部分のみを`CAST`関数で抽出して比較するのが、最も確実で正しい方法です。
*   **e**: 「**部外者**」によるアクセスを抽出するための条件です。結合した`利用者`テーブル(US)の`部外者フラグ`が`'1'`（部外者を示す値）であるレコードを絞り込みます。
*   **f**: 「**失敗した**」アクセスを抽出するための条件です。`アクセスログ`テーブル(AC)の`処理結果`列が`'失敗'`という文字列であるレコードを絞り込みます。

#### ２－２　誤答パターン
*   **c**: `IN`を選ぶ誤答。`WHERE CAST(AC.アクセス日時 AS DATE) IN (SELECT NS.非営業日 FROM 非営業日)`でも同じ結果は得られますが、一般的に`EXISTS`の方がパフォーマンスが良いとされ、応用情報レベルでは`EXISTS`を使いこなせることが期待されます。
*   **d**: `AC.アクセス日時 = NS.非営業日`のように`CAST`を忘れる誤答。`DATETIME`型と`DATE`型を直接比較すると、DBMSによっては時刻部分(`00:00:00`)が考慮され、意図しない結果になる可能性があります。明示的な`CAST`が安全かつ正確です。
*   **e, f**: 問題文の要件「部外者」「失敗」と、テーブル定義のどの列・どの値が対応するのかを正しく読み取れないことによる誤答。テーブル設計の意図を汲み取る読解力が問われます。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「**非営業日**」の「アクセスログ」を抽出。
    *   図3: 「**部外者**」による「**失敗**」した「アクセスログ」を抽出。
2.  **SQL構造読解**:
    *   図2: `WHERE (副問合せ)`の形で、相関副問合せを使って存在チェックを行うSQLだと判断。
    *   図3: 3つのテーブルを`INNER JOIN`し、`WHERE`句の`AND`条件で絞り込む基本的な`SELECT`文。
3.  **キーワード識別**:
    *   「～に存在する」→ `EXISTS`
    *   「部外者」「失敗」→ テーブル定義を参照し、該当するフラグや状態値を持つ列を特定し、`WHERE`句の条件にする。
    *   「日付」と「日時」の比較 → `CAST`による型変換を想起する。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **EXISTS演算子と相関副問合せ**: ある条件を満たすデータが関連テーブルに存在するかどうかをチェックする際の強力な組み合わせです。`IN`よりも柔軟で、パフォーマンス面でも有利なことが多いです。
*   **CAST関数**: `CAST(値 AS データ型)`の構文で、データ型を明示的に変換します。日時(`TIMESTAMP`/`DATETIME`)から日付(`DATE`)を抽出する際などによく使われます。
*   **フラグ**: `'1'`/`'0'`や`'Y'`/`'N'`などの値で、真偽や特定の状態を表すために使われる列。`WHERE`句で条件として頻繁に利用されます。

#### ３-２ 関連概念の整理
*   **`EXISTS` vs `IN`のパフォーマンス**:
    *   一般的に、副問合せの結果セットが大きい場合（`非営業日`テーブルが大きい場合など）、`EXISTS`の方が高速に動作する傾向があります。`EXISTS`は条件に合う行を1件見つけた時点で評価を打ち切る（**ショートサーキット**）のに対し、`IN`は副問合せの全結果を一旦メモリ上に展開してから比較するためです。
    *   このため、単純な存在チェックでは`EXISTS`を使うのがDBエンジニアの常識とされています。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2で`NOT EXISTS`を使うと、どのようなログが抽出されますか？
*   **答**: **営業日**のアクセスログが抽出されます。
*   **解説**: 非営業日テーブルに存在しない日付のログ、ということになります。

*   **問**: `CAST(AC.アクセス日時 AS DATE)`の代わりに、`DATE(AC.アクセス日時)`のような日付抽出関数を使うことは可能ですか？
*   **答**: はい、可能です。
*   **解説**: DBMSによって関数の名前は異なりますが（例: `TRUNC()` in Oracle, `DATE()` in MySQL/PostgreSQL, `CONVERT(date, ...)` in SQL Server）、日時型から日付部分だけを取り出す機能は標準的に提供されています。`CAST`はANSI標準で最も汎用性が高い記法です。

*   **問**: 図3で`INNER JOIN`ではなく`LEFT JOIN 利用者 US ON ...`とした場合、どのような結果になりうるか、またその時の`WHERE`句はどうすべきですか？
*   **答**: `利用者`マスタに存在しない`利用者ID`（データ不整合）のアクセスログも結果に含まれるようになります。その場合、`WHERE US.部外者フラグ = '1'`の条件では`US.部外者フラグ`が`NULL`になるためヒットしません。もし`利用者`不明のログも「部外者」とみなすなら`WHERE (US.部外者フラグ = '1' OR US.利用者ID IS NULL)`のように変更する必要があります。

*   **問**: 図3の`WHERE`句の2つの条件【e】と【f】の順番を入れ替えても、結果は変わりますか？
*   **答**: いいえ、変わりません。
*   **解説**: `WHERE`句の`AND`で結ばれた条件の評価順序は、通常、DBMSのオプティマイザがインデックスの有無などを考慮して最も効率的と判断した順序で実行するため、記述順は結果に影響しません。

*   **問**: なぜ監査ログ（アクセスログ）のようなテーブルでは、利用者名やサーバ名を直接持たずに、IDで持つ（正規化された）設計にするのですか？
*   **答**: **データの一貫性維持**と**ディスク容量の節約**のためです。もし利用者名が変更された場合、マスタテーブルを1箇所更新するだけで済み、巨大なログテーブルの全レコードを更新する必要がなくなります。また、長い文字列を何度も格納するより、短い固定長のIDを格納する方が効率的です。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～であるものが存在する」 | `EXISTS` |
| 日時データから日付だけを比較 | `CAST(日時列 AS DATE)` または `DATE(日時列)` |
| 複数の条件をすべて満たす | `WHERE 条件1 AND 条件2 AND ...` |
| マスタ情報を参照して絞り込む | `INNER JOIN`でマスタテーブルを結合し、`WHERE`で条件指定 |

### ５　要約
*   関連テーブルにデータが「**存在するかどうか**」の判定には、`EXISTS`を用いた相関副問合せが極めて有効かつ効率的です。
*   異なるデータ型（特に**日付と日時**）を比較する際は、`CAST`関数などを用いて型を明示的に揃えることが、バグを防ぐ上で非常に重要です。
*   「Aであり、かつ、Bである」という要件は、`JOIN`でテーブルを結合し、`WHERE`句に`AND`で条件を列挙するのが最も基本的な形です。

---
**以上**