## テーブル結合４種

---
 **`INTERSECT` / `UNION` / `CROSS JOIN` / `INNER JOIN`**

---

# １　全体像（テキスト図）


# 集合演算子（UNION / INTERSECT）　縦にレコードが増える。
   ├─ UNION      → 2つの集合を「和集合」として統合　ベン図のOR演算（重複は行全体が一致する場合のみ削除）
   └─ INTERSECT  → 2つの集合を「積集合」として抽出　ベン図のAND演算

* イメージ：縦に積む（行＝レコードが増える）
* 例：社員リストとアルバイトリストをまとめて「全従業員リスト」を作る → 行数が増える
* 注意：両方のSELECT文で「列数とデータ型が一致」していないとエラー。

# 結合（JOIN）　横方向に巨大な表ができる。レコードは減る方向。
   ├─ CROSS JOIN → デカルト積（全組み合わせ）※爆発。実務ではほぼ使われない。ひっかけ問題用。
   └─ INNER JOIN → 共通キーが一致する行のみを結合

* イメージ：横に広げる（列＝カラムが増える）
* 例：社員表と部署表をJOIN → 社員名に部署名カラムが追加される
*注意：
CROSS JOINだと「行数」も増える（直積）。
INNER JOINは「行の数も列の数も変わる」ので、「横に広げる＋行を絞る」の両方が起こる。

---
# １－１　定義（IPA準拠）と用語の由来

* **1.UNION（和集合）**
  SQLの集合演算子。２つのSELECT結果を結合して、重複を除外して返す（UNION ALLなら重複を残す）。
  *語源：英語「union」＝結合・連合。*
* 複数のテーブルに分散したデータを、一つの一覧として扱いたい。
* **UNIONとUNION ALLの違い**（重複削除の有無）。
* UNIONは、縦に増える。JOINは横に増える。


* **2.INTERSECT（積集合）**
  ２つのSELECT結果に共通する行だけを返す。
  *語源：英語「intersect」＝交わる。*
* 複数の条件を同時に満たすデータを取り出したい。
* AND条件的な意味で問われやすい。

* **3.CROSS JOIN（直積結合）**
  片方の表のすべての行と、もう一方の表のすべての行を組み合わせる。
  *語源：数学の直積（cross product）。*
* 組合せパターンを作りたい（例：社員×商品で営業計画）。
* **CROSS JOINは直積＝全組合せ → 行数が急増する**ことを狙って出題。

* **4.INNER JOIN（内部結合）**
  結合条件が一致する行だけを返す。
  *語源：JOIN＝結合、INNER＝内部。共通部分だけを返すイメージ。*
* 異なる表に分かれた関連データ（社員と部署など）を一つに統合したい。
* **INNER JOINは等価結合が基本**（部署ID＝部署ID）での出題が多い。
---
* **試験作成者の狙い**：
  * UNIONとJOINを混同させる。
  * CROSS JOINとINNER JOINを取り違えさせる。
---
# １－４　体系マップ（分類・関係・比較表）
| 種類         | 集合演算子 | 結合       |
| UNION      | 和集合   | –        |
| INTERSECT  | 積集合   | –        |
| CROSS JOIN | –     | 全組合せ（直積） |
| INNER JOIN | –     | 共通キー一致   |

---
## 「正答例」と「誤答例」の意味

* **正答例**
  → SQL文として意図どおりの結果が得られる典型的な使い方。

* **誤答例**
  → 試験で「引っかけ」としてよく出る、**似ているけれど誤った使い方**。
  （＝構文的には正しいけど、結果が意図とズレる例）

つまり、**試験作成者が狙っている誤解をあえて示す**のが「誤答例」です。

---
## 使用するデータ（例：社員表・部署表）

**社員**
| 社員ID | 社員名 | 部署ID |
| ---- | --- | ---- |
| 1    | 佐藤  | 10   |
| 2    | 鈴木  | 20   |
| 3    | 高橋  | 20   |

**部署**

| 部署ID | 部署名 |
| ---- | --- |
| 10   | 総務  |
| 20   | 開発  |
| 30   | 営業  |

---

## ４つの構文と出力結果

### 1. INNER JOIN（正答例）

社員と部署を結合して「社員名＋部署名」を一覧する。

```sql
SELECT 社員名, 部署名
FROM 社員 INNER JOIN 部署
  ON 社員.部署ID = 部署.部署ID;
```

**出力結果**

| 社員名 | 部署名 |
| --- | --- |
| 佐藤  | 総務  |
| 鈴木  | 開発  |
| 高橋  | 開発  |

👉 部署に存在する社員だけが出る（部署30の営業部は社員がいないので出ない、誰が営業してるんだ？）。
---

### 2. CROSS JOIN（誤答例としてよく狙われる）
`クロス`というだけあってまさに掛け算のように爆発的にレコードが増える。

```sql
SELECT 社員名, 部署名
FROM 社員 CROSS JOIN 部署;
```

**出力結果（全組合せ：3×3=9行）**
| 社員名 | 部署名 |
| 佐藤  | 総務  |
| 佐藤  | 開発  |
| 佐藤  | 営業  |
| 鈴木  | 総務  |
| 鈴木  | 開発  |
| 鈴木  | 営業  |
| 高橋  | 総務  |
| 高橋  | 開発  |
| 高橋  | 営業  |

👉 「社員ごとの所属部署」を期待して書くと大失敗。**行数が爆発するのが誤答ポイント**。

---

### 3. UNION（正答例）

「社員表にある部署ID」と「部署表にある部署ID」をまとめる。

```sql
SELECT 部署ID FROM 社員
UNION
SELECT 部署ID FROM 部署;
```

**出力結果（重複削除）**

| 部署ID |
| ---- |
| 10   |
| 20   |
| 30   |

👉 部署10・20・30が一覧化される。社員表と部署表の「和集合」。

---

### 4. INTERSECT（正答例）

「両方の表に存在する部署ID」だけを取り出す。

```sql
SELECT 部署ID FROM 社員
INTERSECT
SELECT 部署ID FROM 部署;
```

**出力結果**

| 部署ID |
| ---- |
| 10   |
| 20   |

👉 社員が所属している部署だけ（部署30の営業部は社員なしなので除外）。

---

いいですね！🙆 ご提示いただいた **集合演算子（UNION / INTERSECT）** と **JOIN（INNER JOIN）** の理解に、**CROSS JOIN** を加えて一枚の体系に整理してみましょう。

---

# １　集合演算子は「ベン図」で覚える

数学の集合と同じイメージで理解できます。
* **UNION（和集合）**
  → A または B に含まれるすべての要素
  👉 **広げるイメージ（OR条件）**

* **INTERSECT（積集合）**
  → A と B の両方に含まれる要素
  👉 **絞るイメージ（AND条件）**

✅ 共通点：どちらも **縦方向の動き（行を増やす／絞る）**

---

# ２　JOINは「テーブルをくっつける」イメージ

JOINは集合演算ではなく、**行を横に並べて列を増やす**処理です。

* **INNER JOIN**
  → 共通のキーで「横にドッキング」

  ```
  社員（社員ID, 社員名, 部署ID）
       ↓ 部署IDが一致
  部署（部署ID, 部署名）
       ↓
  社員＋部署名 が横に並ぶ
  ```
---

# ３　CROSS JOIN

* **CROSS JOIN（直積）**
  → **条件なしで全組合せを作る**
  ```
  社員（3人） × 部署（3部署）
  → 3×3＝9行の結果
  ```

  👉 「横に広げる」＋「行数が爆発する」
  👉 数学的には **デカルト積（Cartesian Product）** と呼ばれる

---

# ４　まとめ（試験用整理）

| 種類             | 出力方向 | 行の増減        | 列の増減  | イメージ        |
| -------------- | ---- | ----------- | ----- | ----------- |
| **UNION**      | 縦    | 行が増える（重複削除） | 列は同じ  | OR条件・全部まとめる |
| **INTERSECT**  | 縦    | 共通行だけ残る     | 列は同じ  | AND条件・交差点   |
| **INNER JOIN** | 横    | 行は条件で減る     | 列が増える | 共通キーでドッキング  |
| **CROSS JOIN** | 横＋縦  | 行が爆発（直積）    | 列が増える | 全組合せ（社員×部署） |

---
**【CROSS JOINは、試験向けのひっかけ問題。実務での利用はほぼなし】**
`JOIN`と聞くと「横に列が増える」と思いがちですが、`CROSS JOIN`は例外的に「縦に行が爆発する」のが特徴です。

---

## １　JOINの一般イメージ

* **INNER JOIN**：
  * 共通キーでマッチした行だけを横に並べる
  * 行は「絞られる」ことが多い
  * 列は増える
---
## ２　CROSS JOINの動き
* **CROSS JOIN（直積）**：
  * キー条件なしで「全組合せ」
  * 行数は **A表の行数 × B表の行数**
  * 列も増える（両方の列が横に並ぶ）
  * だから「横に広げる」＋「縦に爆発的に増える」
---
## ３　まとめ表

| 演算             | 行数の変化       | 列数の変化 | ポイント     |
| -------------- | ----------- | ----- | -------- |
| **INNER JOIN** | 減ることが多い     | 増える   | 共通キーだけ残す |
| **CROSS JOIN** | 爆発的に増える（直積） | 増える   | 条件なし全組合せ |

---

✅ 結論：

* **JOIN＝横に広げる** が基本ルール。
* ただし **CROSS JOINは「横＋縦の爆発」** という特殊パターン。

---
---


# １－６　よくある誤解と正しい知識

* **誤解**：「INNER JOINとINTERSECTは同じ」
  → 正しくは、INNER JOINは「行を結合」、INTERSECTは「集合の共通部分」。
* **誤解**：「CROSS JOINは普通のJOINと同じ」
  → 正しくは、条件なしの直積。件数爆発に注意。
* **誤解**：「UNIONはデータを連結する」
  → 正しくは、縦方向に積み上げる集合演算。横方向の結合ではない。

---

# １－７　一問一答（5問）

**Q1.** `UNION`と`UNION ALL`の違いは？
**A1.** UNIONは重複を削除、UNION ALLは重複を残す。
**解説**：試験では「重複行が出力されるか」が狙われる。

---
**Q2.** `INTERSECT`はどんな演算？
**A2.** ２つの結果集合の共通部分を返す。
**解説**：数学の積集合と同じ。

---
**Q3.** `CROSS JOIN`の結果件数は？
**A3.** 左表の行数×右表の行数。
**解説**：社員3人×部署3件→9行。

---
**Q4.** `INNER JOIN`はいつ使う？
**A4.** 共通のキーが一致する行だけを結合したいとき。
**解説**：正規化されたDBでは必須の基本結合。

---
**Q5.** `INNER JOIN`と`INTERSECT`の違いは？
**A5.** INNER JOINは行を横に結合、INTERSECTは集合の共通部分を抽出。
**解説**：混同しやすい典型問題。

---

# １－８　要約（3行以内）
* **UNION**＝和集合、**INTERSECT**＝積集合。
* **CROSS JOIN**＝全組合せ、**INNER JOIN**＝共通キー一致。
* 試験では「JOINと集合演算の違い」を狙われやすい。

---


#### 【AP過去問】
「部門別売上」表から、部門コードごと、期ごとの売上を得るSQL文はどれか。

**[部門別売上]**
| 部門コード | 第1期売上 | 第2期売上 |
| D01 | 1,000 | 4,000 |
| D02 | 2,000 | 5,000 |
| D03 | 3,000 | 8,000 |

**[問合せ結果]**
| 部門コード | 期 | 売上 |
| D01 | 第1期 | 1,000 |
| D01 | 第2期 | 4,000 |
| D02 | 第1期 | 2,000 |
| D02 | 第2期 | 5,000 |
| D03 | 第1期 | 3,000 |
| D03 | 第2期 | 8,000 |
---
#### 【選択肢】

**ア**
```sql
SELECT 部門コード, '第1期' AS 期, 第1期売上 AS 売上
FROM 部門別売上
INTERSECT
(SELECT 部門コード, '第2期' AS 期, 第2期売上 AS 売上
 FROM 部門別売上)
ORDER BY 部門コード, 期
```
**イ**
```sql
SELECT 部門コード, '第1期' AS 期, 第1期売上 AS 売上
FROM 部門別売上
UNION
(SELECT 部門コード, '第2期' AS 期, 第2期売上 AS 売上
 FROM 部門別売上)
ORDER BY 部門コード, 期
```
**ウ**
```sql
SELECT A.部門コード, '第1期' AS 期, A.第1期売上 AS 売上
FROM 部門別売上 A
CROSS JOIN
(SELECT B.部門コード, '第2期' AS 期, B.第2期売上 AS 売上
 FROM 部門別売上 B) T
ORDER BY 部門コード, 期
```
**エ**
```sql
SELECT A.部門コード, '第1期' AS 期, A.第1期売上 AS 売上
FROM 部門別売上 A
INNER JOIN
(SELECT B.部門コード, '第2期' AS 期, B.第2期売上 AS 売上
 FROM 部門別売上 B) T ON A.部門コード = T.部門コード
ORDER BY 部門コード, 期
```
---
### 問題の解説
この問題の目的は、「部門別売上」表のように横持ち（列に期間の情報がある）のデータを、縦持ち（行に期間の情報がある）の「問合せ結果」に変換することです。

まず、各選択肢で使われている2つの基本的なSELECT文の結果を理解することが重要です。

**1つ目のSELECT文（第1期データ）:**
```sql
SELECT 部門コード, '第1期' AS 期, 第1期売上 AS 売上 FROM 部門別売上
```
この結果は以下のようになります。
| 部門コード | 期 | 売上 |
| :--- | :---: | :---: |
| D01 | 第1期 | 1,000 |
| D02 | 第1期 | 2,000 |
| D03 | 第1期 | 3,000 |

**2つ目のSELECT文（第2期データ）:**
```sql
SELECT 部門コード, '第2期' AS 期, 第2期売上 AS 売上 FROM 部門別売上
```
この結果は以下のようになります。
| 部門コード | 期 | 売上 |
| :--- | :---: | :---: |
| D01 | 第2期 | 4,000 |
| D02 | 第2期 | 5,000 |
| D03 | 第2期 | 8,000 |

これらの2つの結果を、各選択肢の演算子（`INTERSECT`, `UNION`, `CROSS JOIN`, `INNER JOIN`）でどのように組み合わせるかを見ていきましょう。

---
### 各選択肢の分析と出力結果

#### ア: INTERSECT (共通集合)
*   **方法:** 2つのSELECT文の結果から、両方に存在する**完全に一致する行**のみを返します。
*   **解説:** 第1期データと第2期データには、完全に一致する行（部門コード、期、売上のすべてが同じ行）は一つもありません。
*   **出力結果:**
    （結果なし）
*   **結論:** 誤りです。

#### イ: UNION (和集合)
*   **方法:** 2つのSELECT文の結果を**縦に結合**します。重複する行がある場合は1つにまとめます。（この問題では重複行がないため、`UNION ALL`と同じ結果になります）
*   **解説:** 第1期データの3行と第2期データの3行を単純に足し合わせます。これにより、合計6行のデータセットが作成されます。最後に`ORDER BY`でソートすると、問題の「問合せ結果」と完全に一致します。
*   **出力結果:**
    | 部門コード | 期 | 売上 |
    | :--- | :---: | :---: |
    | D01 | 第1期 | 1,000 |
    | D01 | 第2期 | 4,000 |
    | D02 | 第1期 | 2,000 |
    | D02 | 第2期 | 5,000 |
    | D03 | 第1期 | 3,000 |
    | D03 | 第2期 | 8,000 |
*   **結論:** **これが正解です。**

#### ウ: CROSS JOIN (直積)
*   **方法:** 1つ目のテーブルの各行と、2つ目のテーブルの各行の**すべての組み合わせ**を作成します。
*   **解説:** 1つ目のテーブル（第1期データ）が3行、2つ目のテーブル（第2期データ）が3行なので、結果は 3 × 3 = 9行 となります。`SELECT`句では1つ目のテーブルの情報しか取得していませんが、行数はこの組み合わせで決まります。
*   **出力結果:**
    （D01, 第1期, 1,000）の行が3回、（D02, 第1期, 2,000）の行が3回... といった9行の結果となり、期待する結果とは全く異なります。
*   **結論:** 誤りです。

#### エ: INNER JOIN (内部結合)
*   **方法:** 2つのテーブルを、`ON`句で指定した条件に一致する行同士で**横に結合**します。
*   **解説:** このクエリは、「部門別売上」テーブル（A）と第2期データを抽出したテーブル（T）を`部門コード`で結合しています。両方のテーブルにD01, D02, D03が存在するため、3行が結合されます。しかし、`SELECT`句で取得しているのはテーブルAの第1期のデータのみです。
*   **出力結果:**
    | 部門コード | 期 | 売上 |
    | :--- | :---: | :---: |
    | D01 | 第1期 | 1,000 |
    | D02 | 第1期 | 2,000 |
    | D03 | 第1期 | 3,000 |
*   **結論:** 第2期のデータが含まれていないため、誤りです。
---
### 解答

**イ**