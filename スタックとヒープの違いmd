

## １　全体像（テキスト図）

```
プログラムのメモリ領域
├─ スタック領域（LIFO方式）
│   └─ サブルーチン呼び出しの制御情報・局所変数
└─ ヒープ領域（動的確保）
    └─ プログラム実行中に自由に割当／解放できるメモリ
```

---

## １－１　定義（IPA準拠）と語源

* **スタック領域**

  * 定義：プログラムのサブルーチン呼び出し時に、戻りアドレスや局所変数を保存するLIFO方式のメモリ領域
  * 語源：英語 "stack"（積み重ね）→「上に積む」方式で最後に入れたものが最初に出る構造を表す

* **ヒープ領域**

  * 定義：プログラムから動的に確保・解放できるメモリ領域
  * 語源：英語 "heap"（山）→管理されるブロックが「山のように」無秩序に存在する様子を表す

---

## １－２　技術の必要性（解決する課題）

* **スタック領域**

  * サブルーチン呼び出しの順序管理や局所変数保持を自動化
  * 自動で解放されるため、プログラムの安全性向上

* **ヒープ領域**

  * 実行時に必要なサイズのメモリを自由に確保可能
  * 大規模データや構造体などの動的管理に必須

---

## １－３　試験の着眼点（頻出／ひっかけ）

* スタックは自動管理、ヒープは手動管理（明示的解放）
* スタック領域の容量超過は「スタックオーバーフロー」
* ヒープ領域の未解放は **「メモリリーク」**
* スタックはLIFO順序、ヒープは任意順序

---

## １－４　体系マップ（比較表）

| 特性     | スタック領域      | ヒープ領域     |
| ------ | ----------- | --------- |
| 管理方式   | 自動          | 手動        |
| 確保単位   | 固定／関数呼び出し時  | 動的／任意     |
| 解放     | 関数終了時自動     | 明示的解放必要   |
| 構造     | LIFO        | 双方向リスト（例） |
| 容量     | 小さめ（固定）     | 大きめ（任意）   |
| 典型的リスク | スタックオーバーフロー | メモリリーク    |

---

## １－５　代表例（正例・反例・境界条件）

プログラミングにおいて、プログラムが実行中にデータを保存する主要な場所として「スタック」と「ヒープ」という二つのメモリ領域があります。これらはそれぞれ異なる役割と特徴を持っています。

---

### スタック (Stack)

スタックは、プログラムが関数を呼び出したり、一時的なデータを扱ったりする際に使う、**積み重ね式のメモリ領域**です。

*   **どんなときに使われるか（典型的な利用方法）:**
    *   関数が呼ばれるたびに、その関数内で作られるローカル変数（例: `int x;`）や、関数に渡される引数などがここに一時的に保存されます。
    *   関数から関数へ制御が移るときに必要な情報（どこに戻ればよいかなど）もスタックに積まれます。
    *   これらのデータは、関数が終了すると自動的に取り除かれ、メモリが解放されます。
    *   データの出し入れが非常に高速です。

*   **気をつけるべきこと（問題のある使い方）:**
    *   スタックの領域は限られています。そのため、関数内で`int largeArray[1000000];`のように**非常に大きなデータを宣言してしまうと、スタックの容量を超えてしまい、プログラムがクラッシュする「スタックオーバーフロー」というエラーが発生します**。このような大きなデータはスタックには不向きです。

*   **限界や特別な状況（限界に直面する状況）:**
    *   自分自身を何度も呼び出す「再帰関数」を深く実行しすぎると、それぞれの呼び出しで必要な情報がスタックに次々と積まれ、**スタックの容量が限界に達してスタックオーバーフローを引き起こすことがあります**。

---

### ヒープ (Heap)

ヒープは、プログラムが実行中に**必要に応じて、柔軟にメモリを確保する**ために使われる領域です。

*   **どんなときに使われるか（典型的な利用方法）:**
    *   プログラムの実行中にデータのサイズが決まらない場合や、関数が終わってもデータが残っていてほしい場合に利用されます。
    *   例えば、C++の`new MyObject()`でオブジェクトを作成したり、Javaの`new int[1000];`で配列を作成したりする際に使われます。これらのデータは、プログラムが明示的に解放するか、ガベージコレクタ（自動メモリ管理システム）が不要と判断するまでメモリに残ります。

*   **気をつけるべきこと（問題のある使い方）:**
    *   C言語の`malloc()`やC++の`new`などでヒープにメモリを確保した場合、**不要になったら`free()`や`delete`で明示的に解放する責任がプログラマにあります**。もし解放し忘れると、そのメモリは永久に占有されたままになり、他の用途に使えなくなります。これを「メモリリーク」と呼び、これが蓄積されると、**プログラムが利用可能なメモリを使い果たして、システム全体の動作が遅くなったり、クラッシュしたりする原因となります**。

*   **限界や特別な状況（限界に直面する状況）:**
    *   ヒープ領域では、メモリの確保と解放が頻繁に、不規則な順序で行われると、**使える小さなメモリの隙間がたくさんできてしまう「メモリ断片化」が発生することがあります**。たとえ全体の空き容量は十分あっても、新しいデータの保存に必要な「連続した大きな空き領域」が見つからず、メモリの確保に失敗することがあります。

---

### まとめ

*   **スタック:** 小さくて一時的なデータ（ローカル変数、関数呼び出し情報）に適しており、自動で管理されますが、容量には限りがあります。
*   **ヒープ:** サイズが大きく変動するデータや、プログラムの寿命を通して存在する必要があるデータ（オブジェクト、動的な配列）に適しており、手動（またはガベージコレクタ）で管理されるため、解放を忘れると問題が起きます。

これらのメモリ領域の特性を理解することは、効率的で安定したプログラムを作る上で非常に大切です。
---

## １－６　よくある誤解と対処

* 誤解：スタックは「大きなデータ構造も自由に入れられる」
  → 実際は容量が小さいため、巨大配列や長大再帰に注意
* 誤解：ヒープは自動解放される
  → 実際は明示的に解放しないとメモリリーク

---

## １－７　一問一答

**問題1**
スタック領域で保持されるのはどれか。
**回答**
戻りアドレスと局所変数
**解説**
サブルーチン呼び出し時にLIFOで積まれる。大規模データはスタックに不向き。

**問題2**
ヒープ領域のメモリ管理で必要な操作は何か。
**回答**
動的確保と解放
**解説**
malloc/newで確保し、free/deleteで解放。解放忘れはメモリリークになる。

**問題3**
スタックオーバーフローの原因は？
**回答**
再帰の深さが限界を超えた場合
**解説**
LIFOで積まれる戻り情報や局所変数が容量を超えるため。

**問題4**
ヒープ領域の典型的リスクは？
**回答**
メモリリーク
**解説**
使用後に解放しないメモリが残り続けること。

---

## １－８　要約（3行以内）

* スタック：自動管理、LIFO、局所変数・戻りアドレス
* ヒープ：動的管理、任意確保・解放、メモリリーク注意
* 容量・管理方式・リスクを理解して使い分け

---

## １－９　次アクション

* スタックとヒープの典型的例をC/C++で確認（局所変数と動的配列）
* 再帰や巨大データでスタックオーバーフロー、ヒープメモリリークを体感
* 過去問で「スタック／ヒープの違い」「メモリ管理方法」を確認

---


