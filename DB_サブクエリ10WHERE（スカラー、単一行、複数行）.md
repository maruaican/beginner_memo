
### WHERE句におけるサブクエリの解説



```markdown
## 演算子ごとのサブクエリ結果許容範囲と NULL 含有時の評価

| 演算子 | 単一行（1行1列） | 複数行（1列） | NULL を含む場合の挙動 |
|--------|------------------|---------------|-----------------------|
| = / < / > など単純比較 | ✅ 許容 | ❌ エラー | 単一値が NULL → 比較結果は UNKNOWN（FALSE 扱いになり行は返らない） |
| IN | ✅ 許容 | ✅ 許容 | 比較対象が集合内の値と一致 → TRUE。一致なし＆集合に NULL なし → FALSE。一致なし＆集合に NULL あり → UNKNOWN（行は返らない） |
| NOT IN | ✅ 許容 | ✅ 許容 | 集合に NULL が1つでもあると、すべて UNKNOWN になり結果0件（NULL 落とし穴） |
| ANY / SOME | ✅ 許容 | ✅ 許容 | 比較対象と1つでも条件成立 → TRUE。成立なし＆集合に NULL なし → FALSE。成立なし＆集合に NULL あり → UNKNOWN |
| ALL | ✅ 許容 | ✅ 許容 | 集合内のすべてが条件成立 → TRUE。1つでも不成立 → FALSE。成立なし＆集合に NULL あり → UNKNOWN |
| EXISTS | ✅ 許容 | ✅ 許容 | NULL の有無は関係なし。1行でも返せば TRUE |
| NOT EXISTS | ✅ 許容 | ✅ 許容 | NULL の有無は関係なし。1行も返さなければ TRUE |

---

### 三値論理のポイント
- **TRUE**：条件が成立したとき。
- **FALSE**：条件が成立せず、かつ NULL による不確定要素がないとき。
- **UNKNOWN**：NULL が絡み、真偽が確定できないとき。  
  → `WHERE` 句では UNKNOWN は FALSE と同じ扱いで、その行は結果に含まれません。

---

### 特に注意すべきケース
- **`NOT IN` + NULL**  
  集合に NULL が1つでもあると、すべての比較が UNKNOWN になり、結果が0件になる。  
  → 対策：サブクエリ側で `WHERE 列 IS NOT NULL` を入れる。
- **`IN` / `ANY` / `ALL`** でも、NULL が混ざると「一致なし」時に UNKNOWN になる可能性がある。
```

















`WHERE`句は、テーブルから特定の条件に合致する行を**絞り込む**ための句です。

この条件式に
（１）固定の値（例：`WHERE 給与 > 300000`）を指定するだけでなく、
（２）サブクエリの動的な実行結果を利用することができます。

サブクエリが返す結果の形（行数と列数）によって、`WHERE`句でに組み合わせる`演算子`が異なります。

WHERE句サブクエリ
1. スカラーサブクエリ（1行1列の値:単一の値）※単一行サブクエリの特殊な形態
  　`=`、`<`、`>`、`<=`、`>=`、`<>`：比較演算子。
2. 単一行サブクエリ (1行`複数列`)
　　`=`、`<>`。これ以外を対応するDBは限られる。
3. 複数行サブクエリ
*  （構文）
*   WHERE + 属性 + `IN`／ `NOT IN`
*   WHERE + 属性 + `比較演算子` + `ANY`／ `ALL`
4. EXISTS／NOT EXISTS 
   ※別ファイルで解説

*  重要な点は、**スカラーサブクエリは単一行サブクエリの一種（最も特殊な形）**であること。
*   **スカラーサブクエリ**は「**単一の値**」を返すため`汎用性が非常に高く`、SQLの様々な場所で利用できる。
*   スカラーではない**単一行サブクエリ**は、「**1行複数列のセット**」を返し、主にWHERE句で複数の条件を一度に比較する特殊なケースで使われる。
* (一般的な学習や実用上は、単一行サブクエリのほとんどがスカラーサブクエリである)
---

### 1. スカラーサブクエリ（1行1列の値（単一の値）と比較する）

スカラーサブクエリは、結果として**必ず1行1列の単一の値**（スカラー値）を返します。
集計関数（`MAX`, `AVG`, `SUM`など）を用いた問い合わせが典型例です。

*   **戻り値**: 1行1列（単一の値）
*   **使用演算子**: `=`, `<`, `>`, `<=`, `>=`, `<>`
*   **考え方**: サブクエリ全体が「**一つの確定した値**」になります。単純な比較演算子が利用できます。

#### SQL例：全商品の平均単価を上回る単価の商品を抽出する

```sql
SELECT 商品名, 単価
FROM 商品マスタ
WHERE 単価 > (SELECT AVG(単価) FROM 商品マスタ);
```
**解説**:
1.  まず、サブクエリ `(SELECT AVG(単価) FROM 商品マスタ)` が実行され、全商品の平均単価という**単一の値**（例：`1500`）が計算されます。
2.  次に、主文のSQLは `WHERE 単価 > 1500` と解釈され、各商品の単価がこの平均値を超えているかどうかを判定します。

---
### 2. 単一行サブクエリ (複数列)（複数カラムが完全に一致するものを絞り込む）

このサブクエリは、**単一行ですが、複数の列**を返します。特定の単一レコードが持つ複数の属性値を「一組のデータ」として扱いたい場合に非常に有効です。

*   **戻り値**: 1行`複数列`
*   **使用演算子**: `=`
*   **考え方**: 複数の列を `()` で囲んで「**行の組（タプル）**」として扱い、サブクエリが返す「行の組」と完全に一致するかを判定します。

#### SQL例：特定の社員と全く同じ「所属部署」と「役職」を持つ社員を抽出する

```sql
SELECT 社員名, 所属部署コード, 役職コード
FROM 社員マスタ
WHERE (所属部署コード, 役職コード) = (SELECT 所属部署コード, 役職コード FROM 社員マスタ WHERE 社員番号 = 'S0010')
  AND 社員番号 <> 'S0010';
```

**解説**:
1.  サブクエリは、社員番号'S0010'の人物の所属部署コードと役職コードの**一組の値**（例：`('DEP02', 'MGR')`）を返します。
2.  このSQLは、各社員の `(所属部署コード, 役職コード)` の組（**２つのカラム両方とも**）が、サブクエリの返した組 `('DEP02', 'MGR')` と一致するものをリストアップします。
これにより、複数の条件を `AND` で個別に繋ぐよりも、意図が明確で簡潔なSQLを記述できます。

---

### 3. 複数行サブクエリ（値のリスト【集合】と比較する）

複数行サブクエリは、結果として**複数行1列の値**、つまり「**値のリスト【集合】**」を返します。

*   **戻り値**: 複数行1列
*   **使用演算子**: `IN`／`NOT IN`, 比較演算子＋`ANY`／`ALL`
*   **考え方**: サブクエリが返すのは値のリスト【集合】なので、`=` のような単一値向けの演算子は使えません。「リスト【集合】に含まれるか」「リスト【集合】のいずれかの値より大きいか」「リスト【集合】のすべての値より大きいか」といった、【集合】に対する演算子を用います。

#### SQL例：大阪支社のいずれかの社員と同じ給与額の、東京支社の社員を抽出する

```sql
SELECT 社員名, 給与
FROM 社員
WHERE 勤務地 = '東京'
  AND 給与 IN (SELECT 給与 FROM 社員 WHERE 勤務地 = '大阪');
```

**解説**:
1.  サブクエリ `(SELECT 給与 FROM 社員 WHERE 勤務地 = '大阪')` が実行され、大阪支社に勤務する社員の給与の**リスト【集合】**（例：`(250000, 320000, 450000)`）が返されます。
2.  主文のSQLは、東京支社の社員の中から、給与がこのリストの**いずれかの値と一致する**社員を `IN` 演算子で絞り込みます。
3.  もしここで誤って `WHERE 給与 =（サブクエリ）` と記述すると、サブクエリが`複数の値`を返す可能性があるため、エラーが発生します。
* この **「`=`と`IN`の使い分け」**は、試験で頻繁に問われる重要ポイントです。※間違えた

### 4.１ 複数行サブクエリ（IN / NOT IN / ANY / ALL）の詳論

### **WHERE句の役割：行を選択するための評価式**

まず、`WHERE`句の根本的な役割は、「`FROM`句で指定されたテーブルの一行ごとに、そこに書かれた条件式が**真 (TRUE)** になるか、**偽 (FALSE)** になるかを評価すること」です。

データベースシステムは、テーブルの`全行`を対象にこの評価を行い、条件式が**真 (TRUE) となった`行`だけ**を集めて、`最終的な結果`として返します。

#### **サンプルのテーブル**

以下の2つのテーブルを例として使用します。

**`社員`テーブル** (主テーブル)

| 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
| :--- | :--- | :--- | :--- | :--- |
| S001 | 鈴木 | 営業部 | リーダー | 85 |
| S002 | 田中 | 開発部 | マネージャー| 95 |
| S003 | 佐藤 | 営業部 | 一般 | 70 |
| S004 | 高橋 | 経理部 | 一般 | 75 |
| S005 | 渡辺 | 開発部 | リーダー | 90 |

**`重点プロジェクト部門`テーブル** (サブクエリで使用)
| 部署名 |
| :--- |
| 開発部 |
| 経理部 |
---
###　（１） **IN**
`WHERE`句に指定された列の値が、サブクエリが生成した値のリストの**いずれかの値と等しい**場合、その行に対する評価は**真 (TRUE)** となります。

*   **評価プロセス**:
    `WHERE 列A IN (SELECT 列X FROM TableB)` という条件式は、`FROM`句のテーブルから取り出した一行の `列A` の値について、以下の論理式と同じ評価を行います。
    *   `列A = (サブクエリ結果1) OR 列A = (サブクエリ結果2) OR ...`
    *   この `OR` 条件のいずれか一つでも成立すれば、式全体が**真 (TRUE)** と評価されます。

*   **選択される行**:
    上記評価が**真 (TRUE)** となった`すべて`の`行`が、`最終的な結果`として選択されます。

*   **サンプルSQL**:
    `重点プロジェクト部門`に所属する社員を検索します。
    ```sql
    SELECT *
    FROM 社員
    WHERE 所属部署 IN (SELECT 部署名 FROM 重点プロジェクト部門);
    ```
    ※サブクエリは `('開発部', '経理部')` というリストを返します。

*   **出力結果**:
    | 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
    | :--- | :--- | :--- | :--- | :--- |
    | S002 | 田中 | 開発部 | マネージャー| 95 |
    | S004 | 高橋 | 経理部 | 一般 | 75 |
    | S005 | 渡辺 | 開発部 | リーダー | 90 |

###　（２）  **NOT IN**

`WHERE`句に指定された列の値が、サブクエリが生成した値のリストの**どの値とも等しくない**場合、その行に対する評価は**真 (TRUE)** となります。

*   **評価プロセス**:
    `WHERE 列A NOT IN (SELECT 列X FROM TableB)` という条件式は、以下の論理式と同じ評価を行います。
    *   `列A <> (サブクエリ結果1) AND 列A <> (サブクエリ結果2) AND ...`
    *   この `AND` 条件がすべて成立した場合にのみ、式全体が**真 (TRUE)** と評価されます。

*   **選択される行**:
    上記評価が**真 (TRUE)** となった`すべて`の行が、最終的な結果として選択されます。

*   **サンプルSQL**:
    `重点プロジェクト部門`に所属して**いない**社員を検索します。
    ```sql
    SELECT *
    FROM 社員
    WHERE 所属部署 NOT IN (SELECT 部署名 FROM 重点プロジェクト部門);
    ```

*   **出力結果**:
    | 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
    | :--- | :--- | :--- | :--- | :--- |
    | S001 | 鈴木 | 営業部 | リーダー | 85 |
    | S003 | 佐藤 | 営業部 | 一般 | 70 |

---

# SQLにおけるANY述語とALL述語

`ANY`述語と`ALL`述語は、どちらも`WHERE`句などでサブクエリ（副問合せ）が返す複数の値と比較を行う際に使用する述語です。それぞれの意味と動作を正確に理解することが重要です。

---

## （３） ANY
`ANY`は、`WHERE`句に指定された列の値と、サブクエリが生成した値のリストの各値とを比較演算子で評価した結果、その**いずれか一つでも真 (TRUE) になれば**、その行に対する評価を**真 (TRUE)** とします。

### 評価プロセス

`WHERE 列A > ANY (SELECT 列X FROM TableB)` という条件式は、サブクエリが返した結果リストに対して、以下の`OR`条件で評価されることと同じ意味になります。

*   `(列A > サブクエリ結果1) OR (列A > サブクエリ結果2) OR ...`

この `OR` 条件のいずれか一つでも成立すれば、式全体が**真 (TRUE)** と評価されます。これは実質的に、`列A` が**サブクエリ結果の最小値より大きい**ことを意味します。

### サンプルSQLと解説

**目的**: 営業部の**誰か一人でもいいので**、その人より評価点が高い社員を全社から検索します。

```sql
SELECT *
FROM 社員
WHERE 評価点 > ANY (SELECT 評価点 FROM 社員 WHERE 所属部署 = '営業部');
```

#### SQLの実行フロー

1.  サブクエリ `(SELECT 評価点 FROM 社員 WHERE 所属部署 = '営業部')` が実行され、営業部の評価点リスト【集合】 `(85, 70)` を返します。
2.  `ANY`条件は、この集合 `(85, 70)` のいずれかの値より大きければ良いと解釈されるため、「`70点より大きい`」という条件と同じになります。

#### 出力結果

| 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
| :--- | :--- | :--- | :--- | :--- |
| S001 | 鈴木 | 営業部 | リーダー | 85 |
| S002 | 田中 | 開発部 | マネージャー| 95 |
| S004 | 高橋 | 経理部 | 一般 | 75 |
| S005 | 渡辺 | 開発部 | リーダー | 90 |

---

## （４） ALL
`ALL`は、`WHERE`句に指定された列の値と、サブクエリが生成した値のリストの各値とを比較演算子で評価した結果、その**すべてが真 (TRUE) になった場合のみ**、その行に対する評価を**真 (TRUE)** とします。

### 評価プロセス

`WHERE 列A > ALL (SELECT 列X FROM TableB)` という条件式は、サブクエリが返した結果リストに対して、以下の`AND`条件で評価されることと同じ意味になります。

*   `(列A > サブクエリ結果1) AND (列A > サブクエリ結果2) AND ...`

この `AND` 条件がすべて成立した場合にのみ、式全体が**真 (TRUE)** と評価されます。これは実質的に、`列A` が**サブクエリ結果の最大値より大きい**ことを意味します。

### サンプルSQLと解説

**目的**: 営業部の**全員**よりも評価点が高い社員を全社から検索します。

```sql
SELECT *
FROM 社員
WHERE 評価点 > ALL (SELECT 評価点 FROM 社員 WHERE 所属部署 = '営業部');
```

#### SQLの実行フロー

1.  サブクエリ `(SELECT 評価点 FROM 社員 WHERE 所属部署 = '営業部')` が実行され、営業部の評価点リスト `(85, 70)` を返します。
2.  `ALL`条件は、この集合 `(85, 70)` のすべての値より大きくなければならないと解釈されるため、「`85点より大きい`」という条件と同じになります。

#### 出力結果

| 社員番号 | 氏名 | 所属部署 | 役職 | 評価点 |
| :--- | :--- | :--- | :--- | :--- |
| S002 | 田中 | 開発部 | マネージャー| 95 |
| S005 | 渡辺 | 開発部 | リーダー | 90 |

---

# １－３　試験の着眼点

応用情報技術者試験では、`ANY`と`ALL`の使い分けや、類似した機能を持つ`IN`との違いが問われます。以下のポイントを押さえておきましょう。

*   **述語の役割の違い**
    *   **IN／NOT IN** は「集合との一致／不一致」を評価します。
    *   **ANY／ALL** は「比較演算子 (`>`, `<`, `=`など) と組み合わせて使う」ことで、集合の要素と比較評価を行います。

*   **条件の言い換え**
    `ANY`と`ALL`は、比較演算子と組み合わせることで特定の条件と同義になります。この言い換えを覚えておくと理解が深まります。
    *   `> ANY` = 最小値より大きいか
    *   `< ALL` = 最大値より小さいか

*   **出題傾向**
    出題者は、受験者が「`ANY` と `ALL` を混同させる」パターンをよく狙います。それぞれの意味（`ANY`は`OR`、`ALL`は`AND`）を論理的に正確に理解しておくことが重要です。
---

## `IN`と`ANY`の違い【重要】

### 結論から：一番大事な違い

*   **`IN`** は、**「＝（等しい）」** の比較しかできません。
*   「このリストの中に、**全く同じものが存在しますか？**」という、**所属確認**のための演算子です。

*   **`ANY`** は、**「＞」や「＜」などの比較演算子**と一緒に使います。
*   「このリストの中の、**どれか一つにでも勝てますか？（あるいは負けますか？）**」という、**大小比較**のための演算子です。

この「**イコールだけの`IN`**」と「**大小比較もできる`ANY`**」という点が、根本的な違いです。

---

### ２つの演算子を並べて、徹底比較してみましょう

同じ`社員`テーブルと、比較対象として**営業部の評価点リスト `(85, 70)`** を使って、両者の動きの違いを見ていきます。

#### **`IN`**：ゲストリストでの本人確認

`IN`は、リストに**含まれているか**、その一点のみをチェックします。

**例題**: 「評価点が、営業部の評価点リスト `(85, 70)` の**どちらかと一致する**社員は誰か？」

```sql
SELECT 氏名, 評価点
FROM 社員
WHERE 評価点 IN (85, 70);
```

**SQLの頭の中**:
*   鈴木(85点) → リストに `85` があるか？ → YES → **選択**
*   田中(95点) → リストに `95` があるか？ → NO → 除外
*   佐藤(70点) → リストに `70` があるか？ → YES → **選択**
*   高橋(75点) → リストに `75` があるか？ → NO → 除外
*   渡辺(90点) → リストに `90` があるか？ → NO → 除外

**出力結果**:
| 氏名 | 評価点 |
| :--- |（１）-- |
| 鈴木 | 85 |
| 佐藤 | 70 |

---

#### **`ANY`**：大会での予選通過

`ANY`は、リストの中の**誰か一人にでも**勝てればOK、というルールです。

**例題**: 「評価点が、営業部の評価点リスト `(85, 70)` の**どちらか一つより大きい**社員は誰か？」

```sql
SELECT 氏名, 評価点
FROM 社員
WHERE 評価点 > ANY (85, 70);
```
※ > ANY (85, 70)なら、`>70`の条件となる。
**SQLの頭の中**:
*   鈴木(85点) → `85 > 70` はYES。 **選択**
*   田中(95点) → `95 > 70` はYES。**選択**
*   佐藤(70点) → `70 > 70` はNO。 除外
*   高橋(75点) → `75 > 70` はYES。**選択**
*   渡辺(90点) → `90 > 70` はYES。**選択**

**出力結果**:
| 氏名 | 評価点 |
| :--- | :--- |
| 鈴木 | 85 |
| 田中 | 95 |
| 高橋 | 75 |
| 渡辺 | 90 |

---
### 最大の混乱ポイント： `= ANY` は `IN` と同じ

`ANY`は `>` や `<` だけでなく `=` とも一緒に使えます。そして、`= ANY` と書いた場合、**`IN`と全く同じ意味になります。**

`WHERE 評価点 = ANY (85, 70)`

これは、
「`評価点 = 85` **OR** `評価点 = 70`」
と解釈されます。

これは、
`WHERE 評価点 IN (85, 70)`
と完全に同じ動きをします。

この事実が、多くの人を混乱させる原因です。`IN`は`= ANY`の、より直感的で分かりやすい書き方だと考えてください。

### まとめ

| 特徴 | `IN` | `ANY` |
| :--- | :--- | :--- |
| **目的** | リストとの**完全一致**を確認する | リストの**どれか一つ**との大小比較を行う |
| **使う演算子** | **`=`** のみ (暗黙的に) | **`=`、`>`、`<`、`<>`** などと一緒に使う |
| **キーワード** | **所属確認** (Is it IN the list?) | **予選通過** (Can it beat ANYONE in the list?) |
| **`= ANY`との関係** | `IN` は `= ANY` と**全く同じ**意味 | `ANY`は `IN` の機能を包含するが、大小比較が主戦場 |

---

# １－７　一問一答

**Q1** INを使うときの典型的な使い方は？
→ **集合のいずれかと一致**。`= ANY` と等価。

**Q2** NOT INの注意点は？
→ サブクエリの結果に`NULL`があると全体が成立しなくなる。

**Q3** `> ANY (集合)` の意味は？
→ 集合の`最小値`より大きければ成立。

**Q4** `< ALL (集合)` の意味は？
→ 集合の`最大値`より小さければ成立。

**Q5** 試験で狙われやすい誤解は？
→ ANYとALLを「IN/NOT IN」と混同させること。

---

# １－８　要約（3行以内）

* **IN／NOT IN** は「集合の一致／不一致」。
* **ANY／ALL** は「比較演算子＋集合」で条件を判定。
* 出題者はANYとALLの取り違えを狙う。

---

#### 各演算子の詳細と注意点

| 演算子 | 判定内容 | 思考パターン / 備考 |
| :--- | :--- | :--- |
| **IN** | 集合に含まれるか | `=ANY` と同義。 |
| **NOT IN** | 集合に含まれないか | **注意**: サブクエリの結果に **NULL が含まれると、比較結果が UNKNOWN となり、全ての行が対象外**になる。比較対象が分からないのに、結果を出すわけにいかないとデーターベースは考える。 |



※ANYは最も緩やかな条件を与える。
| **= ANY** | 集合のどれか1つと等しいか | `IN` と同義。OR的な判定。 |
| **> ANY** | 集合のいずれかの値より大きいか | 「集合の中の**最小値**より大きい」ことと同じ。 |
| **< ANY** | 集合のいずれかの値より小さいか | 「集合の中の**最大値**より小さい」ことと同じ。 |
※ALLはもっとも厳しい条件を与える。
| **= ALL** | 集合の全てと等しいか | 全ての候補が同じ値でない限り成立しないため、実用性は低い。 |
| **> ALL** | 集合の全てより大きいか | 「集合の中の**最大値**より大きい」ことと同じ。 |
| **< ALL** | 集合の全てより小さいか | 「集合の中の**最小値**より小さい」ことと同じ。 |

#### よくある質問と誤解（Q&A）
*   **Q1. `IN` と等価な表現はどれか。**
    *   **A1.** `=ANY`。集合の中のいずれか一つに一致すればよいため。
*   **Q2. 「給与が部署10の全員より高い社員」を求めるにはどの演算子か。**
    *   **A2.** `>ALL`。全員との比較はAND条件に相当するため。
*   **Q3. 「給与が部署10の誰か一人より高い社員」を求めるにはどの演算子か。**
    *   **A3.** `>ANY`。一人でも超えればよいOR条件に相当するため。
*   **Q4. `NOT IN` のサブクエリに `NULL` が含まれるとどうなるか。**
    *   **A4.** 全ての比較が `UNKNOWN` となり、結果は0件になる。
*   **Q5. 「すべての候補値に等しい」を表すのはどの演算子か。**
    *   **A5.** `=ALL`。ただし、実用上ほとんど使われない。

### 2.3. EXISTS / NOT EXISTS との組み合わせ
サブクエリが1行以上の結果を返すかどうか（存在するかどうか）を判定します。多くの場合、相関サブクエリと組み合わせて使用されます。

*   **目的**: 関連するデータが存在するかどうかに基づいて行を抽出する。
*   **特徴**: サブクエリが返す実際の値は無視され、行の有無のみが評価されます
*   `別のファイルで解説`



### 2.4. WHERE句サブクエリの注意点と試験対策

#### 代表的な誤答・凡ミス
1.  **スカラサブクエリが複数行を返してエラー**
    *   **原因**: `=` などの比較演算子を使っているのに、サブクエリが複数行を返してしまうケース。
    *   **対策**: サブクエリが必ず1行1列になるよう、`MAX`, `MIN`, `AVG` などの集約関数を使うか、`IN` 演算子に切り替える。
2.  **`NOT IN` でのNULLの扱いによる意図しない結果**
    *   **原因**: `NOT IN` のサブクエリ結果に `NULL` が含まれていると、比較が `UNKNOWN` となり、意図せず結果が0件になる。
    *   **対策**: `NOT EXISTS` を使用する方が安全。
3.  **EXISTS と IN の意味の違いの混同**
    *   **原因**: `IN` は「値の集合」に含まれるかを比較するのに対し、`EXISTS` はサブクエリの「行の存在」そのものを問う。この違いを理解せず、使い分けを誤る。
4.  **相関サブクエリと非相関サブクエリの混同**
    *   **原因**: 外側の行ごとにサブクエリが実行される相関サブクエリの構造を理解せず、非効率なクエリを作成してしまう。

#### 性能上の留意点
*   **相関サブクエリ**: 外側の各行ごとにサブクエリが実行されるため、行数が増えると性能が低下しやすい。インデックスの活用が重要。
*   **非相関サブクエリ**: サブクエリは一度だけ実行され、その結果がキャッシュされることが多い。ただし、巨大な結果セットを生成する場合は注意が必要。
*   **EXISTS**: 条件を満たす最初の行が見つかった時点で評価が終了する（早期終了）ため、`IN` よりも高速になることがある。
*   **JOINへの書き換え**: サブクエリは `JOIN` を使って書き換えられる場合があり、オプティマイザがインデックスを効率的に利用できるため、性能が向上することがある。