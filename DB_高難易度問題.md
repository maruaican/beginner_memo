### **問題1
**シナリオ**: ある企業では、コンプライアンス上の理由から、「全社員の給与総額は、会社全体の予算テーブルに記録された人件費予算を超えてはならない」という極めて重要なルールが存在する。このルールは、個々の`社員`テーブルや`給与`テーブルへの`CHECK`制約では実現できない。データベース全体の状態を監視し、このルールを一貫して保証するためのSQL定義を完成させてください。
```sql
CREATE 【 a 】 全社人件費制約
【 b 】 (
    (SELECT SUM(給与) FROM 給与テーブル)
    <=
    (SELECT 予算額 FROM 予算テーブル WHERE 費目 = '人件費')
);
```
**【回答】**
`a`: ASSERTION
`b`: CHECK

**【この構文が必要な理由】**
単一のテーブルや行に対する制約（`CHECK`制約）では定義不可能な、**複数のテーブルや全行にまたがるデータベース全体の状態に対する整合性ルール**を定義するために、SQL標準で定められた`ASSERTION`（表明）が必要となるため。

**【構文の解説】**
*   **`CREATE ASSERTION <表明名> CHECK ( <条件式> )`**:
    *   `ASSERTION`は、特定のテーブルに属さず、スキーマの一部として定義される制約です。
    *   `CHECK`句の中に記述された条件式は、データベースに対する**あらゆる変更（INSERT, UPDATE, DELETE）が行われた後**に評価されます。
    *   もしこの条件式が`FALSE`を返すような変更（例：人件費予算を超えて給与を増額する、予算額を減額する等）が試みられた場合、その変更処理はデータベース管理システム（DBMS）によって拒否され、トランザクションはロールバックされます。
*   **IPA試験における重要性**:
    *   `ASSERTION`はSQL標準で規定されているものの、**多くの主要な商用DBMSでは実装されていないか、機能が制限されています**。実務で目にすることは稀です。
    *   しかし、IPA試験では、このような**理論的な概念や標準規格に関する知識**が頻繁に問われます。`CHECK`制約との違い（単一テーブルの行 vs データベース全体）を明確に理解し、どのようなシナリオで`ASSERTION`が必要になるのかを説明できることが、高得点を狙う上で不可欠です。まさに、実務と試験の乖離を象徴するトピックと言えます。

---

### **問題2
**シナリオ**: 返却期限を過ぎている延滞中の貸出レコードを全て抽出し、1件ずつループ処理を行いたい。ループの中では、各貸出に対して延滞日数を計算し、その日数に基づいて`会員`テーブルの`延滞ポイント`を更新（1日あたり5ポイント加算）するという、行単位での複雑な更新処理をストアドプロシージャで実装してください。
```sql
DECLARE @v_貸出ID INT, @v_会員ID INT, @v_返却予定日 DATE;
DECLARE 延滞リストカーソル 【 a 】
    SELECT 貸出ID, 会員ID, 返却予定日
    FROM 貸出テーブル
    WHERE 返却日 IS NULL AND 返却予定日 < CURRENT_DATE;

【 b 】 延滞リストカーソル;

【 c 】 延滞リストカーソル 【 d 】 @v_貸出ID, @v_会員ID, @v_返却予定日;

WHILE @@FETCH_STATUS = 0
BEGIN
    -- 延滞日数を計算し、ポイントを更新
    DECLARE @延滞日数 INT;
    SET @延滞日数 = DATEDIFF(day, @v_返却予定日, CURRENT_DATE);

    【 e 】 会員テーブル
    【 f 】 延滞ポイント = 延滞ポイント + (@延滞日数 * 5)
    WHERE 会員ID = @v_会員ID;

    【 c 】 NEXT FROM 延滞リストカーソル 【 d 】 @v_貸出ID, @v_会員ID, @v_返却予定日;
END;

【 g 】 延滞リストカーソル;
【 h 】 延滞リストカーソル;
```
**【回答】**
`a`: CURSOR FOR
`b`: OPEN
`c`: FETCH
`d`: INTO
`e`: UPDATE
`f`: SET
`g`: CLOSE
`h`: DEALLOCATE

**【この構文が必要な理由】**
`SELECT`文で得られた結果セット（複数の行）を、通常のSQLのように一括で処理するのではなく、**プログラムのループのように1行ずつ順番に取り出し、各行のデータを使って個別の、あるいは複雑な手続き的処理を実行する**ために、カーソル（Cursor）が必要不可欠だからです。

**【構文の解説】**
*   **カーソル操作の一連の流れ**:
    1.  **`DECLARE ... CURSOR FOR ...`**: カーソルを宣言します。カーソルがどの`SELECT`文の結果セットを保持するかを定義します。
    2.  **`OPEN`**: カーソルを開き、`SELECT`文を実行して結果セットをメモリ上に準備します。
    3.  **`FETCH ... INTO ...`**: カーソルから**次の1行**を取得し、`INTO`句で指定した変数に行の値を格納します。`@@FETCH_STATUS`（DBMSにより異なる）のようなグローバル変数で、`FETCH`が成功したか（次の行があったか）を判定できます。
    4.  **`WHILE`ループ**: `FETCH`が成功している間、ループ処理を続けます。この`BEGIN ... END`ブロック内で、変数に格納された値を使った個別の処理（この場合は`UPDATE`文）を実行します。
    5.  **`CLOSE`**: カーソルの使用を終了します。
    6.  **`DEALLOCATE`**: カーソルが使用していたメモリリソースを解放します。
*   **IPA試験における重要性**:
    *   カーソルは、大量のデータに対してループ処理を行うとパフォーマンスが著しく低下するため、現代のSQLプログラミングでは可能な限り**カーソルを使わない集合指向のSQL（`CASE`式やウィンドウ関数など）で解決することが推奨**されています。
    *   しかし、IPA試験では、このような手続き的なアルゴリズムの理解度を問う問題が依然として出題される可能性があります。カーソルの一連のライフサイクル（宣言→オープン→フェッチ→クローズ→解放）と、各ステップで使われるSQLキーワードを正確に記憶しておくことが重要です。

---

### **問題3
**シナリオ**: ある会社が「東京本社」と「大阪支社」にそれぞれ顧客データベースを持っています。今年度の新規顧客について、①両方の拠点に登録されている顧客も含め、全拠点の新規顧客リストを**重複を許して**単純に連結したリスト（`UNION ALL`を使用）と、②両方の拠点に登録されている顧客の重複を排除し、ユニークな顧客のみを抽出したリスト（`UNION`を使用）を作成する2つのビューを定義してください。
```sql
-- ビュー1: 重複を許す全リスト
CREATE VIEW 全新規顧客リスト_重複あり AS
SELECT 顧客ID, 氏名, 登録拠点 FROM 東京本社DB.新規顧客
【 a 】
SELECT 顧客ID, 氏名, 登録拠点 FROM 大阪支社DB.新規顧客;

-- ビュー2: 重複を排除したユニークリスト
CREATE VIEW 全新規顧客リスト_重複なし AS
SELECT 顧客ID, 氏名, 登録拠点 FROM 東京本社DB.新規顧客
【 b 】
SELECT 顧客ID, 氏名, 登録拠点 FROM 大阪支社DB.新規顧客;
```
**【回答】**
`a`: UNION ALL
`b`: UNION

**【この構文が必要な理由】**
複数の`SELECT`文の結果セットを縦に結合する「集合演算」において、**業務要件に応じて重複行を許容するか、あるいは排除するかを明確に制御する**ために、`UNION ALL`と`UNION`という2つの異なる演算子を正しく使い分ける必要があるためです。

**【構文の解説】**
*   **`UNION ALL`**:
    *   2つの結果セットを、単純に**そのまま連結**します。
    *   重複行のチェックを行わないため、`UNION`に比べて**パフォーマンス上有利**です。
    *   「各拠点の登録イベントそのものをリストアップしたい」「後続の処理で`GROUP BY`を使って集計するので、重複は問題ない（むしろ必要）」といったシナリオで選択されます。
*   **`UNION`**:
    *   2つの結果セットを連結した後、**結果セット全体から重複する行をすべて排除**します。`SELECT DISTINCT`を全体にかけたのと同じ効果があります。
    *   内部的に重複チェックのためのソート処理などが発生するため、`UNION ALL`よりも処理コストが高くなります。
    *   「全社でユニークな顧客リストが欲しい」といった、結果の一意性が求められるシナリオで使用されます。
*   **IPA試験における重要性**:
    *   両者の違いは単純ですが、その**パフォーマンス特性の違い**と、**どのような業務要件のときにどちらを選択すべきか**を問われる可能性があります。「処理速度が求められる大規模なデータ集計の中間段階では`UNION ALL`を使い、最終的なレポートでは`UNION`で重複を排除する」といった、文脈に応じた使い分けができるかが、深い理解の証となります。


    ### **問題3
**シナリオ**: `注文明細`テーブルにレコードが`INSERT`された際、自動的に`在庫`テーブルの在庫数を引き当てる（減算する）トリガを作成します。その際、もし引き当てによって在庫数が0になった場合は、その商品の`在庫`テーブルの`ステータス`列を「在庫切れ」に更新してください。さらに、この一連の在庫変動（在庫数の減少と、場合によってはステータス変更）の前後状態をすべて`在庫変更履歴`テーブルに記録してください。
```sql
CREATE TRIGGER 在庫引き当てトリガ
【 a 】 INSERT ON 注文明細
【 b 】
BEGIN
    -- 在庫数の取得と比較
    DECLARE current_stock INT;
    SELECT 在庫数 INTO current_stock FROM 在庫 WHERE 商品ID = 【 c 】.商品ID;

    -- 在庫更新
    UPDATE 在庫
    SET
        在庫数 = 在庫数 - 【 c 】.注文数量,
        ステータス = 【 d 】
            WHEN (在庫数 - 【 c 】.注文数量) = 0 THEN '在庫切れ'
            ELSE ステータス
        END
    WHERE 商品ID = 【 c 】.商品ID;

    -- 履歴の記録
    INSERT INTO 在庫変更履歴 (商品ID, 変更日時, 変更前在庫数, 変更後在庫数, 変更前ステータス, 変更後ステータス, トリガ種別)
    SELECT
        【 e 】.商品ID,
        CURRENT_TIMESTAMP,
        current_stock,
        在庫数,
        (SELECT ステータス FROM 在庫 WHERE 商品ID = 【 e 】.商品ID), -- 更新前のステータスを取得
        ステータス, -- 更新後のステータス
        'INSERT'
    FROM 在庫 WHERE 商品ID = 【 e 】.商品ID;
END;
```
**【回答】**
`a`: AFTER
`b`: FOR EACH ROW
`c`: NEW
`d`: CASE
`e`: NEW

**【この構文が必要な理由】**
`注文明細`へのデータ追加というイベントを起点に、複数のテーブル（`在庫`, `在庫変更履歴`）にまたがる一連のデータ更新処理を、**原子性（Atomicity）を保ちつつ自動実行**するためには、行単位で動作するトリガが必須だからです。特に、`INSERT`されたばかりの行のデータ（`NEW`）を参照し、それに基づいて既存のテーブルのデータを更新前（`OLD`の概念）と更新後で比較・判断するという、手続き型の複雑なビジネスロジックを実装する能力が問われます。

**【構文の解説】**
*   **`AFTER INSERT ON 注文明細`**: トリガが起動するタイミングとイベントを指定します。`注文明細`テーブルへの`INSERT`処理が完了した**後**に実行されます。
*   **`FOR EACH ROW`**: 文トリガ（`FOR EACH STATEMENT`）と対になる句で、`INSERT`文によって影響を受けた**行ごと**にトリガ本体の処理が実行されることを示します。これにより、複数行同時に`INSERT`された場合でも、1行ずつ確実に在庫引き当て処理が行われます。
*   **`NEW`擬似レコード**: トリガの内部では、`INSERT`された行の値を`NEW`という特別な変数で参照できます。`NEW.商品ID`や`NEW.注文数量`とすることで、どの商品の注文が何個入ったかを特定し、後続の`UPDATE`文や`INSERT`文で利用します。(`UPDATE`トリガでは更新前の`OLD`と更新後の`NEW`が両方使え、`DELETE`トリガでは`OLD`のみが使えます)
*   **`CASE`式による条件付き更新**: `UPDATE`文の`SET`句の中で`CASE`式を用いることで、更新後の値に条件分岐を組み込んでいます。「引き当て後の在庫数が0になるならステータスを'在庫切れ'にする、そうでなければ元のまま」というロジックを1つの`UPDATE`文で実現する高度なテクニックです。
*   **履歴のINSERT処理**: 最後に、在庫の変動履歴を記録します。ここでも`NEW.商品ID`を使って対象商品を特定します。更新前後の状態を記録するために、トリガ内で更新前の値を一度変数に保持したり、`UPDATE`後のテーブルから再度`SELECT`し直したりといった工夫が必要となり、手続き的な思考が求められます。
