
## プロセッサのパイプライン処理とハザード解説

### 1. パイプライン方式の目的と本質

#### 1.1. パイプライン方式の目的
パイプライン方式の**本質的な目的は、CPUを「暇にさせない」こと**です。

CPUが命令を一つずつ順番に実行（逐次実行）する場合、ある命令の全工程（命令読み出し→解読→実行→書き戻し）が完了するまで、次の命令は待機しなければなりません。これでは、CPU内の各部品が同時に動かず、処理していない時間（アイドル時間）が発生してしまいます。

そこで、パイプライン方式では、命令の処理を複数のステージ（工程）に分割し、**工場の流れ作業のように各ステージを並列で稼働させます。** これにより、1サイクルごとに出力を生み出すことが可能になり、CPU全体の処理性能を向上させます。

*   **処理ステージの分割例**
    パイプラインは、命令の実行を以下のような独立したステージに分割します。
    *   **[取] 命令フェッチ**：メモリから命令を読み出す
    *   **[解] 命令デコード**：読み出した命令を解読する
    *   **[実] 実行**：解読結果に基づき、演算などを実行する
    *   **[書] 書き戻し**：実行結果をレジスタやメモリに格納する

*   **並列実行のイメージ**
    各ステージが流れ作業のように同時に動くことで、複数の命令が並行して処理されます。

    ```
    命令1   [取]─[解]─[実]─[書]
    命令2        [取]─[解]─[実]─[書]
    命令3             [取]─[解]─[実]─[書]
    ```
    このように、各命令が「ずらして」進むことで、複数命令を同時に処理できます。

#### 1.2. パイプラインハザードとは
パイプライン処理の理想は「すべての命令が独立している」場合にのみ成立します。しかし、実際のプログラムでは命令同士の依存関係などが存在し、この流れ作業がスムーズに進まないことがあります。

**パイプラインハザード**とは、パイプライン処理の実行中に、命令同士の依存関係や資源の競合により、処理を待機（ストップ）したり、途中まで進めた処理を破棄してやり直したり（リセット）しなければならなくなる状況を指します。

このハザードが発生すると、理想的な並列処理が崩れ、せっかくの高速化の効果が損なわれてしまいます。つまり、**パイプラインが"流れ作業"として機能しなくなるのが問題の本質**です。

### 2. パイプラインハザードの3分類

パイプラインハザードは、発生原因によって以下の3種類に分類されます。名称は「CPUが何に困っているか（原因）」を示しており、実際の現象としては「待ち」や「無駄」として現れます。

---
### 2.1. 構造ハザード (Structural Hazard)

#### 概要
CPU内部の**構造的な資源（ハードウェア資源）の競合**が原因で発生するハザードです。複数の命令が、同時に同じハードウェア資源（演算器やメモリなど）を使おうとすることで発生します。

*   **語源:** CPUの設計、**構造 (Structure)** に起因することから名付けられました。
*   **現象:** 資源の取り合いによる「**待ち**」が発生します。

#### 本質的な問題
CPUの各ステージは「同時並行」で動こうとするのに、同じ部品（資源）を同時に使えないために足止めが発生します。本来は並列処理できるはずが、順番待ちによって直列処理に戻ってしまい、高速化の効果が打ち消される点が問題です。

#### 具体例
*   ある命令が命令メモリから命令を読み込んでいる（命令フェッチ）と同時に、別の命令がデータメモリにアクセスしようとする。しかし、メモリにアクセスするためのポートが一つしかない場合、どちらかが待たなければならない。

#### 対策例
*   **ハードウェアの分割:** 命令専用のキャッシュとデータ専用のキャッシュを用意するなど、競合する資源を分離・追加する。

---

### 2.2. データハザード (Data Hazard)

#### 概要
**処理するデータの依存関係**が原因で発生するハザードです。後続の命令が、直前の命令の実行結果を必要とする場合に発生します。

*   **語源:** 問題の根源が**データ (Data) 依存**にあることから名付けられました。
*   **現象:** 必要なデータがまだ確定していないことによる「**待ち**」が発生します。

#### 本質的な問題
パイプラインは「前の命令の処理が完全に終わる前に、次の命令を開始する」仕組みです。しかし、後続の命令が前の命令の結果に依存している場合、その結果がまだ出ていないため、未確定の値を使うわけにはいきません。間違った値で実行すると誤った結果になるため、正しい値が確定するまで待つしかなく、パイプラインの並列性が崩れて処理効率が低下します。

#### 具体例
*   `R1 ← R2 + R3` という加算命令の直後に、`R4 ← R1 + R5` という命令がある場合、後者の命令は前者の命令で計算された `R1` の新しい値を必要とする。しかし、パイプライン上では `R1` の値が書き戻される前に後者の命令が実行ステージに進んでしまうため、待機（ストール）が必要になる。

#### 対策例
*   **フォワーディング（バイパシング）:** 演算結果をレジスタに書き戻す前に、後続の命令の実行ユニットへ直接転送する。
*   **待機（ストール）:** 依存関係が解消されるまで、パイプラインの進行を意図的に停止させる。

---

### 2.3. 制御ハザード (Control Hazard)

#### 概要
**分岐命令や割り込み処理**が原因で発生するハザードです。「次にどの命令を実行すべきか」という**命令の制御フロー (Control Flow)** が実行時まで確定しないために発生します。**分岐ハザード**とも呼ばれます。

*   **語源:** 命令の**制御 (Control)** の流れが不確定になることから名付けられました。
*   **現象:** 予測して先読みした命令が間違っていた場合に、それらを破棄してやり直す「**無駄**」が発生します。

#### 本質的な問題
パイプラインは「次に実行する命令をあらかじめ読み込んでおく（先読み）」ことで高速化を実現しています。しかし、条件分岐命令（if文など）が登場すると、その条件が確定するまで次にどちらの命令（AかBか）を読み込めばよいか分かりません。このため、先読みが無駄になる可能性が生じます。無駄に先読みした命令を破棄し、正しい命令を改めて取り直す必要があり、その時間が空回りとなって性能を低下させます。

#### 具体例
*   `if (条件) then A else B` という分岐命令において、条件判定が終わる前に、とりあえずAを先に読み込んで処理を進めてしまう。しかし、判定結果が偽だった場合、読み込んでいたA関連の命令はすべて破棄し、改めてBを読み込み直さなければならない。

#### 対策例
*   **分岐予測 (Branch Prediction):** 過去の分岐履歴などから、どちらに分岐するかを予測し、予測に基づいて命令の先読みを行う。
*   **投機実行 (Speculative Execution):** 分岐予測に基づいて、結果が確定する前に命令の実行まで進めてしまう。予測が外れた場合は、実行結果を破棄してやり直す。
*   **分岐遅延スロット (Branch Delay Slot):** 分岐命令の直後に、分岐の結果に関わらず必ず実行される命令を配置する方式（古い方式）。

### 3. ハザードの分類まとめと試験の着眼点

#### 3.1. 原因と現象の対応関係

| 種類 | 原因（名称の由来） | 現象 | CPUが困る理由 |
| :--- | :--- | :--- | :--- |
| **構造ハザード** | **構造**（ハード資源の制約） | **待ち** | 同じ装置を取り合っている |
| **データハザード** | **データ**（命令間の依存関係） | **待ち** | 必要な値がまだ出ていない |
| **制御ハザード** | **実行**制御**フローの不確定） | **無駄** | 次にどの命令を取るか分からない |

*   **問題**：命令の分岐によってパイプラインの先読みが無駄になるのはどのハザードか。
    *   **回答**：**制御ハザード**
    *   **解説**：分岐命令は次にどの命令を読み込むべきか（フェッチするか）が実行時まで不確定になるため、パイプラインの流れが乱れる原因となります。

*   **問題**：先行する命令の加算結果を、直後の命令が利用する際に発生するハザードはどれか。
    *   **回答**：**データハザード**
    *   **解説**：命令間でデータの依存関係があり、結果が出る前に後続の命令が進めない状態です。