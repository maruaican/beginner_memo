***

### **データベースの正規化**

データベースの正規化とは、データの重複をなくし、データの一貫性と整合性を保つために、テーブルの構造を整理・最適化していくプロセスです。正規化を行うことで、以下のような目的を達成します。

##　正規化されていないと困る理由
部署名が変更されると、該当する全社員の部署名を変更せねばならないから。
支店の担当範囲が変更されると、顧客テーブルの該当する行の担当支店コードをすべて変更しなくてはならないから。


##　正規化されていなくても困らない理由
テーブルの内容が、その後一切変更されることはないから。
都道府県名マスタのように、データの内容が未来永劫ほぼ不変だから。
ツアーテーブルに追加された行の値が、その後変更されることはないから。



*   **冗長性の削減:** データの重複を最小化し、ストレージの効率を向上させます。
*   **データの一貫性維持:** データの更新や削除時に発生する可能性のある矛盾（更新異常・削除異常）を防ぎます。
*   **データ操作の簡易化と保守性の向上:** データ構造が明確になり、検索や更新が効率的に行えるようになります。

正規化は段階的に行われ、主に第1正規形から第3正規形までが実務でよく利用されます。以下にそのプロセスを順を追って解説します。

---

### **ステップ1：第1正規形（1NF）への移行**

#### **1. 正規化の出発点：非正規形（UNF）**
正規化されていないテーブルは「非正規形」と呼ばれます。この状態では、一つのセルに複数の値が含まれるなど、データが整理されていません。

**例：非正規形のテーブル**
| 生徒ID | 生徒名 | 科目 | 成績 |
| :--- | :--- | :--- | :--- |
| S001 | 山田 | 数学, 英語 | 90, 85 |
| S002 | 鈴木 | 数学 | 78 |

**問題点:**
*   **冗長性:** 1つのセルに複数の値が含まれており、データを個別に扱うことができません。
*   **操作の困難さ:** 「山田」の数学だけの成績を変更する場合など、部分的な編集が非常に困難です。

#### **2. 第1正規形（1NF）への変換**
第1正規形は、テーブル内のすべてのセルが「原子値（それ以上分割できない値）」を持つように整理された状態です。つまり「1セルに1データ」のルールを徹底します。

**対策：**
非正規形のテーブルを、各データが行ごとに独立するように分割します。

**例：第1正規形のテーブル**
| 生徒ID | 生徒名 | 科目 | 成績 |
| :--- | :--- | :--- | :--- |
| S001 | 山田 | 数学 | 90 |
| S001 | 山田 | 英語 | 85 |
| S002 | 鈴木 | 数学 | 78 |

**課題：**
第1正規形にすることで原子性の問題は解決しますが、新たな問題が発生します。
*   **冗長性:** 「S001」「山田」といった同じ情報が繰り返し記録されています。
*   **更新異常:** 生徒名を変更する場合、その生徒に関連するすべての行を変更する必要があり、修正漏れのリスクが生まれます。

この課題を解決するため、次のステップである第2正規形に進みます。

---

### **ステップ2：第2正規形（2NF）への移行**

第2正規形（2NF）は、第1正規形（1NF）が抱える冗長性の問題を解消するために、「部分関数従属」を排除するステップです。

#### **1. 関連する用語**
2NFを理解するために、いくつかの重要な用語を整理します。

*   **主キー（Primary Key）:** テーブル内の各行を一意に識別するための列（または列の組み合わせ）。NULL値は許容されません。
*   **候補キー（Candidate Key）:** 主キーの候補となるキー。行を一意に識別できるすべての列または列の組み合わせが該当し、主キーはこの中から選ばれます。
*   **複合キー（Composite Key）:** 複数の列を組み合わせて主キーとして使用する場合のキー。

#### **2. 部分関数従属とは？**
**定義:**
複合主キーが設定されているテーブルにおいて、**主キーの一部にのみ依存している**非キー列が存在する状態を「部分関数従属」と呼びます。

**具体例：部分関数従属を含むテーブル（1NF）**
以下のテーブルでは、`生徒ID`と`科目ID`の組み合わせが**複合主キー**です。

| 生徒ID | 科目ID | 生徒名 | 科目名 | 成績 |
| :--- | :--- | :--- | :--- | :--- |
| S001 | C001 | 山田 | 数学 | 90 |
| S001 | C002 | 山田 | 英語 | 85 |
| S002 | C001 | 鈴木 | 数学 | 78 |

**依存関係の分析:**
*   `成績`は、「どの生徒」の「どの科目」の成績かを示すため、`生徒ID`と`科目ID`の両方に依存しています（**完全関数従属**）。
*   `生徒名`は、`生徒ID`だけで決まります。`科目ID`には依存していません。
*   `科目名`は、`科目ID`だけで決まります。`生徒ID`には依存していません。

このように、`生徒名`と`科目名`は複合主キーの一部にのみ依存しているため、**部分関数従属**の状態にあります。

#### **3. 部分関数従属の問題点**
*   **冗長性:** 「山田」や「数学」といった情報が複数回出現し、データに無駄が生じます。
*   **更新異常:** 「山田」さんの名前を変更する場合、関連するすべての行を更新しないとデータに矛盾が生じます。

#### **4. 第2正規形（2NF）への変換**
部分関数従属を解消するには、主キーの一部に依存する列を別のテーブルに分離します。

**対策:**
*   `生徒ID`に依存する`生徒名`を「生徒テーブル」に分離します。
*   `科目ID`に依存する`科目名`を「科目テーブル」に分離します。
*   元のテーブルには、主キー全体に依存する`成績`のみを残します。

**例：第2正規形のテーブル群**

**生徒-成績テーブル**
| 生徒ID | 科目ID | 成績 |
| :--- | :--- | :--- |
| S001 | C001 | 90 |
| S001 | C002 | 85 |
| S002 | C001 | 78 |
*(主キー: `生徒ID` + `科目ID`)*

**生徒テーブル**
| 生徒ID | 生徒名 |
| :--- | :--- |
| S001 | 山田 |
| S002 | 鈴木 |
*(主キー: `生徒ID`)*

**科目テーブル**
| 科目ID | 科目名 |
| :--- | :--- |
| C001 | 数学 |
| C002 | 英語 |
*(主キー: `科目ID`)*

これにより、すべての非キー列が主キー全体に依存するようになり、第2正規形の条件を満たします。

---

### **ステップ3：第3正規形（3NF）への移行**

第3正規形（3NF）は、第2正規形（2NF）の状態から、さらに「推移的関数従属」を排除するステップです。

#### **1. 推移的関数従属とは？**
**定義:**
非キー列が、主キーに直接依存するのではなく、**他の非キー列を介して間接的に依存している**状態を「推移的関数従属」と呼びます。
関係性で示すと `主キー → 非キー列A → 非キー列B` となります。

**具体例：推移的関数従属を含むテーブル（2NF）**
以下の「科目担当」テーブルを考えます。主キーは`科目ID`です。

| 科目ID | 科目名 | 担任ID | 担任名 |
| :--- | :--- | :--- | :--- |
| S01 | 数学 | T01 | 佐藤 |
| S02 | 英語 | T02 | 高橋 |
| S03 | 理科 | T01 | 佐藤 |

**依存関係の分析:**
1.  `科目名`と`担任ID`は、主キーである`科目ID`によって決まります (`科目ID` → `科目名`, `科目ID` → `担任ID`)。
2.  `担任名`は、非キー列である`担任ID`によって決まります (`担任ID` → `担任名`)。

この結果、`担任名`は`担任ID`を介して、主キー`科目ID`に間接的に依存しています。これが**推移的関数従属**です。

#### **2. 推移的関数従属の問題点**
*   **冗長性:** 担任ID「T01」に対応する「佐藤」という名前が複数回記録されています。
*   **更新異常:** 担任の「佐藤」先生の名前が変更になった場合、`担任ID`が`T01`であるすべての行を修正する必要があり、データの不整合を招く可能性があります。
*   **削除時異常:** もし科目の「理科」が廃止され行を削除すると、「佐藤先生(T01)」が担当する科目が他にない場合、佐藤先生自身の情報まで失われてしまいます。

#### **3. 第3正規形（3NF）への変換**
推移的関数従属を解消するには、非キー列間の依存関係を別のテーブルに分離します。

**対策:**
*   `担任ID`に依存する`担任名`を「担任テーブル」として分離します。
*   元のテーブルには、主キーに直接依存する列のみを残します。

**例：第3正規形のテーブル群**

**科目テーブル**
| 科目ID | 科目名 | 担任ID |
| :--- | :--- | :--- |
| S01 | 数学 | T01 |
| S02 | 英語 | T02 |
| S03 | 理科 | T01 |
*(主キー: `科目ID`)*

**担任テーブル**
| 担任ID | 担任名 |
| :--- | :--- |
| T01 | 佐藤 |
| T02 | 高橋 |
*(主キー: `担任ID`)*

これにより、すべての非キー列が主キーに直接依存する形となり、第3正規形の条件を満たします。

---

### **補足情報**

#### **1. 第2正規形と第3正規形の違いの整理**

「部分関数従属」と「推移的関数従属」は混同されやすいですが、対象とする問題が異なります。

| 項目 | **部分関数従属（2NFで解消）** | **推移的関数従属（3NFで解消）** |
| :--- | :--- | :--- |
| **問題の焦点** | **複合主キー**の一部に非キー列が依存している状態 | 非キー列が**他の非キー列**に依存している状態 |
| **正規化段階** | 第1正規形 → 第2正規形 | 第2正規形 → 第3正規形 |
| **依存関係** | `（主キーの一部）→ 非キー列` | `主キー → 非キー列A → 非キー列B` |
| **解決方法** | 主キーの一部に依存する列を別テーブルに分離 | 非キー列間の依存関係を別テーブルに分離 |

*   **第2正規形（2NF）のルール:**
    *   第1正規形を満たしている。
    *   **主キー以外のキー（＝複合主キーの一部）に依存する非キー列が存在しない。**
*   **第3正規形（3NF）のルール:**
    *   第2正規形を満たしている。
    *   **主キー以外のキー（＝他の非キー列）に依存する非キー列が存在しない。**

簡単に言えば、2NFは**主キーとの関係**を、3NFは**非キー列同士の関係**を整理するステップです。

#### **2. 主キー選定の基準**
適切な主キーの選定は、データベース設計において非常に重要です。

*   **一意性:** テーブル内のすべての行をユニークに識別できること。
*   **非NULL制約:** 必ず値を持ち、NULLであってはならないこと。
*   **安定性:** 値が頻繁に変更される可能性が極めて低いこと。
*   **シンプルさ:** 可能な限り単純で短いデータ型であることが望ましい。

**候補キーが複数ある場合：**
テーブル内に主キーの条件を満たす候補キーが複数存在する場合は、よりシンプルで更新頻度が低いものを主キーとして選定します。場合によっては、元のデータとは無関係な一意のID（代理キー/サロゲートキー）を新たに作成し、主キーとして利用することもあります。

---

### **まとめ：正規化の覚え方**

各正規形のポイントを簡潔に覚えるには、以下のように捉えるのが効果的です。

*   **第1正規形 (1NF):** データを**「ひとつひとつ」**に分ける。（1セル1データ）
*   **第2正規形 (2NF):** 複合主キーの**「全部」**に依存させる。（部分関数従属をなくす）
*   **第3正規形 (3NF):** 主キー**「だけ」**に依存させる。（推移的関数従属をなくす）

実際のシステム設計では、データの利用頻度やパフォーマンス要求に応じて、**必ずしも第3正規形まで行うとは限りません**。
**意図的に正規化を崩す「非正規化」を行う場合もあります**が、基本原則としてこれらの正規化プロセスを理解しておくことは非常に重要です。
