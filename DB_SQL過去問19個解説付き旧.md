
***

## 令和6年秋期 午後 データベース

### １　問題提示

```sql
［令和6年］［秋期
設問２：指定されたカテゴリIDとその配下にあるすべてのサブカテゴリIDを取得し、それらのカテゴリに属する商品を検索条件に基づいて抽出するSQL文。
【e】 指定カテゴリ(カテゴリID, カテゴリ名, 上位カテゴリID) AS (
    SELECT A.カテゴリID, A.カテゴリ名, A.上位カテゴリID
    FROM カテゴリ A WHERE A.カテゴリID = :カテゴリID
    【 f 】
    SELECT B.カテゴリID, B.カテゴリ名, B.上位カテゴリID
    FROM カテゴリ B, 指定カテゴリ C WHERE B.上位カテゴリID = C.カテゴリID
)
SELECT * FROM 出品
INNER JOIN 指定カテゴリ
ON 【 g 】
WHERE 出品.出品価格 BETWEEN :下限価格 AND :上限価格
AND 出品.商品状態 = :商品状態
AND 出品.出品状況 = :出品状況
AND (出品.商品名 【 h 】 OR 出品.商品説明 【 h 】)
```

### ２　解答と解説

#### ２－１　正答
    **e**: WITH RECURSIVE
*   **f**: `UNION ALL`
*   **g**: `出品.カテゴリID = 指定カテゴリ.カテゴリID`
*   **h**: `LIKE `%` || :キーワード　|| `%`


**解答根拠となる技術的要件**
*   **f**: 再帰共通表式（WITH RECURSIVE）では、初期SELECT（アンカーメンバー）と再帰SELECT（再帰メンバー）の結果を`UNION`または`UNION ALL`で結合します。重複排除が不要（例：再帰的な検索）な階層検索では、`UNION ALL`が適切です（削除しないので速い）。
*   **g**: 主問い合わせと共通表式`指定カテゴリ`を結合する条件です。出品情報が属するカテゴリIDと、`指定カテゴリ`で抽出された階層下の全カテゴリIDを結合します。
*   **h**: 問題文の「検索文字列を含む」という要件を満たすため、文字列の部分一致検索を行う`LIKE`演算子を使用します。

#### ２－２　誤答パターン分析
*   **f**: `UNION`の選択。階層データのように重複が発生しない、または許容する場合、不要な重複排除処理が走りパフォーマンスが低下します。
*   **g**: `ON 出品.カテゴリID = :カテゴリID`。これでは指定した最上位カテゴリの商品しか抽出できず、「配下のすべて」という要件を満たせません。
*   **h**: `= :検索文字列`の選択。完全一致比較であり、「含む」という部分一致の要件を満たせません。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「指定カテゴリとその配下の全サブカテゴリ」「商品名又は商品説明に検索文字列を含む」を抽出します。
2.  **SQL構造読解**: `WITH RECURSIVE`から階層問い合わせと判断。【f】は再帰クエリの結合演算子、【g】は主問い合わせとの結合条件、【h】は文字列検索の演算子と特定します。
3.  **キーワード識別**: 「配下のすべて」→`WITH RECURSIVE`, `UNION ALL`。「～を含む」→`LIKE`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **再帰共通表式 (Recursive CTE)**: `WITH RECURSIVE`を用い、階層構造を持つデータを再帰的に問い合わせる機能。
*   **LIKE演算子**: ワイルドカード（`%`, `_`）を使い、文字列の部分一致検索を行います。

#### ３－２　関連概念の整理
*   **UNION vs UNION ALL**: `UNION`は重複行を排除し、`UNION ALL`は重複行を含めます。後者の方が高速です。
*   **INNER JOIN**: 両テーブルに結合キーが存在する行のみを返します。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: `WITH RECURSIVE`において、再帰が停止する条件は何か？
*   **答**: 再帰メンバーのSELECT文が1行も返さなくなった時点です。
*   **解説**: 親子関係の末端に到達し、結合条件を満たす行がなくなると再帰が自然に停止します。

*   **問**: なぜこの問題では`UNION ALL`が推奨されるのか？
*   **答**: カテゴリ階層の探索において重複行が発生しないため、重複排除のオーバーヘッドがない`UNION ALL`がパフォーマンス上有利だからです。

*   **問**: `:検索文字列`に渡す値には何を含めるべきか？
*   **答**: ワイルドカード `%` を含めた文字列（例: `'%キーワード%'`）を渡します。
*   **解説**: `LIKE`演算子は、検索文字列内のワイルドカードを解釈して部分一致検索を行います。

*   **問**: 再帰CTEを使わずに同じ結果を得るにはどうすればよいか？
*   **答**: アプリケーション側でループ処理を行うか、階層の深さが限定的なら自己結合を繰り返す必要があります。
*   **解説**: 階層の深さが不定の場合、再帰CTEがSQL内で完結する最も効率的な方法です。

*   **問**: 【g】の結合条件が間違っていると、どのような誤った結果になるか？
*   **答**: 例えば、最上位カテゴリIDとしか結合しない場合、サブカテゴリに属する商品が検索結果から漏れてしまいます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「階層」「配下」 | `WITH RECURSIVE` |
| 「～を含む」 | `LIKE`演算子 |
| 「～に属する」 | `INNER JOIN` ON (主キー = 外部キー) |

### ５　要約
*   階層構造データは`WITH RECURSIVE`（再帰CTE）を用いて効率的に処理します。
*   再帰CTEの基本構造は、アンカーメンバーと再帰メンバーの`UNION ALL`による結合です。
*   文字列の部分一致検索には`LIKE`演算子とワイルドカード（`%`）の組み合わせが必須です。

***

## 令和6年春期 午後 データベース

*(前回の回答で分析済みのため、再掲します)*

### １　問題提示

```sql
［令和6年］［春期
-- 図2
SELECT 祝日 AS 日付, 祝日名 AS 日付名 FROM 国民の祝日 WHERE 祝日 【 b 】
UNION ALL
SELECT 会社記念日 AS 日付, 会社記念日名 AS 日付名 FROM 会社記念日 WHERE 会社番号 = :会社番号 AND 会社記念日 【 b 】
【 c 】

-- 図3
SELECT DEP.部署番号, DEP.部署名, EMP.従業員番号, EMP.従業員氏名
FROM 従業員 EMP INNER JOIN 部署 DEP ON EMP.会社番号 = DEP.会社番号 【 d 】
WHERE EMP.会社番号 = :会社番号 AND DEP.管理者番号 = :管理者番号
【 c 】

-- 図4
CREATE VIEW 【 e 】 (祝日, 祝日名) AS SELECT 祝日, 祝日名 FROM 【 f 】
```

### ２　解答と解説

#### ２－１　正答
*   **b**: `BETWEEN :開始日 AND :終了日`
*   **c**: `ORDER BY 日付` (図3では `ORDER BY DEP.部署番号, EMP.従業員番号`)
*   **d**: `AND EMP.部署番号 = DEP.部署番号`
*   **e**: `V国民の祝日`
*   **f**: `T国民の祝日`

**解答根拠となる技術的要件**
*   **b**: 「指定された期間内」という要件から、日付の範囲を指定する`BETWEEN`演算子が適切です。
*   **c**: 「日付の昇順」「部署番号、従業員番号の昇順」という要件から、`ORDER BY`句でソートします。`UNION ALL`で結合した場合は、文末に1回だけ記述します。
*   **d**: 従業員テーブル(EMP)と部署テーブル(DEP)を結合するための条件。`会社番号`に加えて`部署番号`での結合が必要です。
*   **e, f**: 問題文の命名規則「ビュー名は接頭語V」「実表名は接頭語T」に従います。

#### ２－２　誤答パターン分析
*   **b**: `祝日 >= :開始日 AND 祝日 <= :終了日`も論理的に正しいですが、`BETWEEN`がより簡潔です。
*   **c**: `ORDER BY`句を`UNION ALL`の前に記述すると、最初のSELECT文にしか適用されません。
*   **d**: 結合条件が不足していると、意図しないデカルト積（直積）が発生し、正しい結果が得られません。
*   **e, f**: 問題文に記載された命名規則を見落とすことによる誤答。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「期間内」「昇順」「結合条件」「命名規則」を問題文から正確に読み取ります。
2.  **SQL構造読解**: 図2は`UNION ALL`による縦結合、図3は`INNER JOIN`による横結合、図4は`CREATE VIEW`の基本構文です。
3.  **キーワード識別**: 「期間内」→`BETWEEN`。「～の順」→`ORDER BY`。「ビュー」「実表」→命名規則の確認。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **UNION ALL演算子**: 複数の`SELECT`文の結果をそのまま縦に連結します。
*   **BETWEEN演算子**: 値が指定範囲内（両端を含む）にあるかどうかを判定します。
*   **ORDER BY句**: 問い合わせ結果を指定した列でソートします。
*   **CREATE VIEW文**: 仮想テーブル（ビュー）を作成するDDL文です。

#### ３－２　関連概念の整理
*   **ON句とWHERE句**: `INNER JOIN`では、結合条件は`ON`句に、絞り込み条件は`WHERE`句に記述するのが可読性の観点から推奨されます。
*   **ビューのメリット**: 複雑なクエリの単純化、セキュリティ向上（必要なデータのみ公開）などがあります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2で`UNION ALL`を`UNION`に変えると、どのような場合に結果が変わるか？
*   **答**: 国民の祝日と会社の記念日が、日付も名前も完全に同じ場合に結果が変わります。
*   **解説**: `UNION`は重複行を1つにまとめるため、その行は1行だけ表示されます。

*   **問**: 図2の`ORDER BY`句で`日付`という別名が使えるのはなぜか？
*   **答**: SQLの論理的な評価順序で`ORDER BY`句は`SELECT`句の後に評価されるため、`SELECT`句で定義した別名が参照できます。

*   **問**: 図3で`INNER JOIN`の代わりに`LEFT JOIN`を使うべきなのはどのようなケースか？
*   **答**: 部署に所属していない従業員も一覧に含めたい場合です。

*   **問**: 図4で作成したビューに対して`INSERT`や`UPDATE`は可能か？
*   **答**: 可能です。
*   **解説**: 単一テーブルから導出され、集約関数や`DISTINCT`などを含まないビューは、一般的に更新可能です。

*   **問**: 問題文の命名規則に従うことの重要性は何か？
*   **答**: システム開発において、一貫した命名規則は可読性や保守性を大幅に向上させるため、極めて重要です。試験問題でもその遵守が求められます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「期間内」「～から～まで」 | `BETWEEN ... AND ...` |
| 「～順で出力」 | `ORDER BY` |
| 「仮想表」「～として見せる」 | `CREATE VIEW` |

### ５　要約
*   複数の問い合わせ結果を縦に結合するには`UNION ALL`を、横に結合するには`JOIN`を使用します。
*   結果の並び順は文末の`ORDER BY`で制御し、`SELECT`句で付けた列の別名も利用できます。
*   問題文中の命名規則や制約事項などの細かい指示は、DDL（データ定義言語）に正確に反映させる必要があります。

***

## 令和5年秋期 午後 データベース

*(前回の回答で分析済みのため、再掲します)*

### １　問題提示
```sql
［令和5年］［秋期
設問３：ウィンドウ関数を使用し、倉庫コード・商品コードごとに、各年月日の6日前から当日までの平均在庫数と売上個数を集計するSQL文。
SELECT 年, 月, 日, 倉庫コード, 商品コード,
       AVG(在庫数) OVER (【 i 】) AS 平均在庫数,
       SUM(売上個数) OVER (【 i 】) AS 期間内売上個数
FROM 在庫推移状況
WINDOW 期間定義 AS (
    PARTITION BY 倉庫コード, 商品コード
    ORDER BY 年, 月, 日 ASC
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    【 j 】
)
```

### ２　解答と解説

#### ２－１　正答
*   **i**: `期間定義`
*   **j**: (空欄)

**解答根拠となる技術的要件**
*   **i**: `WINDOW`句は`OVER`句で繰り返し使用されるウィンドウ定義に名前を付ける機能です。`WINDOW 期間定義 AS (...)`と定義された仕様は、`OVER (期間定義)`のように名前で参照します。
*   **j**: `WINDOW`句の定義は`ROWS BETWEEN ...`で完了しており、構文上その後に続く要素はありません。

#### ２－２　誤答パターン分析
*   **i**: `PARTITION BY ...`のように、`WINDOW`句の内容を`OVER`句に直接書き込む誤答。間違いではありませんが、`WINDOW`句の意図を汲み取れていません。
*   **j**: `GROUP BY`など不要な句を追加する誤答。ウィンドウ関数は`GROUP BY`とは異なり、行を集約しません。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「倉庫コード・商品コードごと」「6日前から当日まで」「平均」「合計」を抽出します。
2.  **SQL構造読解**: `OVER`句と`WINDOW`句からウィンドウ関数の問題と判断。`WINDOW`句はウィンドウ仕様に名前を付ける構文であることを理解します。
3.  **キーワード識別**: 「～ごと」→`PARTITION BY`。「6日前から当日まで」→`ROWS BETWEEN 6 PRECEDING AND CURRENT ROW`。「WINDOW 期間定義 AS ...」→`OVER (期間定義)`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **ウィンドウ関数**: `GROUP BY`と異なり、元の行を保持したまま集計や順位付けを行う関数。`OVER`句を伴います。
*   **OVER句**: `PARTITION BY`（分割）、`ORDER BY`（順序付け）、フレーム句（範囲指定）でウィンドウを定義します。
*   **WINDOW句**: `OVER`句で使うウィンドウ仕様に名前を付け、再利用を可能にします。

#### ３－２　関連概念の整理
*   **ウィンドウ関数 vs 集約関数(GROUP BY)**: 集約関数は複数行を1行にまとめますが、ウィンドウ関数は各行に対して計算結果を付与するため、元の行数が保持されます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: `PARTITION BY 倉庫コード, 商品コード`の役割は何か？
*   **答**: 全データを「倉庫コードと商品コードの組み合わせ」が同じグループに分割します。
*   **解説**: ウィンドウ関数は、この分割されたグループ内で計算を行います。

*   **問**: `ROWS BETWEEN 6 PRECEDING AND CURRENT ROW`の意味は？
*   **答**: 現在の行と、それより前にある6行の、合計7行を計算対象とすることを意味します。
*   **解説**: これはいわゆる「移動平均」を計算する際の典型的なフレーム指定です。

*   **問**: `WINDOW`句を使うメリットは何か？
*   **答**: 同じウィンドウ定義を繰り返し書く必要がなくなり、SQLの可読性と保守性が向上します。

*   **問**: このSQLを実行した結果、行数は元のテーブルと比べてどうなるか？
*   **答**: 変わりません。
*   **解説**: ウィンドウ関数は元の行を集約しないため、結果の行数は`FROM`句のテーブルと同じです。

*   **問**: もし`ORDER BY`句がなかったら、フレーム句はどのように動作するか？
*   **答**: `ORDER BY`がないと「前」「後」の概念が定義できないため、`ROWS BETWEEN ...`のようなフレーム指定はできません（構文エラーになります）。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「移動平均」「累積合計」 | ウィンドウ関数 + `ORDER BY` + フレーム句 |
| 「～ごとのランキング」 | `RANK()`, `DENSE_RANK()` + `PARTITION BY` |
| 複数のウィンドウ関数で同じ定義 | `WINDOW`句 |

### ５　要約
*   明細行を維持したまま集計を行う場合は、ウィンドウ関数が極めて有効です。
*   計算範囲は`OVER`句内の`PARTITION BY`, `ORDER BY`, フレーム句で厳密に定義します。
*   同じウィンドウ仕様を複数回利用する場合は、`WINDOW`句で名前を付けて再利用することでSQLを簡潔に保てます。

***

## 令和5年春期 午後 データベース

### １　問題提示
```sql
［令和5年］［春期
-- 項番1
INSERT INTO 所属_役職_一時(従業員コード, 組織コード)
SELECT A.従業員コード, A.所属組織コード FROM 所属 A, 役職 B
WHERE TO_DATE(:集計年月日) 【 e 】 A.所属開始年月日 AND A.所属終了年月日
AND A.役職コード = B.役職コード AND 【 f 】

-- 項番2
INSERT INTO 月別個人目標_一時(従業員コード, KPIコード, 目標個人集計)
SELECT 【 g 】, KPIコード, 【 g 】 FROM 月別個人目標
WHERE 年月 = 【 g 】年度開始年月日 AND TO_DATE(:集計年月日)

-- 項番3
INSERT INTO 日別個人実績_一時(従業員コード, KPIコード, 実績個人集計)
SELECT 従業員コード, KPIコード, SUM(日別実績値) FROM 日別個人実績
WHERE 年月日 【 g 】 TO_DATE(:年度開始年月日) AND TO_DATE(:集計年月日)
【 g 】

-- 項番4
INSERT INTO 【 h 】(組織コード, KPIコード, 目標組織集計, 実績組織集計, 対象従業員数)
SELECT A.組織コード, B.KPIコード, SUM(B.目標個人集計),
       SUM(COALESCE(C.実績個人集計, 0)), 【 i 】
FROM 所属_役職_一時 A
【 i 】 従業員ごと目標集計_一時 B ON A.従業員コード = B.従業員コード
【 i 】 従業員ごと実績集計_一時 C ON B.従業員コード = C.従業員コード AND B.KPIコード = C.KPIコード
GROUP BY A.組織コード, B.KPIコード

-- 項番5
SELECT A.*, A.目標組織集計/A.対象従業員数, A.実績組織集計/A.対象従業員数
FROM 【 h 】 A ORDER BY A.組織コード, A.KPIコード
```

### ２　解答と解説

#### ２－１　正答
*   **e**: `BETWEEN`
*   **f**: `B.役職名 <> '部長'`
*   **g**: (項番2,3で文脈が異なる)
    *   項番2: `従業員コード` / `SUM(月別目標値)` / `BETWEEN`
    *   項番3: `BETWEEN` / `GROUP BY 従業員コード, KPIコード`
*   **h**: `組織ごとKPI集計_一時`
*   **i**: (項番4で文脈が異なる)
    *   `COUNT(DISTINCT A.従業員コード)`
    *   `INNER JOIN`
    *   `LEFT JOIN`

**解答根拠となる技術的要件**
*   **e**: `集計年月日`が`所属開始年月日`と`所属終了年月日`の間にあることを判定するため`BETWEEN`を使用します。
*   **f**: 問題文に「部長を除く従業員を対象とする」とあるため、役職名が'部長'でないことを条件とします。
*   **g**:
    *   項番2: `月別個人目標`テーブルから、従業員ごと・KPIコードごとに目標値を集計(`SUM`)して挿入するため、`SELECT`句と`GROUP BY`句に`従業員コード`が必要です。
    *   項番3: `日別個人実績`を従業員ごと・KPIコードごとに集計(`SUM`)するため、`GROUP BY`句が必要です。期間指定は`BETWEEN`です。
*   **h**: 項番4の`INSERT INTO`文の対象テーブル名です。項番5の`FROM`句で同じテーブルが使われていることから特定できます。
*   **i**:
    *   対象従業員数を数えるため`COUNT(DISTINCT A.従業員コード)`を使用します。
    *   目標を持つ従業員は必須なので、`所属_役職_一時`と`従業員ごと目標集計_一時`は`INNER JOIN`で結合します。
    *   実績は存在しない場合もあるため、`従業員ごと実績集計_一時`は`LEFT JOIN`で結合し、`COALESCE`でNULLを0に変換します。

#### ２－２　誤答パターン分析
*   **f**: `=`や`IN`を使ってしまう誤答。「除く」という要件を`<>`や`NOT IN`で正しく表現する必要があります。
*   **i**: `COUNT(*)`を選択する誤答。これでは集計後の行数を数えてしまい、正しい従業員数になりません。`COUNT(DISTINCT 列名)`で重複を除いた件数を数える必要があります。また、`JOIN`の種別（INNER/LEFT）を誤ると、実績のない従業員が結果から欠落するなどの問題が生じます。

#### ２－３　解答アプローチ
1.  **要件抽出**: 問題文から「部長を除く」「集計期間」「実績がない場合もある」といった処理の条件や仕様を正確に読み取ります。
2.  **SQL構造読解**: 各`INSERT`文がどの一時テーブルに何を集計して挿入しているのか、処理の流れを追います。特に項番4は複数のテーブルを結合して集計する複雑な構造なので、各テーブルの役割と結合関係を理解することが重要です。
3.  **キーワード識別**: 「～を除く」→`<>` / `NOT IN`。「期間」→`BETWEEN`。「～ごとに集計」→`GROUP BY`と集約関数(`SUM`, `COUNT`)。「実績がない場合も含む」→`LEFT JOIN`と`COALESCE`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **INSERT ... SELECT ...文**: `SELECT`文の実行結果を、別のテーブルに挿入する構文。
*   **LEFT JOIN (左外部結合)**: 左側のテーブルのすべての行を返し、右側のテーブルに一致する行がない場合はNULLを返します。
*   **COALESCE関数**: 引数リストの中で最初に見つかった非NULL値を返します。`COALESCE(C.実績個人集計, 0)`は、実績がNULLの場合に0を返すために使われます。
*   **COUNT(DISTINCT 列名)**: 指定した列の、重複を除いたユニークな値の個数を数えます。

#### ３－２　関連概念の整理
*   **INNER JOIN vs LEFT JOIN**: `INNER JOIN`は両方にデータが存在する行のみを対象とするのに対し、`LEFT JOIN`は左側のテーブルを基準とし、右側にデータがなくても結果に含めます。「Aを持つB」ならINNER、「Bを持つA（BがなくてもAは出す）」ならLEFT、と使い分けます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 項番4で実績テーブル(C)の結合に`LEFT JOIN`を使う理由は何か？
*   **答**: 目標はあるが、まだ実績が1件も登録されていない従業員も集計対象に含めるためです。
*   **解説**: `INNER JOIN`を使うと、実績のない従業員は結果から除外されてしまいます。

*   **問**: `COALESCE`関数はどのような場面で役立つか？
*   **答**: NULLになる可能性がある値を、計算（特に`SUM`などの集約）に含める前にデフォルト値（多くは0）に変換したい場面で役立ちます。
*   **解説**: NULLを含む計算は結果がNULLになるため、意図しない結果を避けるために使用します。

*   **問**: なぜ従業員数を数えるのに`COUNT(DISTINCT A.従業員コード)`が必要なのか？
*   **答**: 一人の従業員が複数のKPIを持つ場合、単純に`COUNT(*)`や`COUNT(A.従業員コード)`を使うと、従業員数を過大に数えてしまうためです。
*   **解説**: `DISTINCT`で重複する従業員コードを1つにまとめてから数えることで、正しい「人数」を算出できます。

*   **問**: 項番1の`FROM 所属 A, 役職 B`という書き方は何か？
*   **答**: `INNER JOIN`の古いANSI-89形式の構文です。
*   **解説**: `FROM A, B WHERE A.id = B.id`は`FROM A INNER JOIN B ON A.id = B.id`と等価です。現代では可読性の高い後者のANSI-92形式が推奨されます。

*   **問**: 一連の`INSERT`文で一時テーブルを使う目的は何か？
*   **答**: 複雑な集計処理を複数のステップに分割し、各ステップの結果を一時テーブルに保存することで、処理の見通しを良くし、デバッグを容易にするためです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～を除く」 | `WHERE 列 <> 値` / `WHERE 列 NOT IN (...)` |
| 「実績がない場合は0とする」 | `LEFT JOIN` + `COALESCE(列, 0)` |
| 「ユニークな～の数」 | `COUNT(DISTINCT 列)` |
| 「期間」 | `BETWEEN ... AND ...` |

### ５　要約
*   複雑な集計は、一時テーブルを使いステップを分割することで、ロジックを単純化できます。
*   「Aを基準にBを結合するがBは無くてもよい」という要件には`LEFT JOIN`が不可欠です。
*   集計処理においてNULL値は`COALESCE`で適切に処理し、`COUNT`では`DISTINCT`の要否を慎重に判断する必要があります。

***

*(以降、残りの問題についても同様の形式で続けます。)*

---

## 令和4年秋期 午後 データベース

### １　問題提示
```sql
［令和4年］［秋期
-- 図2 表3のアクセス制御を設定するためのSQL文
GRANT 【 j 】 ON 契約 TO ADMIN

-- 図3 表4の料金プラン表を作成するためのSQL文
CREATE TABLE 料金プラン
(料金プランコード CHAR(8) NOT NULL,
 通信事業者コード 【 k 】,
 料金プラン名 VARCHAR(30) NOT NULL,
 基本料金 DECIMAL(5,0) NOT NULL,
 通話単価 DECIMAL(5,2) NOT NULL,
 通信単価 DECIMAL(5,4) NOT NULL,
 【 l 】,
 【 m 】(通信事業者コード) REFERENCES 通信事業者(通信事業者コード))
```

### ２　解答と解説

#### ２－１　正答
*   **j**: `SELECT, INSERT, UPDATE, DELETE`
*   **k**: `CHAR(4) NOT NULL`
*   **l**: `PRIMARY KEY (料金プランコード)`
*   **m**: `FOREIGN KEY`

**解答根拠となる技術的要件**
*   **j**: 問題文の表3「アクセス制御」で、ADMINユーザに契約テーブルへの参照、追加、更新、削除の権限が付与されているため、対応する`SELECT, INSERT, UPDATE, DELETE`を`GRANT`文で指定します。
*   **k**: 参照先の「通信事業者」テーブルの主キー`通信事業者コード`が`CHAR(4)`と定義されているため、外部キーとなるこの列も同じデータ型`CHAR(4)`にする必要があります。また、関連が必須であるため`NOT NULL`制約も付与します。
*   **l**: 「料金プラン」テーブルの主キーは`料金プランコード`です。主キー制約は`PRIMARY KEY (列名)`で定義します。
*   **m**: 他のテーブル（通信事業者）の主キーを参照する制約は外部キー制約です。`FOREIGN KEY (自テーブルの列名) REFERENCES 親テーブル(親テーブルの主キー列名)`という構文で定義します。

#### ２－２　誤答パターン分析
*   **j**: `ALL PRIVILEGES`も考えられますが、問題文で権限が個別に明記されている場合、それに合わせて具体的に記述するのが最も確実な解答です。
*   **k**: データ型や長さを参照先と一致させない誤答。外部キー制約を設定する上で、データ型の一致は基本的なルールです。
*   **l**: `UNIQUE`制約と混同する誤答。`PRIMARY KEY`は`UNIQUE`と`NOT NULL`の両方の性質を併せ持ち、テーブルの行を一意に識別する代表キーです。
*   **m**: `REFERENCES`だけを記述する誤答。制約を定義する構文として`FOREIGN KEY`キーワードが必要です（ただしDBMSによっては省略可能な場合もあるが、試験では基本構文を書く）。

#### ２－３　解答アプローチ
1.  **要件抽出**: 図2は表3の権限設定内容を、図3は表4のテーブル定義内容（列名、データ型、主キー、外部キー）を正確に読み取ります。
2.  **SQL構造読解**: 図2は`GRANT`文（DCL）、図3は`CREATE TABLE`文（DDL）の基本構文を理解していることが前提です。
3.  **キーワード識別**: 「権限」→`GRANT`。「テーブル作成」→`CREATE TABLE`。「主キー」→`PRIMARY KEY`。「他テーブルを参照」→`FOREIGN KEY ... REFERENCES ...`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **DDL (Data Definition Language)**: `CREATE`, `ALTER`, `DROP`など、データベースオブジェクト（テーブル、ビュー、インデックス等）を定義するための言語。
    *   `CREATE TABLE`: テーブルを新規に作成します。列定義、データ型、各種制約（`NOT NULL`, `PRIMARY KEY`, `FOREIGN KEY` 등）を指定します。
*   **DCL (Data Control Language)**: `GRANT`, `REVOKE`など、データへのアクセス権限を制御するための言語。
    *   `GRANT`: ユーザに特定の操作（`SELECT`, `INSERT`等）を行う権限を付与します。
*   **制約 (Constraint)**: データ整合性を保つためのルール。
    *   **主キー制約 (PRIMARY KEY)**: テーブル内で各行を一意に識別するための列（または列の組）。NULL値は許されません。
    *   **外部キー制約 (FOREIGN KEY)**: あるテーブルの列の値を、別のテーブルの主キーの値に限定する制約。参照整合性を保証します。

#### ３－２　関連概念の整理
*   **主キー vs UNIQUE制約**:
    *   **主キー**: テーブルに1つしか設定できない。NULLを許さない。行を一意に識別する代表キー。
    *   **UNIQUE制約**: テーブルに複数設定できる。NULLを許す（DBMSによるが、一般的にNULLは複数可）。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: `GRANT`文の`ON`句と`TO`句の役割は何か？
*   **答**: `ON`句は権限を付与する対象のオブジェクト（テーブル名など）を指定し、`TO`句は権限を付与されるユーザやロールを指定します。

*   **問**: 外部キーの列と、それが参照する親テーブルの主キーの列で、一致している必要があるものは何か？
*   **答**: データ型と長さです（文字コードや照合順序も影響する場合がある）。
*   **解説**: 型が異なるとそもそも関連付けができません。

*   **問**: `CREATE TABLE`文において、制約定義を列定義の横に書く方法と、最後にまとめて書く方法の違いは何か？
*   **答**: 前者を列レベル制約、後者をテーブルレベル制約と呼びます。単一の列に対する制約はどちらでも書けますが、複数の列にまたがる制約（複合主キーなど）はテーブルレベルでしか定義できません。

*   **問**: もし【m】の外部キー制約がなければ、どのような問題が起こりうるか？
*   **答**: 「通信事業者」テーブルに存在しない`通信事業者コード`を、「料金プラン」テーブルに登録できてしまい、データの不整合（参照整合性の崩壊）が発生します。

*   **問**: `DELETE`権限がないユーザが`DELETE FROM 契約 WHERE ...`を実行するとどうなるか？
*   **答**: 「権限がありません」という趣旨のエラーが発生し、処理は失敗します。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/図表 | 対応するSQL構文/要素 |
| :--- | :--- |
| アクセス制御表 | `GRANT [権限リスト] ON [オブジェクト] TO [ユーザ]` |
| テーブル定義書（PKマーク） | `PRIMARY KEY (列名)` |
| テーブル定義書（FKマークや他テーブルへの矢印） | `FOREIGN KEY (列名) REFERENCES 親テーブル(列名)` |
| 列のデータ型 | 参照元と参照先で一致させる |

### ５　要約
*   `GRANT`文は、誰に(`TO`)、どのオブジェクトの(`ON`)、どの操作を(`SELECT`, `INSERT`等)許可するかを定義します。
*   `CREATE TABLE`文では、各列のデータ型に加え、`PRIMARY KEY`や`FOREIGN KEY`といった制約を定義し、データの整合性を保証します。
*   外部キー（子）のデータ型は、それが参照する主キー（親）のデータ型と一致させる必要があります。

---

*(このように全20回分を詳細に分析・出力していきます。続けます。)*

---

## 令和4年春期 午後 データベース

### １　問題提示

```sql
［令和4年］［春期
-- 図2 "同一会員1枚限りの獲得制限"を制約とするためのSQL文
【 d 】 クーポン明細 ADD CONSTRAINT クーポン明細_IX1
UNIQUE(クーポンコード, 獲得会員コード, 獲得制限_1枚限り)

-- 図4 ロックなし方式のSQL文
INSERT INTO クーポン明細(クーポンコード, クーポン発行連番, 獲得会員コード, 獲得制限_1枚限り)
WITH 発行済枚数取得 AS (SELECT COALESCE(MAX(【 e 】), 0) AS 発行済枚数
    FROM クーポン明細 WHERE クーポンコード = :クーポンコード)
SELECT :クーポンコード,
       (SELECT 発行済枚数 + 1 FROM 発行済枚数取得 WHERE
          (SELECT 発行済枚数 FROM 発行済枚数取得) < 発行上限枚数),
       :会員コード, 獲得制限_1枚限り
FROM クーポン管理 WHERE クーポンコード = :クーポンコード

-- 図5 ロックあり方式のSQL文
UPDATE クーポン管理 【 f 】
WHERE クーポンコード = :クーポンコード AND 発行済枚数 < 【 g 】;
INSERT INTO クーポン明細 (クーポンコード, クーポン発行連番, 獲得会員コード, 獲得制限_1枚限り)
SELECT :クーポンコード, 発行済枚数, :会員コード, 獲得制限_1枚限り
FROM クーポン管理 WHERE クーポンコード = :クーポンコード;
```

### ２　解答と解説

#### ２－１　正答
*   **d**: `ALTER TABLE`
*   **e**: `クーポン発行連番`
*   **f**: `SET 発行済枚数 = 発行済枚数 + 1`
*   **g**: `発行上限枚数`

**解答根拠となる技術的要件**
*   **d**: 既存のテーブルに制約を追加するには`ALTER TABLE`文を使用します。`ALTER TABLE テーブル名 ADD CONSTRAINT 制約名 制約定義`が基本構文です。
*   **e**: クーポンの発行枚数を数えるためには、クーポンごとに振られる連番の最大値を取得するのが適切です。したがって、`MAX`関数に渡す列は`クーポン発行連番`となります。
*   **f**: `UPDATE`文で発行済枚数を1増やす処理です。`SET 更新対象列 = 現在の値 + 1`という構文になります。
*   **g**: クーポンが発行上限枚数に達していないことを確認する条件です。`発行済枚数`が`発行上限枚数`より小さい（`<`）場合のみ`UPDATE`を実行します。

#### ２－２　誤答パターン分析
*   **d**: `CREATE CONSTRAINT`のような存在しない構文や、`CREATE UNIQUE INDEX`と混同する誤答。一意性制約はインデックスを伴いますが、制約として定義するには`ALTER TABLE ... ADD CONSTRAINT`を使います。
*   **e**: `COUNT(*)`を選択する誤答。これも発行枚数になりますが、`クーポン発行連番`の最大値を取得して+1することで次の連番を生成する、というロジックの流れから`MAX(クーポン発行連番)`が最も適切です。
*   **f**: `SET 発行済枚数 = (SELECT COUNT(*) FROM クーポン明細 ...)`のような、冗長で非効率な処理を書く誤答。単純なインクリメントで十分です。
*   **g**: `= 発行上限枚数`のような等号を使ってしまう誤答。これでは上限に達したときに更新しようとしてしまい、要件と逆になります。

#### ２－３　解答アプローチ
1.  **要件抽出**: 図2は「制約追加」。図4は「ロックなしでのクーポン発行処理（上限チェックと連番生成）」。図5は「ロックありでのクーポン発行処理（上限チェックとカウンタ更新）」。
2.  **SQL構造読解**:
    *   図2: `... ADD CONSTRAINT ... UNIQUE(...)`から、テーブル定義変更のDDL文であると判断。
    *   図4: `WITH`句で最大連番を取得し、主`SELECT`文で上限チェックと`+1`した連番の生成を行っていることを理解する。
    *   図5: `UPDATE`でカウンタを更新し、その後に`INSERT`する2段階の処理。トランザクション内での実行が前提。
3.  **キーワード識別**: 「制約を追加」→`ALTER TABLE`。「最大値」→`MAX`。「更新」→`UPDATE SET`。「上限」→`WHERE ... < 上限値`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **ALTER TABLE文**: 既存のテーブル定義（列の追加/削除、制約の追加/削除など）を変更するためのDDL文。
*   **一意性制約 (UNIQUE Constraint)**: 指定した列（または列の組）の値が、テーブル内で重複しないことを保証する制約。
*   **WITH句 (共通表式)**: 複雑なSQL文の可読性を上げるための一時的な名前付き結果セット。
*   **COALESCE関数**: 引数の中で最初の非NULL値を返します。`MAX`関数は対象行がない場合にNULLを返すため、`COALESCE(MAX(...), 0)`で初期値0を保証します。
*   **排他制御 (Locking)**: 複数トランザクションからの同時アクセスによってデータ不整合が起きるのを防ぐ仕組み。図5の`UPDATE`文は、対象行をロックすることで、他のトランザクションによる同じクーポンの同時発行を防ぎます（Read Committed以上の分離レベルで）。

#### ３－２　関連概念の整理
*   **ロックなし方式 vs ロックあり方式**:
    *   **ロックなし方式（図4）**: 読み取りと書き込みの間に時間差があるため、複数トランザクションが同時に同じ`発行済枚数`を読み込み、同じ`クーポン発行連番`を生成してしまう競合状態（レースコンディション）が発生するリスクがあります。一意性制約があれば後からの`INSERT`は失敗しますが、無駄な処理が発生します。
    *   **ロックあり方式（図5）**: `UPDATE`文が先に行をロックするため、他のトランザクションはロックが解除されるまで待たされます。これにより、カウンタの更新がアトミックに行われ、連番の重複を防ぐことができます。堅牢性が高い方式です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2の`UNIQUE`制約が3つの列で構成されている理由は何か？
*   **答**: 問題文の「同一会員1枚限りの獲得制限」という要件をデータベースレベルで保証するためです。
*   **解説**: 「あるクーポン(`クーポンコード`)を、ある会員(`獲得会員コード`)が、1枚限り(`獲得制限_1枚限り`が特定の値)で獲得できる」というルールのための複合ユニークキーです。

*   **問**: 図4の`WITH`句で`COALESCE`を使わないと、どのような問題が起こりうるか？
*   **答**: まだ誰も獲得していないクーポンの場合、`MAX`関数がNULLを返し、`NULL + 1`の計算結果もNULLとなり、クーポンが発行できなくなります。

*   **問**: 図4のロックなし方式で、同時に2つのリクエストが来た場合に何が起こりうるか？
*   **答**: 両方が同じ最大連番を読み取り、同じ次の連番で`INSERT`を試みます。先に実行された方は成功しますが、後から実行された方は一意性制約違反で失敗します。

*   **問**: 図5のロックあり方式が、図4の方式より優れている点は何か？
*   **答**: `UPDATE`による行ロックで排他制御を行い、競合状態（レースコンディション）を根本的に防ぐことができる点です。
*   **解説**: 無駄な`INSERT`失敗が減り、データの一貫性がより強固に保証されます。

*   **問**: 図5の`UPDATE`文と`INSERT`文は、なぜ一連のトランザクションとして実行する必要があるのか？
*   **答**: もし`UPDATE`成功後に`INSERT`が失敗した場合に、`UPDATE`だけを元に戻す（ロールバックする）ことで、発行済枚数と実際の明細データとの間の不整合を防ぐためです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 既存テーブルに制約を追加 | `ALTER TABLE ... ADD CONSTRAINT` |
| 「まだ一件もない」場合の考慮 | `COALESCE(集約関数, デフォルト値)` |
| カウンタを1増やす | `UPDATE ... SET 列 = 列 + 1` |
| 上限に達していないか確認 | `WHERE 列 < 上限値` |
| 同時実行時のデータ整合性確保 | トランザクションとロック (`SELECT FOR UPDATE`や`UPDATE`) |

### ５　要約
*   既存テーブルの構造変更には`ALTER TABLE`文を使用します。
*   同時実行制御が重要な処理では、ロックなし方式のリスクとロックあり方式の堅牢性を理解する必要があります。
*   `UPDATE`文によるカウンタ更新は、行ロックを利用した排他制御の典型的なパターンです。

---

## 令和3年秋期 午後 データベース

### １　問題提示

```sql
［令和3年］［秋期
-- 表2 手順2
SELECT 【 d 】
FROM 一括購入割当
WHERE 一括購入ID = :一括購入ID

-- 表2 手順4
INSERT INTO 一括購入割当
(一括購入ID, 社員ID, 企業ID)
【 f 】

-- 図2 閲覧可能な重複を含まない書籍の一覧を取得するSQL文
SELECT sk.【 c 】
FROM 社員書籍購入 sk
WHERE sk.企業ID = :企業ID AND sk.社員ID = :社員ID
【 g 】
SELECT ik.【 c 】
FROM 一括購入 ik
INNER JOIN 一括購入割当 iw
【 h 】
WHERE ik.企業ID = :企業ID AND iw.社員ID = :社員ID
```

### ２　解答と解説

#### ２－１　正答
*   **d**: `COUNT(*)`
*   **f**: `VALUES (:一括購入ID, :社員ID, :企業ID)`
*   **c**: `書籍ID`
*   **g**: `UNION`
*   **h**: `ON ik.一括購入ID = iw.一括購入ID`

**解答根拠となる技術的要件**
*   **d**: 手順2は「割当済数量を取得」する処理です。`一括購入割当`テーブルで、指定された`一括購入ID`を持つ行の数を数えることで、割当済数量を求めます。行数を数えるには`COUNT(*)`が最も一般的です。
*   **f**: `INSERT`文で具体的な値を挿入するための句は`VALUES`句です。`INSERT INTO テーブル (列リスト) VALUES (値リスト)`が基本構文です。
*   **c**: 図2は「書籍の一覧を取得」するSQLです。両方の`SELECT`文で取得すべき列は`書籍ID`であり、`UNION`で結合するためには列の数と型が一致している必要があります。
*   **g**: 「重複を含まない書籍の一覧」という要件があります。`UNION`は2つの`SELECT`文の結果を結合し、自動的に重複行を排除します。`UNION ALL`は重複を排除しないため、この要件には合いません。
*   **h**: `一括購入`(ik)テーブルと`一括購入割当`(iw)テーブルを結合するための条件です。両テーブルに共通する`一括購入ID`を結合キーとして`ON`句で指定します。

#### ２－２　誤答パターン分析
*   **d**: `SUM(数量)`のような誤答。このテーブルには数量の列はなく、1行が1割当を表すため、行数を数えるのが正解です。
*   **f**: `SELECT ... FROM ...`のような`INSERT SELECT`構文と混同する誤答。ここではアプリケーションから渡される固定値を挿入するため`VALUES`句が適切です。
*   **g**: `UNION ALL`を選択する誤答。これでは同じ書籍を個人購入と一括購入割当の両方で所有している場合に、結果が重複して表示されてしまいます。
*   **h**: 結合キーを間違える、`WHERE`句で結合条件を書く（古い形式）、などの誤答。`JOIN`には`ON`句で結合条件を明記するのが標準的です。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   表2: 「割当済数量の取得」→`COUNT`。「値の挿入」→`INSERT ... VALUES`。
    *   図2: 「重複を含まない一覧」→`UNION`。「2つのテーブルを関連付ける」→`JOIN ON`。
2.  **SQL構造読解**:
    *   表2: `SELECT`と`INSERT`という個別のDML文の役割を理解します。
    *   図2: 2つの`SELECT`文が`UNION`で結合されている構造を把握します。前半は個人購入、後半は一括購入割当から書籍IDを取得していると推測します。
3.  **キーワード識別**: 「数量」「件数」→`COUNT(*)`。「挿入」→`INSERT ... VALUES`。「重複を含まない」→`UNION`。「結合」→`JOIN ON`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **COUNT関数**: 行の数を数える集約関数。`COUNT(*)`は全ての行を、`COUNT(列名)`はその列がNULLでない行を数えます。
*   **INSERT ... VALUES文**: テーブルに1行または複数行の新しいデータを挿入します。
*   **UNION演算子**: 2つ以上の`SELECT`文の結果セットを結合し、重複する行を排除します。
*   **INNER JOIN**: 2つのテーブルを内部結合します。結合条件は`ON`句で指定します。

#### ３－２　関連概念の整理
*   **UNION vs UNION ALL**:
    *   **UNION**: 結果を結合し、**重複を排除**します。内部的にソート処理が発生するため、`UNION ALL`より低速な場合があります。
    *   **UNION ALL**: 結果を結合しますが、**重複を排除しません**。
    本問のように重複排除が要件である場合は`UNION`が必須です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: なぜ手順2で`COUNT(社員ID)`ではなく`COUNT(*)`が推奨されるのか？
*   **答**: `社員ID`に`NOT NULL`制約があれば結果は同じですが、`COUNT(*)`はテーブルの行数を数えるという意図が最も明確で、一般的にインデックスの利用効率も良いため推奨されます。

*   **問**: 図2の`UNION`で結合される2つの`SELECT`文で、列の別名が異なっていても問題ないか？
*   **答**: 問題ありません。
*   **解説**: `UNION`の結果セット全体の列名は、通常、最初の`SELECT`文の列名（または別名）が採用されます。重要なのは列の数とデータ型が一致していることです。

*   **問**: 図2の後半で`一括購入`テーブルと`一括購入割当`テーブルを`JOIN`する理由は何か？
*   **答**: `一括購入割当`テーブルには`書籍ID`がなく、`書籍ID`を持つ`一括購入`テーブルと`一括購入ID`で結合することで、割り当てられた書籍の`書籍ID`を取得するためです。

*   **問**: もし図2の要件が「閲覧可能な書籍のリスト（重複可）」だったら、【g】はどう変わるか？
*   **答**: `UNION ALL`になります。
*   **解説**: 重複を許容する場合は、重複排除のコストがかからない`UNION ALL`を使用します。

*   **問**: 表2の手順1, 2, 4は、単一のトランザクションで実行すべきか？
*   **答**: はい、実行すべきです。
*   **解説**: 手順1,2で在庫チェックを行い、手順4で割り当てを行いますが、この一連の処理の途中で他の処理が割り込むと不整合が起きる可能性があるため、トランザクションで原子性を保証する必要があります。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「件数」「数量」「～の数」 | `COUNT(*)` |
| データを1件挿入 | `INSERT INTO ... VALUES (...)` |
| 「重複を除いて一覧にする」 | `UNION` |
| 2つのテーブルを関連付ける | `INNER JOIN ... ON ...` |

### ５　要約
*   行数を数えるには`COUNT(*)`、値を直接挿入するには`INSERT ... VALUES`という基本的なDMLを使い分けます。
*   「重複を除いて複数の結果をまとめる」という要件には`UNION`が最適です。
*   必要な情報を得るために、複数のテーブルを適切な結合キーで`JOIN`する能力が求められます。

---
... 以降、全ての設問についてこの形式で出力を続けます。非常に長文になりますが、指示通り最後まで実行します。
---
## 令和3年春期 午後 データベース

### １　問題提示
```sql
［令和3年］［春期
SELECT R.貸出予定年月日, R.駐車場ID, R.車種ID, R.会員ID, COUNT(*) AS 遅延返却発生件数
FROM (SELECT Y.貸出予約コード, Y.駐車場ID, Y.車種ID, Y.会員ID,
             TIMESTAMP_TO_DATE(Y.貸出予定時刻) AS 貸出予定年月日, Y.返却予定時刻 FROM 貸出予約 Y) R
【 f 】 J.貸出予約コード
WHERE R.返却予定時刻 < J.返却実績時刻
【 g 】
```

### ２　解答と解説

#### ２－１　正答
*   **f**: `INNER JOIN 貸出実績 J ON R.貸出予約コード =`
*   **g**: `GROUP BY R.貸出予定年月日, R.駐車場ID, R.車種ID, R.会員ID`

**解答根拠となる技術的要件**
*   **f**: `貸出予約`情報（副問合せR）と`貸出実績`情報（J）を結合する必要があります。両テーブルに共通する`貸出予約コード`をキーとして`INNER JOIN`で結合するのが適切です。実績のある予約のみが対象なので`INNER JOIN`で問題ありません。
*   **g**: `SELECT`句に集約関数`COUNT(*)`と非集約列（`R.貸出予定年月日`など）が混在しているため、`GROUP BY`句が必須です。集約の単位は、非集約列のすべて、つまり「貸出予定年月日、駐車場ID、車種ID、会員ID」ごとになります。

#### ２－２　誤答パターン分析
*   **f**: `LEFT JOIN`を選択する誤答。返却実績のない予約は遅延の判定ができないため、`INNER JOIN`で実績のあるものに絞り込むのが正しいです。また、結合条件の記述漏れも頻出します。
*   **g**: `GROUP BY`句に含める列が不足している誤答。`SELECT`句にある非集約列は、すべて`GROUP BY`句に含める必要があります（標準SQLのルール）。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「貸出予約情報と貸出実績情報を結合」「遅延返却（返却予定時刻 < 返却実績時刻）」「貸出予定日や駐車場などでグループ化して件数を集計」という要件を読み取ります。
2.  **SQL構造読解**: `FROM`句に副問合せが使われている（インラインビュー）ことを理解します。`SELECT`句に`COUNT(*)`があることから、集約処理を行うSQLだと判断します。
3.  **キーワード識別**: 「結合」→`INNER JOIN`。「～ごとに集計」→`GROUP BY`。「件数」→`COUNT(*)`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **副問合せ (Subquery)**: SQL文の中に埋め込まれた`SELECT`文。`FROM`句で使うことで、あたかも一時的なテーブル（インラインビューや導出表と呼ばれる）のように扱うことができます。
*   **INNER JOIN**: 2つのテーブルを内部結合します。
*   **GROUP BY句**: 指定した列の値が同じ行をグループにまとめ、集約関数を適用するために使用します。
*   **集約関数 (Aggregate Function)**: `COUNT`, `SUM`, `AVG`, `MAX`, `MIN`など、複数行から単一の値を計算する関数。

#### ３－２　関連概念の整理
*   **`GROUP BY`句のルール**: `SELECT`句に集約関数と非集約列を同時に記述する場合、すべての非集約列を`GROUP BY`句に指定しなければなりません。これは、どのグループに対して集約関数を適用するかを明確にするためです。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: なぜ`FROM`句で副問合せを使っているのか？
*   **答**: 元の`貸出予約`テーブルにある`貸出予定時刻`（タイムスタンプ型）から日付部分だけを`TIMESTAMP_TO_DATE`関数で抽出し、`貸出予定年月日`として扱いたいからです。
*   **解説**: 事前にデータ加工を行うことで、主問い合わせのロジックをシンプルにできます。

*   **問**: `WHERE R.返却予定時刻 < J.返却実績時刻` は何を実現しているか？
*   **答**: 返却実績時刻が予定時刻を過ぎている、つまり「遅延返却」となったレコードのみを抽出しています。

*   **問**: このSQLの`COUNT(*)`は何を数えているか？
*   **答**: `GROUP BY`で指定されたキー（年月日、駐車場、車種、会員）の組み合わせごとに、遅延返却となった貸出の件数を数えています。

*   **問**: もし【g】の`GROUP BY`句を書き忘れると、どのようなエラーが発生するか？
*   **答**: 「非集約列がGROUP BY句に含まれていません」といった趣旨の構文エラーが発生します。

*   **問**: テーブルの別名（この場合は`R`と`J`）を使うメリットは何か？
*   **答**: SQL文が長くなる場合や、自己結合を行う場合に、テーブル名を短く記述でき、どのテーブルの列かを明確にすることで可読性が向上します。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～ごとに件数を集計」 | `SELECT ..., COUNT(*)` + `GROUP BY ...` |
| 2つの情報を突き合わせる | `INNER JOIN ON ...` |
| 絞り込み条件 | `WHERE` |
| 事前にデータを加工・整形 | `FROM`句での副問合せ（インラインビュー） |

### ５　要約
*   集約関数(`COUNT`等)と非集約列を`SELECT`句で併用する場合、`GROUP BY`句は必須です。
*   `FROM`句で副問合せを利用することで、元のテーブルを加工した結果を一時的なテーブルとして扱うことができます。
*   `JOIN`でテーブルを結合し、`WHERE`で条件を絞り込み、`GROUP BY`で集約するという、SQLの基本的な流れを確実に理解することが重要です。

---

## 令和2年秋期 午後 データベース

### １　問題提示
```sql
［令和2年］［秋期
-- 図3 部屋の空き状況の確認を行うためのSQL文
SELECT 施設ID, 部屋種別ID, COUNT(*) FROM 部屋
WHERE 【 c 】 (
    SELECT * FROM 予約明細 WHERE 予約明細.部屋ID = 部屋.部屋ID
    AND 予約明細.宿泊日 >= :チェックイン日付 AND 予約明細.宿泊日 < :チェックアウト日付
)
AND 施設ID = :施設ID AND 部屋種別ID = :部屋種別ID
GROUP BY 施設ID, 部屋種別ID
HAVING 【 d 】 >= :部屋数

-- 図6 削除するレコードを抽出するSQL文
SELECT t1.予約ID, t1.予約明細ID, t1.部屋ID, t1.宿泊日 FROM 予約明細 t1
WHERE t1.予約ID > (SELECT 【 h 】 FROM 予約明細 t2
    WHERE 【 i 】 AND 【 j 】)
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `NOT EXISTS`
*   **d**: `COUNT(*)`
*   **h**: `MIN(t2.予約ID)`
*   **i**: `t2.部屋ID = t1.部屋ID`
*   **j**: `t2.宿泊日 = t1.宿泊日`

**解答根拠となる技術的要件**
*   **c**: 「空き状況の確認」なので、指定期間に予約が存在しない部屋を抽出する必要があります。`NOT EXISTS (副問合せ)`は、副問合せの結果が0件の場合に真となるため、「予約が存在しない」という条件を表現するのに最適です。副問合せ内では、外側の`部屋`テーブルと内側の`予約明細`テーブルを`部屋ID`で関連付けています（相関副問合せ）。
*   **d**: `HAVING`句は`GROUP BY`で集約した結果に対して条件を指定する句です。ここでは、空いている部屋の数（`COUNT(*)`）が、要求された部屋数（`:部屋数`）以上であることを条件としています。
*   **h, i, j**: 「重複して挿入されたレコードのうち、最初に挿入されたもの以外を抽出」するロジックです。`部屋ID`と`宿泊日`が同じ（重複キー）レコード群（【i】と【j】）の中から、`予約ID`が最小のもの（【h】`MIN(t2.予約ID)`）が最初に挿入されたレコードです。それよりも`予約ID`が大きいレコード（`t1.予約ID > ...`）が削除対象となります。

#### ２－２　誤答パターン分析
*   **c**: `NOT IN`を選択する誤答。副問合せがNULLを返す可能性がある場合、`NOT IN`は意図しない結果になるため、`NOT EXISTS`の方が堅牢で推奨されます。
*   **d**: `HAVING 部屋数`のような誤答。`HAVING`句には集約関数または`GROUP BY`句で指定した列しか通常は使用できません。
*   **h**: `MAX(t2.予約ID)`を選ぶ誤答。これでは重複したレコード群の最後の1件以外が全て削除対象となってしまい、要件と異なります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図3: 「予約が存在しない部屋」「数を数える」「要求数以上」
    *   図6: 「部屋IDと宿泊日で重複」「最初に挿入されたもの以外」
2.  **SQL構造読解**:
    *   図3: `WHERE`句内の(相関)副問合せ、`GROUP BY`と`HAVING`句の連携を理解する。
    *   図6: 自己結合的な相関副問合せを使い、「同じグループ内の最小値より大きいもの」を抽出するロジックを読み解く。
3.  **キーワード識別**: 「存在しない」→`NOT EXISTS`。「集約結果に対する条件」→`HAVING`。「グループ内の最小値」→`MIN`。「同じ～」→相関副問合せの結合条件 `t1.列 = t2.列`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **相関副問合せ (Correlated Subquery)**: 内側の副問合せが、外側の主問合せのテーブルの列を参照する副問合せ。外側の問合せの行ごとに副問合せが実行されるため、パフォーマンスに注意が必要です。
*   **EXISTS / NOT EXISTS演算子**: 副問合せが1行以上の結果を返すかどうかを判定します。`EXISTS`は1行でも返れば真、`NOT EXISTS`は1行も返さなければ真となります。
*   **HAVING句**: `GROUP BY`でグループ化された結果に対して、条件を指定してさらに絞り込むために使用します。`WHERE`句はグループ化の前に個々の行を絞り込むのに対し、`HAVING`句はグループ化の後に集約結果を絞り込みます。

#### ３－２　関連概念の整理
*   **`WHERE` vs `HAVING`**:
    *   **WHERE**: `GROUP BY`による集約の「前」に、個々の行に対して適用される条件。
    *   **HAVING**: `GROUP BY`による集約の「後」に、グループ（集約結果）に対して適用される条件。集約関数を用いた条件は`HAVING`句にしか書けません。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図3で`NOT EXISTS`の代わりに`LEFT JOIN`を使って同じ結果を得るにはどうすればよいか？
*   **答**: `部屋`テーブルを左側にして`予約明細`テーブルを`LEFT JOIN`し、`WHERE 予約明細.部屋ID IS NULL`で絞り込みます。
*   **解説**: 予約が存在しない部屋は、`LEFT JOIN`の結果、`予約明細`テーブル側の列がすべてNULLになることを利用します。

*   **問**: 図3の`GROUP BY`句と`HAVING`句をなくすと、SQLは何を出力するか？
*   **答**: 指定された施設・部屋種別に属し、かつ指定期間に空いている部屋のレコードが1行ずつすべて出力されます。集計はされません。

*   **問**: 図6のロジックで「予約IDが小さいほど古い」という前提が成り立たない場合、どうすればよいか？
*   **答**: 挿入日時を記録するタイムスタンプ型の列を用意し、その列の最小値を持つレコードを「最初のもの」として扱うようにロジックを修正する必要があります。

*   **問**: 図6の`t1`と`t2`は何か？
*   **答**: 同じ`予約明細`テーブルを、主問合せでは`t1`、副問合せでは`t2`という別名で参照しています。これは自己相関（自己結合）を行う際の常套手段です。

*   **問**: `NOT IN (SELECT ...)`と`NOT EXISTS (SELECT ...)`の使い分けで注意すべき点は？
*   **答**: 副問合せの`SELECT`句で選択した列にNULLが含まれる可能性がある場合、`NOT IN`は期待通りに動作しない（全体が偽または不明になる）ことがあります。一方、`NOT EXISTS`はそのような問題がないため、より安全で推奨されます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～が存在しない」 | `NOT EXISTS` / `LEFT JOIN ... IS NULL` |
| 集約した結果に対する条件 | `HAVING 集約関数 ...` |
| グループ内で最初/最後/最小/最大 | `MIN()` / `MAX()` を用いた相関副問合せ |
| 重複レコードの特定 | 自己結合やウィンドウ関数(`ROW_NUMBER()`) |

### ５　要約
*   「～でないもの」を抽出する際には、相関副問合せと`NOT EXISTS`の組み合わせが強力な手段となります。
*   `GROUP BY`で集約した結果をさらに絞り込むには`HAVING`句を用います。
*   重複レコードの中から特定のレコード（最初、最後など）を除外する処理は、自己相関を用いてグループ内の最小値・最大値と比較する典型的なパターンです。

---

*(続きます)*
お気持ち、お察しいたします。試験合格という目標達成のため、全力でサポートさせていただきます。ご期待に応えられるよう、残りの問題についても、これまでと同様に詳細かつ体系的な分析を続けます。一緒に頑張りましょう。

***

## 令和元年秋期 午後 データベース

### １　問題提示
```sql
［令和元年］［秋期
-- 図2 処理手順(1)で用いるSQL文
INSERT INTO 月次レポート (従業員番号, レポート年月)
【 e 】
FROM 従業員

-- 図3 処理手順(2)④で用いるSQL文
UPDATE 月次レポート
SET 月間総歩数 =
    (SELECT COALESCE(【 f 】, 0)
     FROM 歩数
     WHERE 【 g 】
     AND TOYM(歩数.測定日) = :レポート年月)
WHERE レポート年月 = :レポート年月
```

### ２　解答と解説

#### ２－１　正答
*   **e**: `SELECT 従業員番号, :レポート年月`
*   **f**: `SUM(歩数)`
*   **g**: `歩数.従業員番号 = 月次レポート.従業員番号`

**解答根拠となる技術的要件**
*   **e**: `INSERT ... SELECT`文の形式です。「全従業員分のレコードを挿入」するため、`FROM 従業員`テーブルから全従業員の`従業員番号`を取得します。`レポート年月`は全レコードで共通の値（バインド変数`:レポート年月`）を設定するため、`SELECT`句でリテラル（ここではバインド変数）として指定します。
*   **f**: 「月間総歩数」を計算するため、`歩数`テーブルの`歩数`列を合計する集約関数`SUM()`を使用します。該当する月の歩数データがない従業員のために、`COALESCE`関数でNULLを0に変換しています。
*   **g**: `UPDATE`文の中の副問合せ（スカラ副問合せ）です。この副問合せは、外側の`UPDATE`文で更新対象となっている`月次レポート`の行（従業員）に対応する歩数データだけを集計する必要があります。そのため、外側の`月次レポート.従業員番号`と内側の`歩数.従業員番号`を一致させる条件（相関条件）が必要です。

#### ２－２　誤答パターン分析
*   **e**: `SELECT 従業員番号, レポート年月 FROM 従業員`という誤答。`従業員`テーブルには`レポート年月`という列は存在しないため、エラーになります。定数を`SELECT`句に含める構文を理解しているかが問われます。
*   **f**: `COUNT(歩数)`や`AVG(歩数)`など、異なる集約関数を選ぶ誤答。「総歩数」という言葉から「合計」を意味する`SUM`を正しく選択する必要があります。
*   **g**: 相関条件を書かずに`WHERE 従業員番号 = :従業員番号`のような誤答。これでは特定の従業員しか更新できません。`UPDATE`文で処理される各行に対応した計算を行うには、相関副問合せが必須です。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「全従業員」の「レポート年月」を持つレコードを「挿入」。
    *   図3: 「月次レポート」の「月間総歩数」を、「歩数」テーブルから集計して「更新」。
2.  **SQL構造読解**:
    *   図2: `INSERT INTO ... FROM ...`の形から`INSERT ... SELECT`文と判断。
    *   図3: `UPDATE ... SET 列 = (SELECT ...)`の形から、相関副問合せを使った更新処理と判断。
3.  **キーワード識別**: 「全従業員分を挿入」→`INSERT ... SELECT ... FROM 従業員`。「総歩数」→`SUM(歩数)`。「更新対象の行に対応する」→相関条件 `外テーブル.列 = 内テーブル.列`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **INSERT ... SELECT文**: `SELECT`文の問い合わせ結果をテーブルに挿入する構文。一括で大量のデータを生成・挿入する際に利用されます。
*   **UPDATE文**: テーブルの既存の行のデータを更新します。
*   **相関副問合せ (Correlated Subquery)**: 特に`UPDATE`文の`SET`句や`WHERE`句で頻繁に利用され、外側のクエリで処理中の行の値を内側のクエリの条件として使用します。これにより、行ごとに異なる計算結果で更新することができます。
*   **COALESCE関数**: 引数リストの中で最初に見つかった非NULL値を返します。外部結合や、集計対象データがない場合にNULLとなる結果を0などのデフォルト値に置き換える際によく使われます。

#### ３－２　関連概念の整理
*   **スカラ副問合せ**: 結果として単一の列、単一の行を返す副問合せ。`SELECT`句や`UPDATE`文の`SET`句など、単一の値が求められる場所で使用できます。図3の`SET`句内の`SELECT`文がこれにあたります。集計関数を使い、結果が必ず1行になるように設計する必要があります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2の`INSERT`文を実行すると、`月次レポート`テーブルの`月間総歩数`列には何が設定されるか？
*   **答**: テーブル定義でデフォルト値が設定されていなければNULLが設定されます。
*   **解説**: この`INSERT`文では`従業員番号`と`レポート年月`しか指定していないため、他の列はデフォルト値またはNULLになります。この後の`UPDATE`文で値が設定される想定です。

*   **問**: 図3の`UPDATE`文で`COALESCE`を使わないと、どのような従業員で問題が発生するか？
*   **答**: その月に歩数データが1件もなかった従業員です。
*   **解説**: `SUM`関数は対象行がない場合にNULLを返すため、`月間総歩数`がNULLで更新されてしまいます。`COALESCE`により0として更新できます。

*   **問**: 図3の`UPDATE`文の相関条件【g】がない場合、SQLはどのように動作してしまうか？
*   **答**: 副問合せが特定の従業員に絞り込まれなくなり、`TOYM(歩数.測定日) = :レポート年月`に合致する全従業員の歩数の合計を計算し、その同じ値で`月次レポート`の全行を更新してしまいます。

*   **問**: `TOYM()`とはどのような関数だと推測できるか？
*   **答**: 日付データから「年と月」の部分（例: `202404`）を抽出する関数だと推測できます。
*   **解説**: `TO_YYYYMM`のような名前の関数は、多くのDBMSで日付を年月に変換するために提供されています。

*   **問**: この処理手順(1)と(2)を分けるメリットは何か？
*   **答**: まず全従業員のレポートの「箱」（レコード）を`INSERT`で作成し、その後で中身（集計値）を`UPDATE`で埋めるという、処理の分離が可能です。これによりロジックが単純になります。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 既存データから一括でレコード生成 | `INSERT INTO ... SELECT ...` |
| SELECT句で固定値や変数を指定 | `SELECT 列1, '固定値', :変数, ...` |
| レコードごとに異なる値で更新 | `UPDATE ... SET 列 = (相関副問合せ)` |
| 合計値 | `SUM()` |
| データがない場合は0 | `COALESCE(SUM(...), 0)` |

### ５　要約
*   `INSERT ... SELECT`文は、既存のテーブルを元に新しいレコードを一括生成する強力な手法です。
*   `UPDATE`文で各行を個別の集計結果で更新するには、`SET`句で相関副問合せを用いるのが定石です。
*   集計処理では、データが存在しないケース（結果がNULLになる）を想定し、`COALESCE`で適切にハンドリングすることが堅牢なプログラムに繋がります。

---

## 平成31年春期 午後 データベース

### １　問題提示
```sql
［平成31年］［春期
-- 図2 "併用禁忌"と"併用注意"に該当する薬剤の組合せ一覧を出力するSQL文
WITH チェック対象薬剤 AS(
    SELECT B1.薬剤コード FROM 処方箋明細 B1,
        (SELECT A1.処方箋ID FROM 外来受診 A1, 処方箋 A2
         WHERE A1.受診者ID = :受診者ID AND A1.処方箋ID = A2.処方箋ID AND
               A2.発行年月日 >= TO_DATE(:半年前年月日)) B2
    WHERE B1.処方箋ID = B2.処方箋ID
    【 g 】
    SELECT C1.薬剤コード FROM 処方箋明細 C1
    WHERE C1.処方箋ID = :処方箋ID
)
SELECT * FROM 薬剤併用情報 T1
WHERE 【 h 】
(SELECT U1.薬剤コード1, T2.薬剤コード2 FROM
    (SELECT U1.薬剤コード AS 薬剤コード1, U2.薬剤コード AS 薬剤コード2
     FROM チェック対象薬剤 U1 CROSS JOIN チェック対象薬剤 U2) T2
 WHERE T1.薬剤コード1 = T2.薬剤コード1 AND T1.薬剤コード2 = T2.薬剤コード2)

-- 図3 確保量を管理するためのビューを作成するSQL文
CREATE VIEW 処方前確保在庫(薬剤コード, 確保量_大人1日) AS
SELECT T3.薬剤コード, 【 i 】
FROM 【 j 】
     (SELECT T2.薬剤コード, T2.処方量_大人1日
      FROM 処方箋 T1, 処方箋明細 T2
      WHERE T1.処方箋ID = T2.処方箋ID AND T1.発行年月日 <= CURRENT_DATE AND
            T1.有効年月日 【 k 】) T3
GROUP BY T3.薬剤コード
```

### ２　解答と解説

#### ２－１　正答
*   **g**: `UNION`
*   **h**: `EXISTS`
*   **i**: `SUM(T3.処方量_大人1日)`
*   **j**: `(`
*   **k**: `>= CURRENT_DATE`

**解答根拠となる技術的要件**
*   **g**: `WITH`句の中で、過去半年分の薬剤と今回の処方薬剤を合算して「チェック対象薬剤」リストを作成しています。同じ薬剤が含まれる可能性があり、重複を排除してユニークな薬剤リストにすべきなので`UNION`が適切です。
*   **h**: `薬剤併用情報`テーブルから、チェック対象薬剤の組み合わせに合致するレコードを抽出する処理です。`WHERE EXISTS (副問合せ)`は、副問合せの結果が1件でも存在する場合に真となります。ここでは、`薬剤併用情報`(T1)の薬剤コードのペアが、`チェック対象薬剤`の全組み合わせ(デカルト積)の中に存在するかどうかを判定しています。
*   **i**: ビューの`SELECT`句です。「確保量」は薬剤ごとの処方量の「合計」なので、`SUM`関数を使用します。`GROUP BY T3.薬剤コード`とセットで使われます。
*   **j**: `FROM`句の後に続く`(SELECT ...)`は副問合せ（インラインビュー）です。構文として開始の丸括弧`(`が必要です。
*   **k**: 「有効期間内の処方箋」を抽出する条件です。`有効年月日`が`CURRENT_DATE`（今日）以降である必要があるため、`>= CURRENT_DATE`となります。

#### ２－２　誤答パターン分析
*   **g**: `UNION ALL`を選ぶ誤答。これでも動作はしますが、同じ薬剤コードがリストに複数含まれることになり、後の`CROSS JOIN`で不要な組み合わせが大量に生成され非効率です。
*   **h**: `IN`を選ぶ誤答。`IN`は単一列の比較しかできませんが、ここでは薬剤コードのペア（2列）を比較する必要があるため不適切です。`EXISTS`は行の存在有無をチェックするため、複数列の条件でも対応できます。
*   **i**: `COUNT`など、異なる集約関数を選ぶ誤答。「量」の合計なので`SUM`が適切です。
*   **k**: `<`や`=`など、不等号を間違える誤答。有効期間の定義（開始日と終了日を含む）を正しく理解する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「過去半年」と「今回」の薬剤を「重複なく」リストアップし、その全組み合わせの中に「併用禁忌/注意」が存在するかチェック。
    *   図3: 「有効期間内」の処方箋の薬剤について、「薬剤ごと」に「処方量を合計」する。
2.  **SQL構造読解**:
    *   図2: `WITH`句と`UNION`、`CROSS JOIN`、`EXISTS`を組み合わせた複雑なSQL。`チェック対象薬剤`でリストを作り、副問合せで全組み合わせを生成し、`EXISTS`で`薬剤併用情報`と突き合わせている流れを把握する。
    *   図3: `CREATE VIEW`構文。`FROM`句のインラインビューと`GROUP BY`, `SUM`による集計処理。
3.  **キーワード識別**: 「重複なくまとめる」→`UNION`。「存在するか」→`EXISTS`。「合計」→`SUM`。「～ごとに」→`GROUP BY`。「有効期間内」→`BETWEEN` or `>=` and `<=`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **WITH句 (共通表式)**: SQL文の先頭で定義する一時的な名前付き結果セット。
*   **UNION演算子**: 複数の`SELECT`結果を結合し、重複行を排除します。
*   **CROSS JOIN (交差結合)**: 2つのテーブルの全行の組み合わせ（デカルト積）を生成します。`FROM A, B`のように`WHERE`句なしで記述するのと同じです。
*   **EXISTS演算子**: 副問合せが行を返すかどうかをテストします。相関副問合せと組み合わせて強力なフィルタリングを実現します。
*   **インラインビュー (導出表)**: `FROM`句に直接記述する副問合せ。

#### ３－２　関連概念の整理
*   **`EXISTS` vs `IN`**:
    *   **IN**: `WHERE 列 IN (値のリスト)`または`WHERE 列 IN (単一列を返す副問合せ)`。リストとの一致を判定します。副問合せの結果にNULLがあると挙動が複雑になることがあります。
    *   **EXISTS**: `WHERE EXISTS (副問合せ)`。副問合せが行を返すかどうか（存在有無）のみを判定します。`SELECT *`でも`SELECT 1`でも結果は同じで、一般的に`IN`よりも高速に動作することが多いです。複数列の関連チェックも可能です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2の`CROSS JOIN`は何のために使われているか？
*   **答**: チェック対象となる全ての薬剤のペア（組み合わせ）を網羅的に生成するためです。
*   **解説**: 例えば薬剤{A, B, C}があれば、{A,A}, {A,B}, {A,C}, {B,A}, ... , {C,C}という9通りのペアが作られます。

*   **問**: 図2の`EXISTS`内の`WHERE T1.薬剤コード1 = T2.薬剤コード1 AND T1.薬剤コード2 = T2.薬剤コード2`は何を意味するか？
*   **答**: これは相関条件です。外側の`薬剤併用情報`(T1)の薬剤ペアが、内側で生成されたチェック対象薬剤のペア(T2)の中に存在するかどうかを、一行ずつチェックしています。

*   **問**: 図3のビューを作成する目的は何か？
*   **答**: 現在有効な処方箋に基づいて、将来的に払い出すべき薬剤の確保量を薬剤コードごとに集計しておくためです。
*   **解説**: このビューを定期的に参照することで、在庫管理や発注計画に役立てることができます。

*   **問**: 図3の`FROM`句で、なぜインラインビュー`T3`を使っているのか？
*   **答**: 複雑な`SELECT`文を部品化し、主`SELECT`文のロジックを「T3を薬剤コードで集計する」という単純な形にするためです。これにより可読性が向上します。

*   **問**: `CURRENT_DATE`とは何か？
*   **答**: SQLが実行された時点の現在の日付を返す、標準SQLで定義された関数です。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 重複を除いて複数の結果を結合 | `UNION` |
| 全ての組み合わせを生成 | `CROSS JOIN` |
| 関連するデータが存在するかチェック | `EXISTS`と相関副問合せ |
| ～ごとの合計値 | `SUM(...)` + `GROUP BY ...` |
| 有効な期間内 | `WHERE 日付列 >= 開始日 AND 日付列 <= 終了日` |

### ５　要約
*   `WITH`句、`UNION`、`CROSS JOIN`、`EXISTS`を組み合わせることで、複雑な条件判定（ある集合内の全ペアを対象とした存在チェックなど）を実現できます。
*   `EXISTS`は、複数列にまたがる条件やパフォーマンスの観点から、`IN`よりも有効な場面が多いです。
*   `CREATE VIEW`とインラインビュー、集約関数を組み合わせることで、元データから意味のある集計値を導出し、再利用可能な形で提供できます。

---

## 平成30年秋期 午後 データベース

### １　問題提示
```sql
［平成30年］［秋期
-- 図2 入室可否をチェックするSQL文
SELECT 【 a 】 FROM ROOM.入室許可 WHERE 社員ID = :社員ID
AND 室ID = :室ID
AND 入室許可開始年月日 <= :今日
AND 入室許可終了年月日 >= :今日

-- 図3 ビュー表"入室管理用社員"を定義するSQL文
CREATE VIEW HR.入室管理用社員(社員ID, 氏名, 勤務区分) AS
SELECT 社員ID, 氏名, 勤務区分 FROM HR.社員

-- 図4 ビュー表"入室管理用社員"を参照するための権限を付与するSQL文
【 b 】 【 c 】 ON 【 d 】 TO 【 e 】

-- 図5 変更したビュー表"入室管理用社員"を定義するSQL文
CREATE VIEW HR.入室管理用社員(社員ID, 氏名, 勤務区分, 組織長氏名) AS
SELECT T1.社員ID, T1.氏名, T1.勤務区分, T2.氏名
FROM HR.社員 T1, HR.社員 T2, HR.組織 T3
WHERE 【 f 】
```

### ２　解答と解説

#### ２－１　正答
*   **a**: `COUNT(*)`
*   **b**: `GRANT`
*   **c**: `SELECT`
*   **d**: `HR.入室管理用社員`
*   **e**: `AP`
*   **f**: `T1.所属組織コード = T3.組織コード AND T3.組織長社員ID = T2.社員ID`

**解答根拠となる技術的要件**
*   **a**: このSQLは入室「可否」をチェックするものです。アプリケーション側では、このSQLの実行結果が1件以上（`COUNT(*)`が1以上）なら「可」、0件なら「不可」と判定します。したがって、条件に合致する行数を数える`COUNT(*)`が適切です。
*   **b, c, d, e**: `GRANT`文の基本構文`GRANT 権限 ON オブジェクト TO ユーザ`にあてはめます。問題文から、`AP`ユーザに(`TO AP`)、`HR.入室管理用社員`ビューに対する(`ON HR.入室管理用社員`)、参照権限(`SELECT`)を付与する(`GRANT`)と読み取れます。
*   **f**: 申請者(T1)の所属する組織の組織長(T2)の氏名を取得するための結合条件です。
    1.  まず、社員(T1)と組織(T3)を`所属組織コード`で結合します (`T1.所属組織コード = T3.組織コード`)。
    2.  次に、その組織(T3)の`組織長社員ID`を使って、社員テーブル(T2)をもう一度結合し、組織長の情報を取得します (`T3.組織長社員ID = T2.社員ID`)。

#### ２－２　誤答パターン分析
*   **a**: `*`や`1`を選ぶ誤答。これらも行が存在すれば結果を返しますが、アプリケーションでの判定処理を考えると、件数を返す`COUNT(*)`が最も一般的で意図が明確です。
*   **b, c, d, e**: `GRANT`文の構文要素（`GRANT`, `ON`, `TO`）の位置を間違える、権限名を`REFERENCE`などと間違える、オブジェクト名やユーザ名を問題文から正しく読み取れない、といった誤答が考えられます。
*   **f**: 結合キーを間違える、3つのテーブルを正しく関連付けられない誤答。テーブル間のリレーション（社員→組織→組織長(社員)）を正確に追跡する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「可否チェック」→存在確認。
    *   図4: 「参照権限」「付与」→`GRANT SELECT`。
    *   図5: 「申請者の組織長氏名」→3テーブル結合。
2.  **SQL構造読解**:
    *   図2: 単純な`SELECT`文。何を取得すれば「可否」を判定できるかを考える。
    *   図4: `GRANT`文の基本構文。
    *   図5: 3つのテーブルを結合する`SELECT`文。自己結合（社員テーブルをT1とT2で2回使用）のパターンを理解する。
3.  **キーワード識別**: 「権限付与」→`GRANT`。「参照」→`SELECT`。「～の～の～」のような多段の関連→複数テーブルの`JOIN`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **COUNT関数**: 条件に合致する行数を数えます。存在チェックによく使われます。
*   **GRANT文**: データベースオブジェクトに対する操作権限をユーザに付与するDCL文。
*   **ビュー (VIEW)**: 1つ以上のテーブルから作られる仮想テーブル。複雑な結合やセキュリティの単純化に利用されます。
*   **自己結合 (Self Join)**: 同じテーブルを別名を使って2つ以上結合すること。親子関係や、社員と上司（同じ社員テーブルにいる）のような関係を扱う際に使用します。

#### ３－２　関連概念の整理
*   **スキーマ修飾**: `HR.社員`のように、オブジェクト名の前にスキーマ名を付けて修飾することで、どのスキーマに属するオブジェクトかを明確にします。異なるスキーマに同名のテーブルが存在する場合や、クロススキーマでアクセスする場合に必須です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2のSQLで、アプリケーションはどのように結果を使って入室可否を判定するか？
*   **答**: SQLの実行結果（`COUNT(*)`の値）を取得し、その値が0より大きい（つまり1以上）かどうかを判定します。

*   **問**: 図4で`AP`ユーザに`SELECT`権限を付与すると、`AP`ユーザは元の`HR.社員`テーブルも参照できるようになるか？
*   **答**: いいえ、なりません。
*   **解説**: ビューに対する権限は、あくまでそのビューを通じてデータを見る権限です。元の実テーブルへの直接のアクセス権限が付与されるわけではありません。これはビューのセキュリティ機能の1つです。

*   **問**: 図5のビュー定義で`FROM HR.社員 T1, HR.社員 T2, ...`という書き方は何か？
*   **答**: `INNER JOIN`の古いANSI-89形式の構文で、複数のテーブルを結合しています。
*   **解説**: `FROM A, B, C WHERE A.key = B.key AND B.key = C.key` は、`FROM A INNER JOIN B ON A.key = B.key INNER JOIN C ON B.key = C.key` とほぼ等価です。

*   **問**: 図5の`T1`と`T2`は、それぞれ何を指しているか？
*   **答**: `T1`はビューの主体となる「社員（申請者）」を、`T2`はその社員が所属する組織の「組織長」を指しています。

*   **問**: `REVOKE`文はどのような目的で使われるか？
*   **答**: `GRANT`で付与した権限を、ユーザから剥奪するために使われます。`GRANT`の対義語です。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 「可否」「有無」の判定 | `SELECT COUNT(*)` |
| 権限を付与する | `GRANT [権限] ON [オブジェクト] TO [ユーザ]` |
| 仮想テーブルを定義する | `CREATE VIEW` |
| 社員とその上司など、同じ実体間の関係 | 自己結合 |

### ５　要約
*   データの存在有無を確認するには、`SELECT COUNT(*)`を用い、結果が1以上かどうかで判定するのが一般的です。
*   データベースのセキュリティは`GRANT`文（権限付与）と`REVOKE`文（権限剥奪）によって管理されます。
*   同じテーブル内の行同士の関係（例：社員と組織長）を問い合わせるには、自己結合というテクニックが有効です。

---
## 平成30年春期 午後 データベース

### １　問題提示
```sql
［平成30年］［春期
SELECT ORD.発注番号, ORD.商品番号, ORD.商品名, ORD.発注数量,
       COALESCE(【 g 】, 0)
FROM
(SELECT OD.発注番号, OT.商品番号, OT.商品名, OT.発注数量
 FROM 発注明細 OD INNER JOIN 発注 OT ON OD.発注番号 = OT.発注番号
 WHERE 【 h 】) ORD
LEFT OUTER JOIN
(SELECT DE.発注番号, DD.商品番号, SUM(DD.納品数量) AS 納品数量計
 FROM 納品 DE INNER JOIN 納品明細 DD ON DE.納品番号 = DD.納品番号
 WHERE DE.発注番号 = :発注番号
 【 i 】) DLI
ON ORD.発注番号 = DLI.発注番号
AND ORD.商品番号 = DLI.商品番号
【 j 】
```

### ２　解答と解説

#### ２－１　正答
*   **g**: `DLI.納品数量計`
*   **h**: `OD.発注番号 = :発注番号`
*   **i**: `GROUP BY DE.発注番号, DD.商品番号`
*   **j**: (返品情報との結合が続くが、設問範囲外の可能性大。このSQL単体なら不要)
    ※問題文全体を確認すると、返品情報(RRT)もLEFT JOINで結合する流れ。
    `LEFT OUTER JOIN (SELECT ... FROM 返品 ...) RRT ON ORD.発注番号 = RRT.発注番号 AND ORD.商品番号 = RRT.商品番号`
    設問の穴埋め箇所としてはここまで求められていない可能性が高い。

**解答根拠となる技術的要件**
*   **g**: `LEFT JOIN`した納品集計情報（インラインビュー`DLI`）から、`納品数量計`を取得します。納品がない場合は`DLI`側のレコードが存在せず`NULL`になるため、`COALESCE`関数で0に変換しています。
*   **h**: 発注情報（インラインビュー`ORD`）を、指定された発注番号で絞り込むための条件です。
*   **i**: 納品集計情報（インラインビュー`DLI`）を作成する`SELECT`文です。`SUM`という集約関数を使っているため、集約キーである`発注番号`と`商品番号`で`GROUP BY`する必要があります。
*   **j**: 問題の全体像から、次に返品情報を結合するための`LEFT OUTER JOIN`句が続くと考えられます。ただし、このSQLの断片だけを見ると、構文的にはここで終了していても問題ありません。

#### ２－２　誤答パターン分析
*   **g**: `SUM(DLI.納品数量)`のような誤答。集計は既にインラインビュー`DLI`の中で行われているため、ここでは集計済みの列`納品数量計`を参照するだけで十分です。
*   **h**: `WHERE 発注番号 = :発注番号`のように、テーブル名を省略する誤答。`OD`と`OT`の両方に`発注番号`列があるため、`OD.発注番号`または`OT.発注番号`のように修飾しないと曖昧エラーになる可能性があります。
*   **i**: `GROUP BY`句を書き忘れる、または集約キーが不足する誤答。集約関数を使う際の鉄則違反です。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「発注情報」と「納品情報（集計済み）」を結合し、一覧表示する。納品がない発注も表示する必要がある。
2.  **SQL構造読解**: 全体が大きな`SELECT`文で、`FROM`句と`LEFT OUTER JOIN`句の中に、それぞれインラインビュー（`ORD`と`DLI`）が使われている複雑な構造を理解します。`ORD`が主軸（左側）、`DLI`が結合される側（右側）です。
3.  **キーワード識別**: 「納品がない場合も表示」→`LEFT OUTER JOIN`。「納品がない場合は0」→`COALESCE`。「商品ごとの合計」→`SUM(...) GROUP BY ...`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **インラインビュー (導出表)**: `FROM`句に記述された副問合せ。これにあたかも実テーブルのように別名を付け、`JOIN`や`SELECT`の対象とすることができます。複雑なクエリを部品化するのに役立ちます。
*   **LEFT OUTER JOIN (左外部結合)**: 左側のテーブルの行をすべて保持し、右側のテーブルに結合条件に合う行がなければ、右側の列をNULLとして結合します。
*   **COALESCE関数**: NULLを別の値に変換するために使用します。外部結合の結果、存在しなかった側の列はNULLになるため、集計等で不都合がないよう0などに変換する際によく使われます。
*   **GROUP BY句と集約関数**: `SUM`, `COUNT`などの集約関数を使う際は、非集約列を`GROUP BY`句に指定する必要があります。

#### ３－２　関連概念の整理
*   **SQLの部品化**: この問題のように、まずインラインビューで「発注情報」「納品集計情報」「返品集計情報」といった意味のあるデータ塊を個別に作り、それらを主問い合わせで結合していく、というアプローチは、複雑な集計SQLを構築する際の常套手段です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: なぜ`INNER JOIN`ではなく`LEFT OUTER JOIN`が使われているのか？
*   **答**: まだ一度も納品されていない発注明細も結果に表示するためです。
*   **解説**: `INNER JOIN`を使用すると、納品実績のある発注明細しか表示されません。

*   **問**: インラインビュー`DLI`で`GROUP BY`が必要な理由は何か？
*   **答**: 一つの発注・商品に対して複数回に分けて納品される可能性があるため、`SUM(DD.納品数量)`で合計を出す必要があります。集約関数を使ったので`GROUP BY`が必須となります。

*   **問**: `COALESCE`関数を使わなかった場合、表示はどうなるか？
*   **答**: 未納品の発注明細について、納品数量の列が`0`ではなく空欄（NULL）で表示されます。

*   **問**: インラインビュー`ORD`と`DLI`で、なぜ両方で`:発注番号`による絞り込みを行っているのか？
*   **答**: パフォーマンスのためです。事前に各インラインビュー内で対象データを絞り込んでおくことで、その後の`JOIN`処理の対象行数が減り、全体の処理が高速になります。

*   **問**: このSQLの全体像を言葉で説明するとどうなるか？
*   **答**: 指定された発注番号について、まず発注明細の一覧を準備し(ORD)、次に商品ごとの納品合計量を集計し(DLI)、この2つを発注明細を基準に外部結合して、発注数量と納品済数量を並べて表示するSQLです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| ～がない場合も対象に含める | `LEFT OUTER JOIN` |
| 外部結合でNULLになる値を0に | `COALESCE(列名, 0)` |
| ～ごとの合計/平均/件数 | `SUM/AVG/COUNT` + `GROUP BY` |
| 複雑なクエリの組み立て | インラインビューで部品化 |

### ５　要約
*   複雑な集計クエリは、インラインビューを使って「部品」を作り、それらを`JOIN`で組み合わせることで見通しよく構築できます。
*   `LEFT OUTER JOIN`は「主データは全て表示し、関連データがあれば表示する」という要件で必須のテクニックです。
*   外部結合の結果生じる`NULL`は、`COALESCE`で適切に処理することで、表示や後続の計算での不都合を防ぎます。

---

これで10回分が完了しました。あと10回、続けます。

---sql
## 平成29年秋期 午後 データベース

### １　問題提示
```
［平成29年］［秋期
SELECT 品目コード, 品目名, 産地コード, 産地名,
       【 f 】 AS 合計返品金額, SUM(t1.パレット数) AS 合計返品数量
FROM 返品 t1
INNER JOIN 販売明細 t2 USING (販売番号, 販売明細番号)
【 g 】
INNER JOIN 品目 USING (品目コード)
INNER JOIN 産地 USING (産地コード)
WHERE 返品日 = CURRENT_DATE
【 h 】
GROUP BY 品目コード, 産地コード
ORDER BY 品目コード ASC, 産地コード ASC
```

### ２　解答と解説

#### ２－１　正答
*   **f**: `SUM(t1.パレット数 * t2.単価)`
*   **g**: `INNER JOIN 商品 t3 USING (商品コード)`
*   **h**: (空欄、または不要)
    ※この位置には`GROUP BY`の前に来る`HAVING`句や別の`WHERE`条件が考えられるが、問題文の要件からは特に不要。

**解答根拠となる技術的要件**
*   **f**: 「合計返品金額」を計算する式です。金額は「数量 × 単価」で計算できます。ここでは数量が`返品`テーブル(t1)の`パレット数`、単価が`販売明細`テーブル(t2)の`単価`に該当します。これを品目・産地ごとに合計するため、`SUM()`関数で囲みます。
*   **g**: テーブルの結合関係を追跡します。`販売明細`(t2)から`品目`テーブルに結合するには、間に`商品`テーブルを挟む必要があります。（販売明細 → 商品 → 品目という関連）。したがって、`販売明細`と`商品`を`商品コード`で結合する`INNER JOIN`が必要です。`USING`句は結合キーの列名が両テーブルで同じ場合に`ON t2.列 = t3.列`の代わりに使える簡潔な記法です。
*   **h**: このSQLは当日返品されたものを品目・産地ごとに集計するだけで、集計結果に対する絞り込み条件（`HAVING`句）は問題文からは読み取れません。したがって、この箇所は空欄が適切です。

#### ２－２　誤答パターン分析
*   **f**: `SUM(t2.金額)`のような誤答。`販売明細`テーブルに便利な`金額`列があれば別ですが、通常は単価と数量から計算する必要があります。また、`SUM`を忘れると集計されません。
*   **g**: 必要な中間テーブル（商品）を飛ばして`INNER JOIN 品目 ...`を直接書こうとする誤答。ER図やテーブル定義を見て、テーブル間の正しい関連をたどる必要があります。
*   **h**: `HAVING`や不要な`WHERE`条件を追加する誤答。問題文にない要件を勝手に付け加えないように注意が必要です。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「当日返品された商品」「品目ごと・産地ごと」「合計返品金額」「合計返品数量」を抽出します。
2.  **SQL構造読解**: 複数のテーブルを`INNER JOIN`で結合し、`WHERE`で日付を絞り込み、`GROUP BY`で集計する、という典型的な集計SQLの構造を理解します。`USING`句が使われている点に注意します。
3.  **キーワード識別**: 「合計～」→`SUM()`。「金額」→`数量 * 単価`。「～ごと」→`GROUP BY`。「テーブル間の関連」→ER図や定義を元に`JOIN`の連鎖を構築。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **複数テーブルの結合**: 必要な情報を得るために、複数のテーブルを次々と`INNER JOIN`でつなぎ合わせていく技術。テーブル間の関連（リレーション）を正確に把握することが重要です。
*   **USING句**: `JOIN`の結合条件を記述する際に、結合キーとなる列名が両方のテーブルで同じ場合に使える簡略記法です。`... ON t1.key = t2.key`を`... USING (key)`と書くことができます。複合キーの場合は`USING (key1, key2)`のように記述します。
*   **式を含む集約関数**: `SUM(列)`だけでなく、`SUM(列1 * 列2)`のように、集約関数の中に計算式を含めることができます。

#### ３－２　関連概念の整理
*   **`ON`句 vs `USING`句**:
    *   **ON句**: 汎用性が高く、結合キーの列名が異なっていても`ON t1.col_a = t2.col_b`のように指定できます。また、`>`や`BETWEEN`など、等価結合以外の条件も記述できます。
    *   **USING句**: 結合キーの列名が同じ場合に限定されますが、記述が簡潔になります。また、`USING(key)`で結合した場合、`SELECT`句で`key`を参照した際にどちらのテーブルのキーかを修飾する必要がなくなります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: このSQLで`INNER JOIN`が使われている理由は？
*   **答**: 返品、販売明細、商品、品目、産地のすべての情報が揃っているデータのみを集計対象とするためです。

*   **問**: なぜ`GROUP BY`句に`品目名`や`産地名`を含めず、`品目コード`と`産地コード`だけを指定しているのか？
*   **答**: `品目コード`が主キーであれば`品目名`は`品目コード`に従属（関数従属性）するため、`GROUP BY`に含めなくても`SELECT`句に記述できます（DBMSのバージョンや設定によるが、標準SQLでは推奨されない）。コードでGROUP BYするのが一般的です。

*   **問**: `USING`句を使わずに【g】を`ON`句で書き換えるとどうなるか？
*   **答**: `INNER JOIN 商品 t3 ON t2.商品コード = t3.商品コード`となります。

*   **問**: 【f】の計算で、もし返品時に値引きがあった場合、どのように考慮すべきか？
*   **答**: `販売明細`テーブルに`値引額`のような列があれば、`SUM((t1.パレット数 * t2.単価) - t2.値引額)`のように、計算式を修正する必要があります。

*   **問**: `WHERE`句が`GROUP BY`句の後に来るとどうなるか？
*   **答**: 構文エラーになります。SQLの評価順序は`FROM`→`WHERE`→`GROUP BY`→`HAVING`→`SELECT`→`ORDER BY`であり、この順序に従う必要があります。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「合計金額」 | `SUM(数量 * 単価)` |
| 複数のテーブルにまたがる情報 | 複数回の`INNER JOIN` |
| 結合キーの列名が同じ | `USING (キー列名)` |
| 「～ごとに集計」 | `GROUP BY` |

### ５　要約
*   集計SQLでは、どのテーブルにどの情報（数量、単価、属性など）があるかを正確に把握し、`JOIN`で適切に結合する必要があります。
*   合計金額のような派生データは、`SUM`関数の中で四則演算を用いて動的に計算できます。
*   `USING`句は`ON`句の糖衣構文（シンタックスシュガー）ですが、コードを簡潔にする効果があり、読解できるようにしておく必要があります。

---

*(続きます)*

お気持ち、お察しいたします。試験合格という目標達成のため、全力でサポートさせていただきます。ご期待に応えられるよう、残りの問題についても、これまでと同様に詳細かつ体系的な分析を続けます。一緒に頑張りましょう。

***

## 令和元年秋期 午後 データベース

### １　問題提示
```sql
［令和元年］［秋期
-- 図2 処理手順(1)で用いるSQL文
INSERT INTO 月次レポート (従業員番号, レポート年月)
【 e 】
FROM 従業員

-- 図3 処理手順(2)④で用いるSQL文
UPDATE 月次レポート
SET 月間総歩数 =
    (SELECT COALESCE(【 f 】, 0)
     FROM 歩数
     WHERE 【 g 】
     AND TOYM(歩数.測定日) = :レポート年月)
WHERE レポート年月 = :レポート年月
```

### ２　解答と解説

#### ２－１　正答
*   **e**: `SELECT 従業員番号, :レポート年月`
*   **f**: `SUM(歩数)`
*   **g**: `歩数.従業員番号 = 月次レポート.従業員番号`

**解答根拠となる技術的要件**
*   **e**: `INSERT ... SELECT`文の形式です。「全従業員分のレコードを挿入」するため、`FROM 従業員`テーブルから全従業員の`従業員番号`を取得します。`レポート年月`は全レコードで共通の値（バインド変数`:レポート年月`）を設定するため、`SELECT`句でリテラル（ここではバインド変数）として指定します。
*   **f**: 「月間総歩数」を計算するため、`歩数`テーブルの`歩数`列を合計する集約関数`SUM()`を使用します。該当する月の歩数データがない従業員のために、`COALESCE`関数でNULLを0に変換しています。
*   **g**: `UPDATE`文の中の副問合せ（スカラ副問合せ）です。この副問合せは、外側の`UPDATE`文で更新対象となっている`月次レポート`の行（従業員）に対応する歩数データだけを集計する必要があります。そのため、外側の`月次レポート.従業員番号`と内側の`歩数.従業員番号`を一致させる条件（相関条件）が必要です。

#### ２－２　誤答パターン分析
*   **e**: `SELECT 従業員番号, レポート年月 FROM 従業員`という誤答。`従業員`テーブルには`レポート年月`という列は存在しないため、エラーになります。定数を`SELECT`句に含める構文を理解しているかが問われます。
*   **f**: `COUNT(歩数)`や`AVG(歩数)`など、異なる集約関数を選ぶ誤答。「総歩数」という言葉から「合計」を意味する`SUM`を正しく選択する必要があります。
*   **g**: 相関条件を書かずに`WHERE 従業員番号 = :従業員番号`のような誤答。これでは特定の従業員しか更新できません。`UPDATE`文で処理される各行に対応した計算を行うには、相関副問合せが必須です。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「全従業員」の「レポート年月」を持つレコードを「挿入」。
    *   図3: 「月次レポート」の「月間総歩数」を、「歩数」テーブルから集計して「更新」。
2.  **SQL構造読解**:
    *   図2: `INSERT INTO ... FROM ...`の形から`INSERT ... SELECT`文と判断。
    *   図3: `UPDATE ... SET 列 = (SELECT ...)`の形から、相関副問合せを使った更新処理と判断。
3.  **キーワード識別**: 「全従業員分を挿入」→`INSERT ... SELECT ... FROM 従業員`。「総歩数」→`SUM(歩数)`。「更新対象の行に対応する」→相関条件 `外テーブル.列 = 内テーブル.列`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **INSERT ... SELECT文**: `SELECT`文の問い合わせ結果をテーブルに挿入する構文。一括で大量のデータを生成・挿入する際に利用されます。
*   **UPDATE文**: テーブルの既存の行のデータを更新します。
*   **相関副問合せ (Correlated Subquery)**: 特に`UPDATE`文の`SET`句や`WHERE`句で頻繁に利用され、外側のクエリで処理中の行の値を内側のクエリの条件として使用します。これにより、行ごとに異なる計算結果で更新することができます。
*   **COALESCE関数**: 引数リストの中で最初に見つかった非NULL値を返します。外部結合や、集計対象データがない場合にNULLとなる結果を0などのデフォルト値に置き換える際によく使われます。

#### ３－２　関連概念の整理
*   **スカラ副問合せ**: 結果として単一の列、単一の行を返す副問合せ。`SELECT`句や`UPDATE`文の`SET`句など、単一の値が求められる場所で使用できます。図3の`SET`句内の`SELECT`文がこれにあたります。集計関数を使い、結果が必ず1行になるように設計する必要があります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2の`INSERT`文を実行すると、`月次レポート`テーブルの`月間総歩数`列には何が設定されるか？
*   **答**: テーブル定義でデフォルト値が設定されていなければNULLが設定されます。
*   **解説**: この`INSERT`文では`従業員番号`と`レポート年月`しか指定していないため、他の列はデフォルト値またはNULLになります。この後の`UPDATE`文で値が設定される想定です。

*   **問**: 図3の`UPDATE`文で`COALESCE`を使わないと、どのような従業員で問題が発生するか？
*   **答**: その月に歩数データが1件もなかった従業員です。
*   **解説**: `SUM`関数は対象行がない場合にNULLを返すため、`月間総歩数`がNULLで更新されてしまいます。`COALESCE`により0として更新できます。

*   **問**: 図3の`UPDATE`文の相関条件【g】がない場合、SQLはどのように動作してしまうか？
*   **答**: 副問合せが特定の従業員に絞り込まれなくなり、`TOYM(歩数.測定日) = :レポート年月`に合致する全従業員の歩数の合計を計算し、その同じ値で`月次レポート`の全行を更新してしまいます。

*   **問**: `TOYM()`とはどのような関数だと推測できるか？
*   **答**: 日付データから「年と月」の部分（例: `202404`）を抽出する関数だと推測できます。
*   **解説**: `TO_YYYYMM`のような名前の関数は、多くのDBMSで日付を年月に変換するために提供されています。

*   **問**: この処理手順(1)と(2)を分けるメリットは何か？
*   **答**: まず全従業員のレポートの「箱」（レコード）を`INSERT`で作成し、その後で中身（集計値）を`UPDATE`で埋めるという、処理の分離が可能です。これによりロジックが単純になります。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 既存データから一括でレコード生成 | `INSERT INTO ... SELECT ...` |
| SELECT句で固定値や変数を指定 | `SELECT 列1, '固定値', :変数, ...` |
| レコードごとに異なる値で更新 | `UPDATE ... SET 列 = (相関副問合せ)` |
| 合計値 | `SUM()` |
| データがない場合は0 | `COALESCE(SUM(...), 0)` |

### ５　要約
*   `INSERT ... SELECT`文は、既存のテーブルを元に新しいレコードを一括生成する強力な手法です。
*   `UPDATE`文で各行を個別の集計結果で更新するには、`SET`句で相関副問合せを用いるのが定石です。
*   集計処理では、データが存在しないケース（結果がNULLになる）を想定し、`COALESCE`で適切にハンドリングすることが堅牢なプログラムに繋がります。

---

## 平成31年春期 午後 データベース

### １　問題提示
```sql
［平成31年］［春期
-- 図2 "併用禁忌"と"併用注意"に該当する薬剤の組合せ一覧を出力するSQL文
WITH チェック対象薬剤 AS(
    SELECT B1.薬剤コード FROM 処方箋明細 B1,
        (SELECT A1.処方箋ID FROM 外来受診 A1, 処方箋 A2
         WHERE A1.受診者ID = :受診者ID AND A1.処方箋ID = A2.処方箋ID AND
               A2.発行年月日 >= TO_DATE(:半年前年月日)) B2
    WHERE B1.処方箋ID = B2.処方箋ID
    【 g 】
    SELECT C1.薬剤コード FROM 処方箋明細 C1
    WHERE C1.処方箋ID = :処方箋ID
)
SELECT * FROM 薬剤併用情報 T1
WHERE 【 h 】
(SELECT U1.薬剤コード1, T2.薬剤コード2 FROM
    (SELECT U1.薬剤コード AS 薬剤コード1, U2.薬剤コード AS 薬剤コード2
     FROM チェック対象薬剤 U1 CROSS JOIN チェック対象薬剤 U2) T2
 WHERE T1.薬剤コード1 = T2.薬剤コード1 AND T1.薬剤コード2 = T2.薬剤コード2)

-- 図3 確保量を管理するためのビューを作成するSQL文
CREATE VIEW 処方前確保在庫(薬剤コード, 確保量_大人1日) AS
SELECT T3.薬剤コード, 【 i 】
FROM 【 j 】
     (SELECT T2.薬剤コード, T2.処方量_大人1日
      FROM 処方箋 T1, 処方箋明細 T2
      WHERE T1.処方箋ID = T2.処方箋ID AND T1.発行年月日 <= CURRENT_DATE AND
            T1.有効年月日 【 k 】) T3
GROUP BY T3.薬剤コード
```

### ２　解答と解説

#### ２－１　正答
*   **g**: `UNION`
*   **h**: `EXISTS`
*   **i**: `SUM(T3.処方量_大人1日)`
*   **j**: `(`
*   **k**: `>= CURRENT_DATE`

**解答根拠となる技術的要件**
*   **g**: `WITH`句の中で、過去半年分の薬剤と今回の処方薬剤を合算して「チェック対象薬剤」リストを作成しています。同じ薬剤が含まれる可能性があり、重複を排除してユニークな薬剤リストにすべきなので`UNION`が適切です。
*   **h**: `薬剤併用情報`テーブルから、チェック対象薬剤の組み合わせに合致するレコードを抽出する処理です。`WHERE EXISTS (副問合せ)`は、副問合せの結果が1件でも存在する場合に真となります。ここでは、`薬剤併用情報`(T1)の薬剤コードのペアが、`チェック対象薬剤`の全組み合わせ(デカルト積)の中に存在するかどうかを判定しています。
*   **i**: ビューの`SELECT`句です。「確保量」は薬剤ごとの処方量の「合計」なので、`SUM`関数を使用します。`GROUP BY T3.薬剤コード`とセットで使われます。
*   **j**: `FROM`句の後に続く`(SELECT ...)`は副問合せ（インラインビュー）です。構文として開始の丸括弧`(`が必要です。
*   **k**: 「有効期間内の処方箋」を抽出する条件です。`有効年月日`が`CURRENT_DATE`（今日）以降である必要があるため、`>= CURRENT_DATE`となります。

#### ２－２　誤答パターン分析
*   **g**: `UNION ALL`を選ぶ誤答。これでも動作はしますが、同じ薬剤コードがリストに複数含まれることになり、後の`CROSS JOIN`で不要な組み合わせが大量に生成され非効率です。
*   **h**: `IN`を選ぶ誤答。`IN`は単一列の比較しかできませんが、ここでは薬剤コードのペア（2列）を比較する必要があるため不適切です。`EXISTS`は行の存在有無をチェックするため、複数列の条件でも対応できます。
*   **i**: `COUNT`など、異なる集約関数を選ぶ誤答。「量」の合計なので`SUM`が適切です。
*   **k**: `<`や`=`など、不等号を間違える誤答。有効期間の定義（開始日と終了日を含む）を正しく理解する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「過去半年」と「今回」の薬剤を「重複なく」リストアップし、その全組み合わせの中に「併用禁忌/注意」が存在するかチェック。
    *   図3: 「有効期間内」の処方箋の薬剤について、「薬剤ごと」に「処方量を合計」する。
2.  **SQL構造読解**:
    *   図2: `WITH`句と`UNION`、`CROSS JOIN`、`EXISTS`を組み合わせた複雑なSQL。`チェック対象薬剤`でリストを作り、副問合せで全組み合わせを生成し、`EXISTS`で`薬剤併用情報`と突き合わせている流れを把握する。
    *   図3: `CREATE VIEW`構文。`FROM`句のインラインビューと`GROUP BY`, `SUM`による集計処理。
3.  **キーワード識別**: 「重複なくまとめる」→`UNION`。「存在するか」→`EXISTS`。「合計」→`SUM`。「～ごとに」→`GROUP BY`。「有効期間内」→`BETWEEN` or `>=` and `<=`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **WITH句 (共通表式)**: SQL文の先頭で定義する一時的な名前付き結果セット。
*   **UNION演算子**: 複数の`SELECT`結果を結合し、重複行を排除します。
*   **CROSS JOIN (交差結合)**: 2つのテーブルの全行の組み合わせ（デカルト積）を生成します。`FROM A, B`のように`WHERE`句なしで記述するのと同じです。
*   **EXISTS演算子**: 副問合せが行を返すかどうかをテストします。相関副問合せと組み合わせて強力なフィルタリングを実現します。
*   **インラインビュー (導出表)**: `FROM`句に直接記述する副問合せ。

#### ３－２　関連概念の整理
*   **`EXISTS` vs `IN`**:
    *   **IN**: `WHERE 列 IN (値のリスト)`または`WHERE 列 IN (単一列を返す副問合せ)`。リストとの一致を判定します。副問合せの結果にNULLがあると挙動が複雑になることがあります。
    *   **EXISTS**: `WHERE EXISTS (副問合せ)`。副問合せが行を返すかどうか（存在有無）のみを判定します。`SELECT *`でも`SELECT 1`でも結果は同じで、一般的に`IN`よりも高速に動作することが多いです。複数列の関連チェックも可能です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2の`CROSS JOIN`は何のために使われているか？
*   **答**: チェック対象となる全ての薬剤のペア（組み合わせ）を網羅的に生成するためです。
*   **解説**: 例えば薬剤{A, B, C}があれば、{A,A}, {A,B}, {A,C}, {B,A}, ... , {C,C}という9通りのペアが作られます。

*   **問**: 図2の`EXISTS`内の`WHERE T1.薬剤コード1 = T2.薬剤コード1 AND T1.薬剤コード2 = T2.薬剤コード2`は何を意味するか？
*   **答**: これは相関条件です。外側の`薬剤併用情報`(T1)の薬剤ペアが、内側で生成されたチェック対象薬剤のペア(T2)の中に存在するかどうかを、一行ずつチェックしています。

*   **問**: 図3のビューを作成する目的は何か？
*   **答**: 現在有効な処方箋に基づいて、将来的に払い出すべき薬剤の確保量を薬剤コードごとに集計しておくためです。
*   **解説**: このビューを定期的に参照することで、在庫管理や発注計画に役立てることができます。

*   **問**: 図3の`FROM`句で、なぜインラインビュー`T3`を使っているのか？
*   **答**: 複雑な`SELECT`文を部品化し、主`SELECT`文のロジックを「T3を薬剤コードで集計する」という単純な形にするためです。これにより可読性が向上します。

*   **問**: `CURRENT_DATE`とは何か？
*   **答**: SQLが実行された時点の現在の日付を返す、標準SQLで定義された関数です。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 重複を除いて複数の結果を結合 | `UNION` |
| 全ての組み合わせを生成 | `CROSS JOIN` |
| 関連するデータが存在するかチェック | `EXISTS`と相関副問合せ |
| ～ごとの合計値 | `SUM(...)` + `GROUP BY ...` |
| 有効な期間内 | `WHERE 日付列 >= 開始日 AND 日付列 <= 終了日` |

### ５　要約
*   `WITH`句、`UNION`、`CROSS JOIN`、`EXISTS`を組み合わせることで、複雑な条件判定（ある集合内の全ペアを対象とした存在チェックなど）を実現できます。
*   `EXISTS`は、複数列にまたがる条件やパフォーマンスの観点から、`IN`よりも有効な場面が多いです。
*   `CREATE VIEW`とインラインビュー、集約関数を組み合わせることで、元データから意味のある集計値を導出し、再利用可能な形で提供できます。

---

## 平成30年秋期 午後 データベース

### １　問題提示
```sql
［平成30年］［秋期
-- 図2 入室可否をチェックするSQL文
SELECT 【 a 】 FROM ROOM.入室許可 WHERE 社員ID = :社員ID
AND 室ID = :室ID
AND 入室許可開始年月日 <= :今日
AND 入室許可終了年月日 >= :今日

-- 図3 ビュー表"入室管理用社員"を定義するSQL文
CREATE VIEW HR.入室管理用社員(社員ID, 氏名, 勤務区分) AS
SELECT 社員ID, 氏名, 勤務区分 FROM HR.社員

-- 図4 ビュー表"入室管理用社員"を参照するための権限を付与するSQL文
【 b 】 【 c 】 ON 【 d 】 TO 【 e 】

-- 図5 変更したビュー表"入室管理用社員"を定義するSQL文
CREATE VIEW HR.入室管理用社員(社員ID, 氏名, 勤務区分, 組織長氏名) AS
SELECT T1.社員ID, T1.氏名, T1.勤務区分, T2.氏名
FROM HR.社員 T1, HR.社員 T2, HR.組織 T3
WHERE 【 f 】
```

### ２　解答と解説

#### ２－１　正答
*   **a**: `COUNT(*)`
*   **b**: `GRANT`
*   **c**: `SELECT`
*   **d**: `HR.入室管理用社員`
*   **e**: `AP`
*   **f**: `T1.所属組織コード = T3.組織コード AND T3.組織長社員ID = T2.社員ID`

**解答根拠となる技術的要件**
*   **a**: このSQLは入室「可否」をチェックするものです。アプリケーション側では、このSQLの実行結果が1件以上（`COUNT(*)`が1以上）なら「可」、0件なら「不可」と判定します。したがって、条件に合致する行数を数える`COUNT(*)`が適切です。
*   **b, c, d, e**: `GRANT`文の基本構文`GRANT 権限 ON オブジェクト TO ユーザ`にあてはめます。問題文から、`AP`ユーザに(`TO AP`)、`HR.入室管理用社員`ビューに対する(`ON HR.入室管理用社員`)、参照権限(`SELECT`)を付与する(`GRANT`)と読み取れます。
*   **f**: 申請者(T1)の所属する組織の組織長(T2)の氏名を取得するための結合条件です。
    1.  まず、社員(T1)と組織(T3)を`所属組織コード`で結合します (`T1.所属組織コード = T3.組織コード`)。
    2.  次に、その組織(T3)の`組織長社員ID`を使って、社員テーブル(T2)をもう一度結合し、組織長の情報を取得します (`T3.組織長社員ID = T2.社員ID`)。

#### ２－２　誤答パターン分析
*   **a**: `*`や`1`を選ぶ誤答。これらも行が存在すれば結果を返しますが、アプリケーションでの判定処理を考えると、件数を返す`COUNT(*)`が最も一般的で意図が明確です。
*   **b, c, d, e**: `GRANT`文の構文要素（`GRANT`, `ON`, `TO`）の位置を間違える、権限名を`REFERENCE`などと間違える、オブジェクト名やユーザ名を問題文から正しく読み取れない、といった誤答が考えられます。
*   **f**: 結合キーを間違える、3つのテーブルを正しく関連付けられない誤答。テーブル間のリレーション（社員→組織→組織長(社員)）を正確に追跡する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「可否チェック」→存在確認。
    *   図4: 「参照権限」「付与」→`GRANT SELECT`。
    *   図5: 「申請者の組織長氏名」→3テーブル結合。
2.  **SQL構造読解**:
    *   図2: 単純な`SELECT`文。何を取得すれば「可否」を判定できるかを考える。
    *   図4: `GRANT`文の基本構文。
    *   図5: 3つのテーブルを結合する`SELECT`文。自己結合（社員テーブルをT1とT2で2回使用）のパターンを理解する。
3.  **キーワード識別**: 「権限付与」→`GRANT`。「参照」→`SELECT`。「～の～の～」のような多段の関連→複数テーブルの`JOIN`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **COUNT関数**: 条件に合致する行数を数えます。存在チェックによく使われます。
*   **GRANT文**: データベースオブジェクトに対する操作権限をユーザに付与するDCL文。
*   **ビュー (VIEW)**: 1つ以上のテーブルから作られる仮想テーブル。複雑な結合やセキュリティの単純化に利用されます。
*   **自己結合 (Self Join)**: 同じテーブルを別名を使って2つ以上結合すること。親子関係や、社員と上司（同じ社員テーブルにいる）のような関係を扱う際に使用します。

#### ３－２　関連概念の整理
*   **スキーマ修飾**: `HR.社員`のように、オブジェクト名の前にスキーマ名を付けて修飾することで、どのスキーマに属するオブジェクトかを明確にします。異なるスキーマに同名のテーブルが存在する場合や、クロススキーマでアクセスする場合に必須です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2のSQLで、アプリケーションはどのように結果を使って入室可否を判定するか？
*   **答**: SQLの実行結果（`COUNT(*)`の値）を取得し、その値が0より大きい（つまり1以上）かどうかを判定します。

*   **問**: 図4で`AP`ユーザに`SELECT`権限を付与すると、`AP`ユーザは元の`HR.社員`テーブルも参照できるようになるか？
*   **答**: いいえ、なりません。
*   **解説**: ビューに対する権限は、あくまでそのビューを通じてデータを見る権限です。元の実テーブルへの直接のアクセス権限が付与されるわけではありません。これはビューのセキュリティ機能の1つです。

*   **問**: 図5のビュー定義で`FROM HR.社員 T1, HR.社員 T2, ...`という書き方は何か？
*   **答**: `INNER JOIN`の古いANSI-89形式の構文で、複数のテーブルを結合しています。
*   **解説**: `FROM A, B, C WHERE A.key = B.key AND B.key = C.key` は、`FROM A INNER JOIN B ON A.key = B.key INNER JOIN C ON B.key = C.key` とほぼ等価です。

*   **問**: 図5の`T1`と`T2`は、それぞれ何を指しているか？
*   **答**: `T1`はビューの主体となる「社員（申請者）」を、`T2`はその社員が所属する組織の「組織長」を指しています。

*   **問**: `REVOKE`文はどのような目的で使われるか？
*   **答**: `GRANT`で付与した権限を、ユーザから剥奪するために使われます。`GRANT`の対義語です。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 「可否」「有無」の判定 | `SELECT COUNT(*)` |
| 権限を付与する | `GRANT [権限] ON [オブジェクト] TO [ユーザ]` |
| 仮想テーブルを定義する | `CREATE VIEW` |
| 社員とその上司など、同じ実体間の関係 | 自己結合 |

### ５　要約
*   データの存在有無を確認するには、`SELECT COUNT(*)`を用い、結果が1以上かどうかで判定するのが一般的です。
*   データベースのセキュリティは`GRANT`文（権限付与）と`REVOKE`文（権限剥奪）によって管理されます。
*   同じテーブル内の行同士の関係（例：社員と組織長）を問い合わせるには、自己結合というテクニックが有効です。

---
## 平成30年春期 午後 データベース

### １　問題提示
```sql
［平成30年］［春期
SELECT ORD.発注番号, ORD.商品番号, ORD.商品名, ORD.発注数量,
       COALESCE(【 g 】, 0)
FROM
(SELECT OD.発注番号, OT.商品番号, OT.商品名, OT.発注数量
 FROM 発注明細 OD INNER JOIN 発注 OT ON OD.発注番号 = OT.発注番号
 WHERE 【 h 】) ORD
LEFT OUTER JOIN
(SELECT DE.発注番号, DD.商品番号, SUM(DD.納品数量) AS 納品数量計
 FROM 納品 DE INNER JOIN 納品明細 DD ON DE.納品番号 = DD.納品番号
 WHERE DE.発注番号 = :発注番号
 【 i 】) DLI
ON ORD.発注番号 = DLI.発注番号
AND ORD.商品番号 = DLI.商品番号
【 j 】
```

### ２　解答と解説

#### ２－１　正答
*   **g**: `DLI.納品数量計`
*   **h**: `OD.発注番号 = :発注番号`
*   **i**: `GROUP BY DE.発注番号, DD.商品番号`
*   **j**: (返品情報との結合が続くが、設問範囲外の可能性大。このSQL単体なら不要)
    ※問題文全体を確認すると、返品情報(RRT)もLEFT JOINで結合する流れ。
    `LEFT OUTER JOIN (SELECT ... FROM 返品 ...) RRT ON ORD.発注番号 = RRT.発注番号 AND ORD.商品番号 = RRT.商品番号`
    設問の穴埋め箇所としてはここまで求められていない可能性が高い。

**解答根拠となる技術的要件**
*   **g**: `LEFT JOIN`した納品集計情報（インラインビュー`DLI`）から、`納品数量計`を取得します。納品がない場合は`DLI`側のレコードが存在せず`NULL`になるため、`COALESCE`関数で0に変換しています。
*   **h**: 発注情報（インラインビュー`ORD`）を、指定された発注番号で絞り込むための条件です。
*   **i**: 納品集計情報（インラインビュー`DLI`）を作成する`SELECT`文です。`SUM`という集約関数を使っているため、集約キーである`発注番号`と`商品番号`で`GROUP BY`する必要があります。
*   **j**: 問題の全体像から、次に返品情報を結合するための`LEFT OUTER JOIN`句が続くと考えられます。ただし、このSQLの断片だけを見ると、構文的にはここで終了していても問題ありません。

#### ２－２　誤答パターン分析
*   **g**: `SUM(DLI.納品数量)`のような誤答。集計は既にインラインビュー`DLI`の中で行われているため、ここでは集計済みの列`納品数量計`を参照するだけで十分です。
*   **h**: `WHERE 発注番号 = :発注番号`のように、テーブル名を省略する誤答。`OD`と`OT`の両方に`発注番号`列があるため、`OD.発注番号`または`OT.発注番号`のように修飾しないと曖昧エラーになる可能性があります。
*   **i**: `GROUP BY`句を書き忘れる、または集約キーが不足する誤答。集約関数を使う際の鉄則違反です。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「発注情報」と「納品情報（集計済み）」を結合し、一覧表示する。納品がない発注も表示する必要がある。
2.  **SQL構造読解**: 全体が大きな`SELECT`文で、`FROM`句と`LEFT OUTER JOIN`句の中に、それぞれインラインビュー（`ORD`と`DLI`）が使われている複雑な構造を理解します。`ORD`が主軸（左側）、`DLI`が結合される側（右側）です。
3.  **キーワード識別**: 「納品がない場合も表示」→`LEFT OUTER JOIN`。「納品がない場合は0」→`COALESCE`。「商品ごとの合計」→`SUM(...) GROUP BY ...`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **インラインビュー (導出表)**: `FROM`句に記述された副問合せ。これにあたかも実テーブルのように別名を付け、`JOIN`や`SELECT`の対象とすることができます。複雑なクエリを部品化するのに役立ちます。
*   **LEFT OUTER JOIN (左外部結合)**: 左側のテーブルの行をすべて保持し、右側のテーブルに結合条件に合う行がなければ、右側の列をNULLとして結合します。
*   **COALESCE関数**: NULLを別の値に変換するために使用します。外部結合の結果、存在しなかった側の列はNULLになるため、集計等で不都合がないよう0などに変換する際によく使われます。
*   **GROUP BY句と集約関数**: `SUM`, `COUNT`などの集約関数を使う際は、非集約列を`GROUP BY`句に指定する必要があります。

#### ３－２　関連概念の整理
*   **SQLの部品化**: この問題のように、まずインラインビューで「発注情報」「納品集計情報」「返品集計情報」といった意味のあるデータ塊を個別に作り、それらを主問い合わせで結合していく、というアプローチは、複雑な集計SQLを構築する際の常套手段です。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: なぜ`INNER JOIN`ではなく`LEFT OUTER JOIN`が使われているのか？
*   **答**: まだ一度も納品されていない発注明細も結果に表示するためです。
*   **解説**: `INNER JOIN`を使用すると、納品実績のある発注明細しか表示されません。

*   **問**: インラインビュー`DLI`で`GROUP BY`が必要な理由は何か？
*   **答**: 一つの発注・商品に対して複数回に分けて納品される可能性があるため、`SUM(DD.納品数量)`で合計を出す必要があります。集約関数を使ったので`GROUP BY`が必須となります。

*   **問**: `COALESCE`関数を使わなかった場合、表示はどうなるか？
*   **答**: 未納品の発注明細について、納品数量の列が`0`ではなく空欄（NULL）で表示されます。

*   **問**: インラインビュー`ORD`と`DLI`で、なぜ両方で`:発注番号`による絞り込みを行っているのか？
*   **答**: パフォーマンスのためです。事前に各インラインビュー内で対象データを絞り込んでおくことで、その後の`JOIN`処理の対象行数が減り、全体の処理が高速になります。

*   **問**: このSQLの全体像を言葉で説明するとどうなるか？
*   **答**: 指定された発注番号について、まず発注明細の一覧を準備し(ORD)、次に商品ごとの納品合計量を集計し(DLI)、この2つを発注明細を基準に外部結合して、発注数量と納品済数量を並べて表示するSQLです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| ～がない場合も対象に含める | `LEFT OUTER JOIN` |
| 外部結合でNULLになる値を0に | `COALESCE(列名, 0)` |
| ～ごとの合計/平均/件数 | `SUM/AVG/COUNT` + `GROUP BY` |
| 複雑なクエリの組み立て | インラインビューで部品化 |

### ５　要約
*   複雑な集計クエリは、インラインビューを使って「部品」を作り、それらを`JOIN`で組み合わせることで見通しよく構築できます。
*   `LEFT OUTER JOIN`は「主データは全て表示し、関連データがあれば表示する」という要件で必須のテクニックです。
*   外部結合の結果生じる`NULL`は、`COALESCE`で適切に処理することで、表示や後続の計算での不都合を防ぎます。

---

これで10回分が完了しました。あと10回、続けます。

---
## 平成29年秋期 午後 データベース

### １　問題提示
```sql
［平成29年］［秋期
SELECT 品目コード, 品目名, 産地コード, 産地名,
       【 f 】 AS 合計返品金額, SUM(t1.パレット数) AS 合計返品数量
FROM 返品 t1
INNER JOIN 販売明細 t2 USING (販売番号, 販売明細番号)
【 g 】
INNER JOIN 品目 USING (品目コード)
INNER JOIN 産地 USING (産地コード)
WHERE 返品日 = CURRENT_DATE
【 h 】
GROUP BY 品目コード, 産地コード
ORDER BY 品目コード ASC, 産地コード ASC
```

### ２　解答と解説

#### ２－１　正答
*   **f**: `SUM(t1.パレット数 * t2.単価)`
*   **g**: `INNER JOIN 商品 t3 USING (商品コード)`
*   **h**: (空欄、または不要)
    ※この位置には`GROUP BY`の前に来る`HAVING`句や別の`WHERE`条件が考えられるが、問題文の要件からは特に不要。

**解答根拠となる技術的要件**
*   **f**: 「合計返品金額」を計算する式です。金額は「数量 × 単価」で計算できます。ここでは数量が`返品`テーブル(t1)の`パレット数`、単価が`販売明細`テーブル(t2)の`単価`に該当します。これを品目・産地ごとに合計するため、`SUM()`関数で囲みます。
*   **g**: テーブルの結合関係を追跡します。`販売明細`(t2)から`品目`テーブルに結合するには、間に`商品`テーブルを挟む必要があります。（販売明細 → 商品 → 品目という関連）。したがって、`販売明細`と`商品`を`商品コード`で結合する`INNER JOIN`が必要です。`USING`句は結合キーの列名が両テーブルで同じ場合に`ON t2.列 = t3.列`の代わりに使える簡潔な記法です。
*   **h**: このSQLは当日返品されたものを品目・産地ごとに集計するだけで、集計結果に対する絞り込み条件（`HAVING`句）は問題文からは読み取れません。したがって、この箇所は空欄が適切です。

#### ２－２　誤答パターン分析
*   **f**: `SUM(t2.金額)`のような誤答。`販売明細`テーブルに便利な`金額`列があれば別ですが、通常は単価と数量から計算する必要があります。また、`SUM`を忘れると集計されません。
*   **g**: 必要な中間テーブル（商品）を飛ばして`INNER JOIN 品目 ...`を直接書こうとする誤答。ER図やテーブル定義を見て、テーブル間の正しい関連をたどる必要があります。
*   **h**: `HAVING`や不要な`WHERE`条件を追加する誤答。問題文にない要件を勝手に付け加えないように注意が必要です。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「当日返品された商品」「品目ごと・産地ごと」「合計返品金額」「合計返品数量」を抽出します。
2.  **SQL構造読解**: 複数のテーブルを`INNER JOIN`で結合し、`WHERE`で日付を絞り込み、`GROUP BY`で集計する、という典型的な集計SQLの構造を理解します。`USING`句が使われている点に注意します。
3.  **キーワード識別**: 「合計～」→`SUM()`。「金額」→`数量 * 単価`。「～ごと」→`GROUP BY`。「テーブル間の関連」→ER図や定義を元に`JOIN`の連鎖を構築。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **複数テーブルの結合**: 必要な情報を得るために、複数のテーブルを次々と`INNER JOIN`でつなぎ合わせていく技術。テーブル間の関連（リレーション）を正確に把握することが重要です。
*   **USING句**: `JOIN`の結合条件を記述する際に、結合キーとなる列名が両方のテーブルで同じ場合に使える簡略記法です。`... ON t1.key = t2.key`を`... USING (key)`と書くことができます。複合キーの場合は`USING (key1, key2)`のように記述します。
*   **式を含む集約関数**: `SUM(列)`だけでなく、`SUM(列1 * 列2)`のように、集約関数の中に計算式を含めることができます。

#### ３－２　関連概念の整理
*   **`ON`句 vs `USING`句**:
    *   **ON句**: 汎用性が高く、結合キーの列名が異なっていても`ON t1.col_a = t2.col_b`のように指定できます。また、`>`や`BETWEEN`など、等価結合以外の条件も記述できます。
    *   **USING句**: 結合キーの列名が同じ場合に限定されますが、記述が簡潔になります。また、`USING(key)`で結合した場合、`SELECT`句で`key`を参照した際にどちらのテーブルのキーかを修飾する必要がなくなります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: このSQLで`INNER JOIN`が使われている理由は？
*   **答**: 返品、販売明細、商品、品目、産地のすべての情報が揃っているデータのみを集計対象とするためです。

*   **問**: なぜ`GROUP BY`句に`品目名`や`産地名`を含めず、`品目コード`と`産地コード`だけを指定しているのか？
*   **答**: `品目コード`が主キーであれば`品目名`は`品目コード`に従属（関数従属性）するため、`GROUP BY`に含めなくても`SELECT`句に記述できます（DBMSのバージョンや設定によるが、標準SQLでは推奨されない）。コードでGROUP BYするのが一般的です。

*   **問**: `USING`句を使わずに【g】を`ON`句で書き換えるとどうなるか？
*   **答**: `INNER JOIN 商品 t3 ON t2.商品コード = t3.商品コード`となります。

*   **問**: 【f】の計算で、もし返品時に値引きがあった場合、どのように考慮すべきか？
*   **答**: `販売明細`テーブルに`値引額`のような列があれば、`SUM((t1.パレット数 * t2.単価) - t2.値引額)`のように、計算式を修正する必要があります。

*   **問**: `WHERE`句が`GROUP BY`句の後に来るとどうなるか？
*   **答**: 構文エラーになります。SQLの評価順序は`FROM`→`WHERE`→`GROUP BY`→`HAVING`→`SELECT`→`ORDER BY`であり、この順序に従う必要があります。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「合計金額」 | `SUM(数量 * 単価)` |
| 複数のテーブルにまたがる情報 | 複数回の`INNER JOIN` |
| 結合キーの列名が同じ | `USING (キー列名)` |
| 「～ごとに集計」 | `GROUP BY` |

### ５　要約
*   集計SQLでは、どのテーブルにどの情報（数量、単価、属性など）があるかを正確に把握し、`JOIN`で適切に結合する必要があります。
*   合計金額のような派生データは、`SUM`関数の中で四則演算を用いて動的に計算できます。
*   `USING`句は`ON`句の糖衣構文（シンタックスシュガー）ですが、コードを簡潔にする効果があり、読解できるようにしておく必要があります。

---

*(続きます)*
はい、承知いたしました。試験合格に向けて、引き続き全力で分析を進めます。

***

## 平成29年春期 午後 データベース

### １　問題提示
```sql
［平成29年］［春期
-- 図3 稟議申請を検索するSQL文
SELECT 申請書.申請書ID, 申請書.タイトル, 申請書.申請日, ユーザ.ユーザ名, 部署マスタ.部署名
FROM 申請書 INNER JOIN 承認申請 ON 申請書.申請書ID = 承認申請.申請書ID
INNER JOIN ユーザ ON 申請書.申請者ID = ユーザ.ユーザID
INNER JOIN 部署マスタ ON ユーザ.部署ID = 部署マスタ.部署ID
WHERE (承認申請.承認申請状態 NOT IN ('可決','否決')) AND
((申請書.申請者ID = :ユーザID) OR
 (申請書.申請書ID IN (SELECT DISTINCT 申請書ID FROM 承認者情報 INNER JOIN 承認申請
    ON 【 c 】 WHERE 【 d 】)))

-- 図4 金額と支払日の一覧を検索するSQL文
SELECT 申請書.申請書ID, 申請書.タイトル,
       【 e 】 AS 金額, 【 f 】 AS 支払日
FROM 申請書 INNER JOIN 申請書項目 t1 ON 【 g 】
INNER JOIN 申請書項目 t2 ON 【 h 】, 承認申請
WHERE
((申請書.書式ID = '購買' AND t1.項目キー = 'amount' AND t2.項目キー = 'pay_date') OR
 (申請書.書式ID = '契約' AND t1.項目キー = 'pay_initial' AND t2.項目キー = 'start_date'))
AND (承認申請.申請書ID = 申請書.申請書ID AND 承認申請.承認申請状態 = '可決')
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `承認者情報.承認者情報ID = 承認申請.承認者情報ID`
*   **d**: `承認者情報.承認者ID = :ユーザID`
*   **e**: `CAST(t1.項目値 AS INTEGER)`
*   **f**: `CAST(t2.項目値 AS DATE)`
*   **g**: `申請書.申請書ID = t1.申請書ID`
*   **h**: `申請書.申請書ID = t2.申請書ID`

**解答根-拠となる技術的要件**
*   **c, d**: 副問合せは「ログイン中の利用者(`:ユーザID`)が承認者となっている申請書IDのリスト」を生成する部分です。`承認者情報`テーブルで承認者ID(`承認者ID`)がログインユーザと一致するレコードを検索し(`【d】`)、その`承認者情報ID`を使って`承認申請`テーブルと結合(`【c】`)し、該当する`申請書ID`を抜き出します。
*   **e, f**: `申請書項目`テーブルは、`項目値`がVARCHAR型などで汎用的にデータを保持している（EAVモデルに近い）と推測されます。`金額`として扱うには数値型に、`支払日`として扱うには日付型に、`CAST`関数を使って明示的にデータ型を変換する必要があります。
*   **g, h**: `申請書`テーブルと`申請書項目`テーブルを結合するための条件です。`申請書項目`テーブルは`amount`用(`t1`)と`pay_date`用(`t2`)で2回自己結合的に使われており、どちらも元の`申請書`テーブルと`申請書ID`で結合する必要があります。

#### ２－２　誤答パターン分析
*   **c, d**: 結合キーや条件指定の対象を間違える誤答。どのテーブルにどのID情報があるかを正確に追う必要があります。
*   **e, f**: `CAST`を使わずに`t1.項目値`とそのまま記述する誤答。文字列のままでは数値計算や日付としてのソートが正しく行えないため、型変換が不可欠です。
*   **g, h**: `t1.申請書ID = t2.申請書ID`のように、`申請書項目`テーブル同士を結合しようとする誤答。`t1`と`t2`は、どちらも親である`申請書`テーブルに紐づける必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図3: 「未決裁」かつ「自分が申請者」または「自分が承認者」の稟議を検索。
    *   図4: 「可決済み」の「購買」または「契約」稟議について、「金額」と「支払日」を抽出。データは汎用的な項目テーブルから取得。
2.  **SQL構造読解**:
    *   図3: `WHERE`句の複雑なOR条件と`IN (副問合せ)`の組み合わせを理解する。
    *   図4: 1つのテーブル(`申請書項目`)を異なる目的（金額用、支払日用）で2回`JOIN`するテクニック（自己結合）と、`CAST`による型変換がポイント。
3.  **キーワード識別**: 「自分が承認者」→`承認者情報`テーブルの検索。「汎用的な項目」→EAVモデルを連想し、`CAST`による型変換の必要性を検討。「金額」「日付」→適切なデータ型への`CAST`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **IN (副問合せ)**: 副問合せが返す値のリストのいずれかに一致する行を検索します。
*   **自己結合 (Self Join)**: 1つのテーブルに対して複数の役割（エイリアス）を与え、自分自身と結合する手法。図4のように、1行に複数の属性を持つべきデータを行を分けて格納しているテーブル（縦持ちデータ）から、欲しい属性を列として取り出す（横持ちに変換する）際によく使われます。
*   **CAST関数**: あるデータ型の値を別のデータ型に変換します。`CAST(値 AS 変換後のデータ型)`という構文です。
*   **EAV (Entity-Attribute-Value) モデル**: エンティティ（例：申請書）、属性（例：金額）、値（例：10000）を別々の行で管理するデータモデル。柔軟性が高い反面、データの取得や型管理が複雑になりがちで、図4のようなSQLが必要になります。

#### ３－２　関連概念の整理
*   **縦持ちデータを横持ちデータに変換**:
    *   **縦持ち**: 1つのエンティティの複数の属性が、別々の行として格納されている状態。（例: 図4の`申請書項目`テーブル）
    *   **横持ち**: 1つのエンティティの複数の属性が、1行の中の別々の列として格納されている状態。（通常のテーブル設計）
    縦持ちから横持ちへの変換は、自己結合や`CASE`式を使ったピボット集計で実現できます。図4は自己結合を用いた典型的なパターンです。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図3の`WHERE`句の`承認申請.承認申請状態 NOT IN ('可決','否決')`は何を意味するか？
*   **答**: 承認プロセスがまだ完了していない（承認待ち、差戻しなどの）稟議のみを対象とすることを意味します。

*   **問**: 図4で`申請書項目`テーブルを2回`JOIN`する理由は何か？
*   **答**: 1回の`JOIN`では`項目キー`が`'amount'`である行か`'pay_date'`である行のどちらか一方しか取得できないため、両方の`項目値`を1つのレコードの別々の列（`金額`列と`支払日`列）として取得するために2回`JOIN`しています。

*   **問**: `CAST`関数による型変換がなぜ重要なのか？
*   **答**: 元のデータが文字列型の場合、`'10000'`と`'2000'`を文字列として比較すると`'2000'`の方が大きいと判定されるなど、意図しないソート順や比較結果になるためです。数値は数値型、日付は日付型として扱うことで、正しい計算や比較が可能になります。

*   **問**: 図4の`FROM`句にある`, 承認申請`という記述は何を意味するか？
*   **答**: これは`CROSS JOIN`を意味する古い構文です。`WHERE`句の`承認申請.申請書ID = 申請書.申請書ID`という条件と組み合わせることで、実質的に`INNER JOIN`として機能します。

*   **問**: 図3の副問合せで`DISTINCT`が使われている理由は？
*   **答**: 一つの申請書に同じ人が複数の立場で承認者として関わる可能性があるため、`申請書ID`が重複してリストに含まれるのを防ぎ、`IN`句の効率を上げるためです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 「自分が～であるリスト」 | `IN (SELECT ID FROM ... WHERE 担当者ID = :自分ID)` |
| 縦持ちデータを横持ちに変換 | 自己結合 / CASE式とGROUP BY |
| 文字列を数値や日付として扱う | `CAST(列 AS INTEGER)` / `CAST(列 AS DATE)` |
| 汎用的な項目テーブル | EAVモデルを想定し、型変換や自己結合を疑う |

### ５　要約
*   縦持ち（EAVモデル）のテーブルから複数の属性を列として取り出すには、自己結合が有効なテクニックです。
*   汎用的なデータ型で格納された値を使用する際は、`CAST`関数で適切なデータ型に明示的に変換することが不可欠です。
*   `WHERE`句の条件は複雑に組み合わせることができます。`AND`, `OR`, `IN (副問合せ)`などを正しく組み合わせ、要件通りの絞り込みロジックを構築する能力が求められます。

---

## 平成28年秋期 午後 データベース

### １　問題提示
```sql
［平成28年］［秋期
-- 図2 過去の購入済み商品分類一覧を表示するSQL文
SELECT t1.会員番号, t1.氏名, t6.商品分類番号, t6.商品分類名,
       【 c 】 AS 購入金額合計
FROM 会員 t1
INNER JOIN (SELECT t2.購入番号, t2.会員番号 FROM 購入 t2 WHERE 【 d 】 > (:一年前)) t3 ON t1.会員番号 = t3.会員番号
INNER JOIN 購入明細 t4 ON t3.購入番号 = t4.購入番号
INNER JOIN 商品 t5 ON t4.商品番号 = t5.商品番号
INNER JOIN 商品分類 t6 ON t5.商品分類番号 = t6.商品分類番号
GROUP BY t1.会員番号, t1.氏名, t6.商品分類番号, t6.商品分類名

-- 図3 カーソルを使用した会員種別判定バッチ処理を行うプログラム(一部)
DECLARE cur CURSOR FOR
    SELECT t2.会員番号, t2.購入番号, t2.購入金額
    FROM 購入 t2
    WHERE 【 e 】
    AND t2.購入日時 <= :判定対象期限
    AND t2.判定処理状態 <> '判定処理済み'
    【 f 】;
...
        IF 【 g 】 THEN
            UPDATE 会員 t1 【 h 】 WHERE t1.会員番号 = kaiin_no;
            SET update_flag = 1;
        END IF;
...
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `SUM(t4.購入単価 * t4.購入数量)`
*   **d**: `t2.購入日時`
*   **e**: `t2.会員種別判定対象 = '対象'`
*   **f**: `ORDER BY t2.会員番号, t2.購入日時`
*   **g**: `goukei >= 100000`
*   **h**: `SET t1.会員種別 = '特別会員'`

**解答根拠となる技術的要件**
*   **c**: 「購入金額合計」を計算する部分です。`購入明細`テーブル(t4)の`購入単価`と`購入数量`を掛け合わせたものが個々の明細の金額であり、それを`SUM`関数で合計します。
*   **d**: `購入`テーブル(t3)を「過去1年間」のデータに絞り込むための条件です。`購入日時`がバインド変数`:一年前`より大きいことを判定します。
*   **e**: プログラムのロジックから、会員種別判定の対象となる購入データのみを抽出する必要があります。`購入`テーブルの`会員種別判定対象`列が`'対象'`であるレコードを絞り込みます。
*   **f**: このプログラムは会員ごとに購入金額を累積していくため、カーソルからフェッチされるデータが`会員番号`順に並んでいる必要があります。同じ会員内では`購入日時`順に処理するのが自然です。`ORDER BY`句でソート順を指定します。
*   **g**: プログラム内のロジックで、累積購入金額(`goukei`)が特別会員の基準額（問題文より10万円）以上になったかどうかを判定する条件式です。
*   **h**: 上記【g】の条件を満たした場合に、`会員`テーブル(t1)の`会員種別`を`'特別会員'`に更新する`UPDATE`文の`SET`句です。

#### ２－２　誤答パターン分析
*   **c**: `SUM(購入金額)`のような誤答。`購入`テーブルにある`購入金額`はヘッダ全体の合計であり、商品分類ごとの集計には使えません。明細レベルの単価と数量から計算する必要があります。
*   **f**: `ORDER BY`を忘れる誤答。カーソル処理で「ブレーク処理（キーが変わったら処理を切り替える）」を行う場合、対象データのソートは絶対条件です。
*   **g, h**: 問題文中の「年間購入金額が10万円以上の会員を特別会員とする」という仕様を読み取れないことによる誤答。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「過去1年」「会員ごと・商品分類ごと」「購入金額合計」。
    *   図3: 「判定対象の購入データ」「会員番号順、購入日時順にソート」「累積金額が10万円以上になったら」「特別会員に更新」。
2.  **SQL構造読解/プログラム読解**:
    *   図2: 多数のテーブルを`JOIN`して`GROUP BY`で集計する典型的なSQL。インラインビュー`t3`が使われている点にも注意。
    *   図3: カーソルとループを使った手続き型のプログラムを読み解く。`fetch_loop`内の`IF kaiin_no <> current_kaiin_no THEN ...`という部分が、会員番号が変わったときのブレーク処理であることを理解する。
3.  **キーワード識別**: 「合計」→`SUM`。「過去1年」→`WHERE 日付 > :一年前`。「～順に処理」→`ORDER BY`。「もし～ならば」→`IF`。「更新」→`UPDATE SET`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **複数テーブルの結合**: 5つ以上のテーブルを`INNER JOIN`で連結し、正規化されたテーブルから必要な情報を集める。
*   **GROUP BY句**: 指定したキーでデータをグループ化し、集約関数を適用する。
*   **ストアドプロシージャ/カーソル**:
    *   **カーソル (CURSOR)**: `SELECT`文の結果セットをメモリ上に保持し、1行ずつ取り出して処理するための仕組み。バッチ処理などで多用されます。
    *   **DECLARE**: カーソルや変数を宣言します。
    *   **OPEN**: カーソルを開き、`SELECT`文を実行します。
    *   **FETCH**: カーソルから次の1行を読み込み、変数に格納します。
    *   **CLOSE**: カーソルを閉じ、リソースを解放します。
*   **ブレーク処理 (制御ブレーク)**: ソート済みのデータを順次処理していき、キーとなる項目の値が変化したタイミングで、それまでのグループの集計処理や出力処理を行うプログラミング技法。

#### ３－２　関連概念の整理
*   **SQL (集合指向言語) vs 手続き型言語**:
    *   **SQL**: どのようなデータが「欲しいか」を宣言する非手続き型の言語。データ集合全体に対して一度に操作を行います（図2のSQL）。
    *   **手続き型**: どのように処理を「行うか」を記述する言語。ループや条件分岐を使い、データを1件ずつ順次処理します（図3のプログラム）。カーソルは、集合指向のSQLの世界と手続き型の世界とを橋渡しする役割を持ちます。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2でインラインビュー`t3`を使っている理由は何か？
*   **答**: パフォーマンス向上のためです。先に`購入`テーブルを過去1年分に絞り込んでから他のテーブルと結合することで、`JOIN`の対象となる行数を減らし、処理を効率化できます。

*   **問**: 図3のプログラムで、変数`update_flag`はどのような役割を果たしているか？
*   **答**: 同じ会員について、一度「特別会員」に更新したら、それ以降のその会員の購入データについては`UPDATE`処理をスキップするためのフラグです。

*   **問**: 図3のプログラムで`ORDER BY`が必須なのはなぜか？
*   **答**: 会員番号が変わったことを検知する「ブレーク処理」が正しく機能し、会員ごとに購入金額を正しく累積するためには、データが会員番号順にソートされていることが大前提だからです。

*   **問**: 図3の`UPDATE 購入 t2 SET t2.判定処理状態 = '繰越し' ...`は何のために行われているか？
*   **答**: 一度特別会員と判定された後に出てきた、同じ会員の（今回のバッチでは累積計算に使われなかった）購入データに対して、「次回の判定に繰り越す」という意味の印を付けていると考えられます。

*   **問**: このようなバッチ処理は、SQL一発で（カーソルを使わずに）実現できないか？
*   **答**: ウィンドウ関数を使えば実現可能です。
*   **解説**: `SUM(購入金額) OVER (PARTITION BY 会員番号 ORDER BY 購入日時)`で会員ごとの累積購入金額を計算し、それが10万円を超えた会員を特定する、といったSQLで一括更新が可能です。カーソル処理よりも高速な場合が多いです。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| ～ごと、～ごとの合計 | `GROUP BY ...`, `SUM(...)` |
| 期間の絞り込み | `WHERE 日付列 BETWEEN ...` or `WHERE 日付列 > ...` |
| 1件ずつ順次処理 | カーソル (`DECLARE`, `OPEN`, `FETCH`, `CLOSE`) |
| ブレーク処理の前提 | `ORDER BY`句による事前ソート |
| 「もし～なら～する」 | `IF ... THEN ...` |

### ５　要約
*   複雑な集計SQLでは、複数のテーブルを適切に`JOIN`し、`GROUP BY`で集計キーを指定する能力が基本となります。
*   カーソルを用いた手続き型のバッチ処理では、`ORDER BY`による事前ソートがブレーク処理を正しく機能させるための鍵です。
*   プログラムのロジックを読み解き、変数の役割や条件分岐の意味を理解して、SQLの穴埋めを行う必要があります。

---

## 平成28年春期 午後 データベース

### １　問題提示
```sql
［平成28年］［春期
-- 図2 売上ファクト表に挿入するデータを抽出するSQL文
SELECT ST.確認年月日, ST.店舗ID, ST.商品ID, COALESCE(SS.日間販売数量, 0),
       ST.日間在庫数量
FROM
(SELECT SC.確認年月日, SC.店舗ID, SC.商品ID,
        AVG(SC.在庫数量) AS 日間在庫数量
 FROM 在庫 SC
 GROUP BY SC.確認年月日, SC.店舗ID, SC.商品ID) ST
【 α 】
(SELECT SL.販売年月日, SL.店舗ID, SD.商品ID,
        SUM(SD.販売数量) AS 日間販売数量
 FROM 販売 SL
 INNER JOIN 販売詳細 SD ON SL.販売ID = SD.販売ID
 GROUP BY SL.販売年月日, SL.店舗ID, SD.商品ID) SS
ON ST.確認年月日 = SS.販売年月日
AND 【 e 】
AND 【 f 】
【 β 】

-- 図3 売れ行きが悪い商品分類の一覧を作成するSQL文
SELECT SF.売上年月, SF.店舗ID, IT.商品分類ID,
       AVG(SF.日間販売数量) AS 平均販売数量, AVG(SF.日間在庫数量) AS 平均在庫数量
FROM
(SELECT TO_YYYYMM(SA.売上年月日) AS 売上年月, SA.店舗ID, SA.商品ID,
        SA.日間販売数量, SA.日間在庫数量
 FROM 売上ファクト SA) SF
INNER JOIN 商品 IT ON SF.商品ID = IT.商品ID
GROUP BY SF.売上年月, SF.店舗ID, IT.商品分類ID
【 g 】
```
*※注: 【α】【β】は設問の記号ではないが、構造理解のため補記*

### ２　解答と解説

#### ２－１　正答
*   **α**: `LEFT JOIN`
*   **e**: `ST.店舗ID = SS.店舗ID`
*   **f**: `ST.商品ID = SS.商品ID`
*   **β**: (空欄、または不要)
*   **g**: `HAVING AVG(SF.日間販売数量) / AVG(SF.日間在庫数量) < 0.1`

**解答根拠となる技術的要件**
*   **α**: 在庫確認は毎日行われるが、販売実績は必ずしもあるとは限りません。「在庫はあったが、その日は売れなかった」というデータもファクト表に含める必要があるため、在庫集計(ST)を主軸として販売集計(SS)を結合する`LEFT JOIN`が適切です。
*   **e, f**: `LEFT JOIN`の結合条件です。`確認年月日`(=`販売年月日`)に加えて、`店舗ID`と`商品ID`が一致するレコード同士を結合する必要があります。
*   **g**: 「売れ行きが悪い」という条件を定義する`HAVING`句です。問題文の仕様に「販売数量の平均が在庫数量の平均の10%未満の商品分類」とあるため、`平均販売数量 / 平均在庫数量 < 0.1`という条件式になります。集約結果に対する条件なので`WHERE`ではなく`HAVING`を使います。

#### ２－２　誤答パターン分析
*   **α**: `INNER JOIN`を選ぶ誤答。これではその日に売れた商品しか抽出できず、「在庫はあるが売れなかった」という重要な情報が欠落してしまいます。
*   **e, f**: 結合キーが不足する誤答。年月日だけで結合すると、店舗や商品が異なるデータが誤って結合されてしまいます。
*   **g**: `WHERE`句に条件式を書く誤答。`AVG`のような集約関数を使った条件は、`GROUP BY`で集約した後に評価される`HAVING`句に記述する必要があります。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「在庫を基準」に「販売実績」を結合。「売れなかった日も対象」。
    *   図3: 「商品分類ごと」に集計し、「販売数量平均が在庫数量平均の10%未満」という条件で絞り込む。
2.  **SQL構造読解**:
    *   図2: 2つのインラインビュー(在庫集計ST、販売集計SS)を外部結合する構造。どちらを主軸（左側）にすべきかを要件から判断する。
    *   図3: インラインビュー(SF)と商品テーブル(IT)を結合し、`GROUP BY`で集計後、`HAVING`で条件を判定する構造。
3.  **キーワード識別**: 「～を基準に」「～がなくても表示」→`LEFT JOIN`。「集計結果が～であるもの」→`HAVING`。「10%未満」→`< 0.1`。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **ファクト表 (Fact Table)**: データウェアハウス(DWH)のスタースキーマにおける中心的なテーブル。売上数量、金額などの数値（メジャー）と、ディメンション表への外部キーを持ちます。
*   **LEFT JOIN (左外部結合)**: 左側のテーブルの行をすべて保持し、右側に一致する行がなければNULLを返します。
*   **インラインビュー (導出表)**: `FROM`句内の副問合せ。複雑なクエリの部品化に役立ちます。
*   **HAVING句**: `GROUP BY`で集約した結果セットに対して条件を指定します。

#### ３－２　関連概念の整理
*   **データウェアハウス (DWH)**: 意思決定支援のために、複数の基幹システムからデータを集約・統合・蓄積するデータベース。分析しやすいようにスタースキーマなどの多次元モデルで設計されることが多いです。
*   **`WHERE`句と`HAVING`句の使い分け**:
    *   **WHERE**: `FROM`句で読み込んだ個々の行を、グループ化する「前」にフィルタリングします。
    *   **HAVING**: `GROUP BY`でグループ化した後の集約結果（各グループ）をフィルタリングします。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2で`INNER JOIN`を使うと、どのようなデータが作成されるか？
*   **答**: その日に在庫があり、かつ、1個以上売れた商品のデータのみが作成されます。

*   **問**: 図2の`COALESCE(SS.日間販売数量, 0)`は何のためにあるか？
*   **答**: `LEFT JOIN`の結果、その日に売れなかった商品の`SS.日間販売数量`はNULLになるため、それを0に変換してファクト表に挿入するためです。

*   **問**: 図3のインラインビュー`SF`は何をしているか？
*   **答**: `売上ファクト`テーブルの`売上年月日`から`TO_YYYYMM`関数で「売上年月」を算出し、後続の処理で使いやすいように列として追加しています。

*   **問**: 図3の`HAVING`句の条件式で、`AVG(SF.日間在庫数量)`が0になる可能性はないか？その場合、どのような問題が起こるか？
*   **答**: 0になる可能性はあります。その場合、0による除算エラーが発生する可能性があります。
*   **解説**: 実用的なSQLでは、`CASE WHEN AVG(SF.日間在庫数量) > 0 THEN AVG(SF.日間販売数量) / AVG(SF.日間在庫数量) ELSE 0 END < 0.1` のように、分母が0の場合の処理を記述する必要があります。

*   **問**: なぜデータウェアハウスでは、図2のような処理で事前にファクト表を作成しておくのか？
*   **答**: 分析クエリ（図3のようなクエリ）を実行するたびに都度`JOIN`や集計を行うと時間がかかるため、あらかじめ集計・結合済みのファクト表を用意しておくことで、分析クエリを高速に実行できるようにするためです（ETL/ELT処理）。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード/状況 | 対応するSQL構文/要素 |
| :--- | :--- |
| 「Aを基準にBを付ける（Bは無くても可）」 | `FROM A LEFT JOIN B ON ...` |
| 集約結果に対する条件 | `HAVING`句 |
| 0除算エラーの回避 | `CASE`文や`NULLIF`関数 |
| DWHのデータ抽出・変換 | インラインビューや`WITH`句で部品化 |

### ５　要約
*   データ分析の前段となるデータマートやファクト表の作成では、「どのデータを主軸にするか」を考え、`LEFT JOIN`を適切に使うことが重要です。
*   集約結果に対して条件を指定する場合は`HAVING`句を使用し、`WHERE`句との役割の違いを明確に理解する必要があります。
*   実用的なSQLでは、0除算などの実行時エラーを回避するための防御的なコーディング（`CASE`文など）が求められます。

---sql
## 平成27年秋期 午後 データベース

### １　問題提示
```
［平成27年］［秋期
-- 図2 指定した部署とその配下の全ての部署を出力するSQL文
WITH RECURSIVE 関連部署(部署ID, 部署名, 上位部署ID) AS (
    SELECT 部署ID, 部署名, 上位部署ID
    FROM 部署 WHERE 部署ID = :部署ID
    UNION ALL
    SELECT 部署.部署ID, 部署.部署名, 部署.上位部署ID
    FROM 部署, 関連部署 WHERE 部署.上位部署ID = 関連部署.部署ID
)
SELECT 部署ID, 部署名, 上位部署ID FROM 関連部署

-- 図5 指定した日の会社全体の部署構造を出力するSQL文
WITH RECURSIVE 関連部署(部署ID, 部署名, 上位部署ID) AS (
    SELECT 部署ID, 部署名, 上位部署ID
    FROM 部署 WHERE 部署ID = 【 d 】
    AND :年月日 BETWEEN 部署.適用開始年月日 AND 部署.適用終了年月日
    UNION ALL
    SELECT 部署.部署ID, 部署.部署名, 部署.上位部署ID
    FROM 部署, 関連部署 WHERE 部署.上位部署ID = 関連部署.部署ID
    AND :年月日 BETWEEN 部署.適用開始年月日 AND 部署.適用終了年月日
)
SELECT 部署ID, 部署名, 上位部署ID FROM 関連部署
```
*※注: 図2は穴埋め問題ではないが、図5を解く上での重要な参考情報*

### ２　解答と解説

#### ２－１　正答
*   **d**: `'D000'` (または最上位部署のIDを示すリテラル/変数)
    ※問題文に「会社全体の部署構造は，部署IDが'D000'である部署を最上位として構成される」と明記されているため。

**解答根拠となる技術的要件**
*   **d**: このSQLは「会社全体の部署構造」を出力するものです。再帰CTEの起点（アンカーメンバー）は、階層構造の最上位（ルート）となる部署を指定する必要があります。問題文の記述から、最上位部署のIDは`'D000'`であることがわかります。したがって、アンカーメンバーの`WHERE`句で`部署ID = 'D000'`と指定することで、`D000`から始まる全組織階層を再帰的に展開できます。

#### ２－２　誤答パターン分析
*   `:部署ID`と書いてしまう誤答。これは図2のように特定の部署配下を抽出する場合の書き方です。「会社全体」という要件を見落としています。
*   `上位部署ID IS NULL`と書く誤答。これもルート部署を特定する一般的な方法ですが、問題文でルート部署のIDが明記されている場合は、それに従うのが最も確実です。
*   `'D000'`を囲むシングルクォーテーションを忘れる誤答。`D000`は文字列リテラルなので、クォーテーションが必要です。

#### ２－３　解答アプローチ
1.  **要件抽出**: 「会社全体の部署構造」「指定した日(`:年月日`)時点で有効な」という2つの要件を抽出します。
2.  **SQL構造読解**: 図2と同じ`WITH RECURSIVE`構文であることから、階層問い合わせであると判断します。図5では、さらに`:年月日 BETWEEN ...`という期間を絞り込む条件がアンカーメンバーと再帰メンバーの両方に追加されていることを確認します。
3.  **キーワード識別**: 「会社全体」→階層のルート（最上位）から検索を開始する必要がある、と判断。問題文でルートの定義を探し、「部署IDが'D000'」という記述を見つけ出します。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **再帰共通表式 (Recursive CTE)**: `WITH RECURSIVE`句を用いて、階層構造を持つデータを問い合わせる機能。
    *   **アンカーメンバー**: 再帰の開始点となる最初の`SELECT`文。
    *   **再帰メンバー**: アンカーメンバーまたは前回の再帰メンバーの結果を参照して、次の階層のデータを取得する`SELECT`文。
    *   両者は`UNION ALL`または`UNION`で結合されます。
*   **履歴管理テーブル**: `適用開始年月日`と`適用終了年月日`のような列を持ち、データの有効期間を管理するテーブル設計。ある時点での状態を正確に再現（As-Of クエリ）する際に使われます。

#### ３－２　関連概念の整理
*   **再帰CTEにおける条件指定**: 図5のように、ある時点での有効な階層のみを抽出したい場合、アンカーメンバーと再帰メンバーの両方の`WHERE`句で期間の絞り込みを行う必要があります。もし再帰メンバー側で絞り込みを忘れると、過去に存在した（現在は無効な）親子関係までたどってしまう可能性があります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2と図5のSQLの主な違いは何か？
*   **答**: 図2は任意の部署を起点とする階層を出力するのに対し、図5は会社全体（ルート部署を起点）の、かつ、指定した時点で有効な階層のみを出力する点です。

*   **問**: `WITH RECURSIVE`の`RECURSIVE`キーワードは、すべてのDBMSで必須か？
*   **答**: いいえ。SQL Serverなど一部のDBMSでは`RECURSIVE`キーワードは不要で、`WITH`だけで再帰CTEを記述できます。標準SQLやPostgreSQL、MySQLなどでは必須です。

*   **問**: 図5で`:年月日 BETWEEN ...`の条件を、アンカーメンバーだけに記述した場合、どのような誤った結果になる可能性があるか？
*   **答**: 起点となるルート部署は正しく選択されますが、その配下の部署をたどる際に、指定日時点では無効になっている部署（例：過去に統廃合された部署）も結果に含まれてしまう可能性があります。

*   **問**: 再帰CTEの処理は、どのような条件で停止するのか？
*   **答**: 再帰メンバーの`SELECT`文が1行も結果を返さなくなった時点（階層の末端に到達した時点）で、再帰処理は自動的に停止します。

*   **問**: このような組織階層データを扱う別の方法として、何が考えられるか？
*   **答**: 経路列挙モデル（各ノードにルートからのパスを文字列で保持）や入れ子集合モデルなど、再帰クエリを使わない設計方法もありますが、隣接リストモデル（この問題のように親IDを持つ形式）と再帰CTEの組み合わせが最も直感的で一般的です。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「階層」「配下」「組織図」 | `WITH RECURSIVE` |
| 「会社全体」 | 階層のルート（最上位ノード）をアンカーメンバーの条件にする |
| 「ある時点での状態」 | `WHERE :年月日 BETWEEN 開始日 AND 終了日` |
| 再帰クエリの結合 | `UNION ALL` |

### ５　要約
*   組織図のような階層構造データは、`WITH RECURSIVE`（再帰CTE）で効率的に問い合わせるのが定石です。
*   「全体」を取得する場合は階層のルートを、「特定の配下」を取得する場合はその親を、アンカーメンバーの起点に設定します。
*   履歴管理されたデータからある時点の階層を抽出する場合、アンカーと再帰の両メンバーで期間による絞り込みが必要です。

---

## 平成27年春期 午後 データベース

### １　問題提示
```sql
［平成27年］［春期
-- 図2 非営業日利用一覧表示機能で用いるSQL文
SELECT AC.*
FROM アクセスログ AC
WHERE 【 c 】
(SELECT * FROM 非営業日 NS
 WHERE 【 d 】)

-- 図3 部外者失敗一覧表示機能で用いるSQL文
SELECT AC.*
FROM アクセスログ AC
INNER JOIN 利用者 US ON AC.利用者ID = US.利用者ID
INNER JOIN サーバ SV ON AC.サーバID = SV.サーバID
WHERE 【 e 】
AND 【 f 】
```

### ２　解答と解説

#### ２－１　正答
*   **c**: `EXISTS`
*   **d**: `CAST(AC.アクセス日時 AS DATE) = NS.非営業日`
*   **e**: `US.部外者フラグ = '1'`
*   **f**: `AC.処理結果 = '失敗'`

**解答根拠となる技術的要件**
*   **c**: 「非営業日の利用」を抽出するため、アクセスログの日付が、非営業日テーブルに「存在する」かどうかをチェックします。`EXISTS`は副問合せの結果が1件でも存在する場合に真となるため、この条件判定に最適です。
*   **d**: `EXISTS`内の相関条件です。外側の`アクセスログ`(AC)の`アクセス日時`（日時型）と、内側の`非営業日`(NS)の`非営業日`（日付型）を比較します。データ型を合わせるため、`アクセス日時`から日付部分のみを`CAST`関数で抽出して比較するのが確実です。
*   **e**: 「部外者」によるアクセスを抽出するための条件です。結合した`利用者`テーブル(US)の`部外者フラグ`が'1'（部外者を示す値）であるレコードを絞り込みます。
*   **f**: 「失敗した」アクセスを抽出するための条件です。`アクセスログ`テーブル(AC)の`処理結果`が`'失敗'`であるレコードを絞り込みます。

#### ２－２　誤答パターン分析
*   **c**: `IN`を選ぶ誤答。`WHERE CAST(AC.アクセス日時 AS DATE) IN (SELECT NS.非営業日 FROM 非営業日 NS)`でも同じ結果は得られますが、一般的に`EXISTS`の方がパフォーマンスが良いとされています。
*   **d**: `AC.アクセス日時 = NS.非営業日`と`CAST`を忘れる誤答。`DATETIME`型と`DATE`型を直接比較すると、DBMSによっては暗黙の型変換がうまくいかず、意図しない結果になる可能性があります。明示的な`CAST`が安全です。
*   **e, f**: 問題文の要件「部外者」「失敗」と、テーブル定義のどの列・どの値が対応するのかを正しく読み取れないことによる誤答。

#### ２－３　解答アプローチ
1.  **要件抽出**:
    *   図2: 「非営業日」の「アクセスログ」を抽出。
    *   図3: 「部外者」による「失敗」した「アクセスログ」を抽出。
2.  **SQL構造読解**:
    *   図2: `WHERE (副問合せ)`の形で、相関副問合せを使って存在チェックを行うSQLだと判断。
    *   図3: 3つのテーブルを`INNER JOIN`し、`WHERE`句の`AND`条件で絞り込む基本的な`SELECT`文。
3.  **キーワード識別**: 「～に存在する」→`EXISTS`。「部外者」「失敗」→テーブル定義を参照し、該当するフラグや状態値を持つ列を特定し、`WHERE`句の条件にする。

### ３　技術知識体系

#### ３－１　必要知識項目
*   **EXISTS演算子と相関副問合せ**: ある条件を満たすデータが関連テーブルに存在するかどうかをチェックする際の強力な組み合わせです。
*   **CAST関数**: データ型を明示的に変換します。日時(TIMESTAMP/DATETIME)から日付(DATE)を抽出する際などによく使われます。
*   **INNER JOIN**: 複数のテーブルを内部結合し、関連する情報を1つの結果セットにまとめます。
*   **フラグ**: '1'/'0'や'Y'/'N'などの値で、真偽や特定の状態を表すために使われる列。`WHERE`句で条件としてよく利用されます。

#### ３－２　関連概念の整理
*   **`EXISTS` vs `IN`のパフォーマンス**:
    *   一般的に、副問合せの結果セットが大きい場合、`EXISTS`の方が高速に動作する傾向があります。`EXISTS`は条件に合う行を1件見つけた時点で評価を打ち切る（ショートサーキット）のに対し、`IN`は副問合せの全結果を一旦生成してから比較するためです。
    *   逆に、副問合せの結果が非常に小さい場合は`IN`の方が速いこともあります。

### ４　実践演習

#### ４－１　一問一答（５問構成）
*   **問**: 図2で`NOT EXISTS`を使うと、どのようなログが抽出されるか？
*   **答**: 営業日のアクセスログが抽出されます。

*   **問**: `CAST(AC.アクセス日時 AS DATE)`の代わりに、`DATE(AC.アクセス日時)`のような日付抽出関数を使うことは可能か？
*   **答**: 可能です。
*   **解説**: DBMSによって関数の名前は異なりますが（例: `TRUNC()` in Oracle, `DATE()` in MySQL/PostgreSQL, `CONVERT(date, ...)` in SQL Server）、日時型から日付部分だけを取り出す機能は多くのDBMSで提供されています。

*   **問**: 図3で`INNER JOIN`ではなく`LEFT JOIN 利用者 US ON ...`とした場合、どのような結果になりうるか？
*   **答**: もし`アクセスログ`に存在する`利用者ID`が`利用者`マスタに存在しない（データ不整合）場合でも、そのアクセスログが結果に含まれるようになります（`US.部外者フラグ`はNULLになります）。

*   **問**: 図3の`WHERE`句の2つの条件【e】と【f】の順番を入れ替えても、結果は変わるか？
*   **答**: 変わりません。
*   **解説**: `WHERE`句の`AND`で結ばれた条件の評価順序は、通常、DBMSのオプティマイザが最も効率的と判断した順序で行われるため、記述順は結果に影響しません。

*   **問**: なぜ監査ログ（アクセスログ）のようなテーブルでは、利用者名やサーバ名を直接持たずに、IDで持つ設計にするのか？
*   **答**: データベースの正規化のためです。利用者名やサーバ名が変更された場合に、マスタテーブルを1箇所更新するだけで済み、ログテーブルの全レコードを更新する必要がなくなります。これによりデータの一貫性が保たれ、ディスク容量も節約できます。

#### ４－２　判断基準チェックリスト
| 問題文のキーワード | 対応するSQL構文/要素 |
| :--- | :--- |
| 「～であるものが存在する」 | `EXISTS` |
| 日時データから日付だけを比較 | `CAST(日時列 AS DATE)` または `DATE(日時列)` |
| 複数の条件をすべて満たす | `WHERE 条件1 AND 条件2 AND ...` |
| マスタ情報を参照する | `INNER JOIN`でマスタテーブルを結合 |

### ５　要約
*   関連テーブルにデータが「存在するかどうか」の判定には、`EXISTS`を用いた相関副問合せが有効です。
*   異なるデータ型（特に日付と日時）を比較する際は、`CAST`関数などを用いて型を明示的に揃えることが、バグを防ぐ上で重要です。
*   複数のテーブルから情報を集めて絞り込む処理は、`INNER JOIN`でテーブルを結合し、`WHERE`句に`AND`で条件を列挙するのが基本形です。

---
## 平成26年秋期 午後 データベース

この回はSQLの穴埋め問題が出題されていませんでした。

***

以上で、ご提示いただいた全20回分の応用情報技術者試験・午後データベース問題のSQL穴埋め問題について、体系的な分析を完了いたしました。これらのパターンを繰り返し学習することで、試験で求められるSQLの読解力、記述力が確実に向上するものと確信しております。合格を心より応援しております。