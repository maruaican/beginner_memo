
---

## 📘 SQLテーブル定義と制約（CONSTRAINT）の体系的解説  
**―「CONSTRAINTは必須か？」という疑問に答えながら―**

このドキュメントは、SQLにおける `CREATE TABLE` 文と、データの整合性を保証する `CONSTRAINT`（制約）について、基本構造から実務的な価値、構文、そして「制約は必須か？」という設計上の判断までを体系的に解説します。

---

### 1. `CREATE TABLE`の基本構文

まずは、従業員テーブル（`従業員`）を例に、テーブル定義の基本構造を確認します。

```sql
CREATE TABLE 従業員 (
    従業員ID INT NOT NULL,
    氏名 VARCHAR(100),
    部署ID INT,
    CONSTRAINT pk_従業員 PRIMARY KEY (従業員ID)
);
```

#### 1.1. 各構成要素の意味

| 要素 | 解説 |
|------|------|
| `CREATE TABLE 従業員` | `従業員`という名前のテーブルを新規作成する命令。 |
| `従業員ID INT NOT NULL` | 従業員の識別子。NULLを許容しない必須項目。 |
| `氏名 VARCHAR(100)` | 従業員の名前。最大100文字の可変長文字列。NULLは許容。 |
| `部署ID INT` | 所属部署のID。NULLは許容。 |
| `CONSTRAINT pk_従業員 PRIMARY KEY (従業員ID)` | `従業員ID`を主キーとして設定。制約名は `pk_従業員`。 |

---

### 2. CONSTRAINTは必ず使う必要があるのか？

#### 💬 質問：CONSTRAINTは必須なの？

この問いに対する答えは：

> ❌ **必須ではない**（省略可能）  
> ✅ **使うべき場面では非常に有効**

つまり、`CONSTRAINT`句はSQL文法上は省略可能ですが、**設計品質・保守性・運用性を高めるためには積極的に使うべき**です。

#### 2.1. 省略した場合の挙動

```sql
CREATE TABLE 従業員 (
    従業員ID INT PRIMARY KEY
);
```

このように書いても主キー制約は機能します。ただし、制約名が自動生成されるため、後から制約を削除・変更する際に識別しづらくなります。

#### 2.2. 制約名を付けるメリット

| 観点 | CONSTRAINT句なし | CONSTRAINT句あり |
|------|------------------|------------------|
| 動作 | ✅ 動く           | ✅ 動く           |
| 保守性 | ❌ 制約名が不明   | ✅ 制約名で操作可能 |
| エラー解析 | ❌ 自動生成名が分かりづらい | ✅ エラーに制約名が出る |
| チーム開発 | ❌ 意図が不明瞭 | ✅ 命名規則で設計意図が明確 |

#### 2.3. 結論：覚える必要はないが、設計には組み込むべき

制約名は「人が覚えるもの」ではなく、「設計に埋め込むもの」です。命名規則とドキュメント管理によって、記憶に頼らない運用が可能です。

---

### 3. CONSTRAINTの構文テンプレート

```sql
CONSTRAINT 制約名称 制約の種類 (対象列)
```

#### 制約の種類と構文例（日本語版）

| 制約の種類 | 構文例 | 意味 |
|------------|--------|------|
| 主キー制約 | `CONSTRAINT pk_従業員 PRIMARY KEY (従業員ID)` | 一意性＋非NULL保証 |
| 外部キー制約 | `CONSTRAINT fk_従業員_部署ID FOREIGN KEY (部署ID) REFERENCES 部署(部署ID)` | 他テーブルとの整合性 |
| 一意性制約 | `CONSTRAINT uq_従業員_メール UNIQUE (メール)` | 重複禁止 |
| チェック制約 | `CONSTRAINT chk_従業員_年齢 CHECK (年齢 >= 18)` | 条件制約 |
| NULL禁止 | `氏名 VARCHAR(100) NOT NULL` | 列定義内で直接指定 |

---

### 4. 複合主キーと外部キーの実例

#### 注文明細テーブルの定義

```sql
CREATE TABLE 注文明細 (
    注文ID INT,
    商品ID INT,
    数量 INT,
    CONSTRAINT pk_注文明細 PRIMARY KEY (注文ID, 商品ID),
    FOREIGN KEY (注文ID) REFERENCES 注文(注文ID),
    FOREIGN KEY (商品ID) REFERENCES 商品(商品ID)
);
```

#### データ挿入例と主キー制約の挙動

```sql
INSERT INTO 注文明細 VALUES (101, 1, 5); -- OK
INSERT INTO 注文明細 VALUES (101, 2, 3); -- OK
INSERT INTO 注文明細 VALUES (102, 1, 10);-- OK
INSERT INTO 注文明細 VALUES (101, 1, 1); -- ❌ 主キー重複でエラー
```

最後の挿入は、主キー `(注文ID, 商品ID)` が既に存在するため、**一意性制約に違反**してエラーになります。

---

### 5. 外部キーと参照制約の関係

#### 外部キー制約は参照制約とセット

```sql
FOREIGN KEY (部署ID) REFERENCES 部署(部署ID)
```

このように、**外部キー制約は参照先を明示する `REFERENCES` 句とセットで使う必要があります**。

#### NULLの扱い

外部キー列が `NOT NULL` でなければ、**NULLは許容されます**。NULLは「未定義な値」であり、参照整合性のチェック対象外です。

---

### 6. 登場テーブルの役割（日本語名称）

| テーブル名 | 役割 |
|------------|------|
| **従業員** | 従業員情報を管理。主キーは `従業員ID`。 |
| **部署** | 部署情報を管理。主キーは `部署ID`。従業員の所属先として参照される。 |
| **商品** | 商品情報を管理。主キーは `商品ID`。 |
| **注文** | 注文情報を管理。主キーは `注文ID`。 |
| **注文明細** | 注文と商品を結びつける中間テーブル。複合主キー `(注文ID, 商品ID)` を持つ。 |

---

### ✅ 総まとめ：CONSTRAINTは「設計品質を守る装置」

- **必須ではないが、設計には組み込むべき**
- **制約名は覚えるものではなく、設計に埋め込むもの**
- **CONSTRAINT句は、保守性・運用性・エラー解析の信頼性を高める**

