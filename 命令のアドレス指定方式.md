了解。ここでは\*\*「命令＝［命令部］＋［アドレス部］」とは何か\*\*から始めて、\*\*図解＋具体的な命令例（MOV）\*\*で、**主語・述語・目的語**を明確にして説明します。見出しはご指定の形式にそろえます。

---

# １　全体像（テキスト図）

```
[主記憶(MEM)]
   ↑(実効アドレスEA)
   │
[アドレス生成器(AGU)] ←―――――――――――――――――――――――――――――――――――――┐
   ↑                (どの方式でEAを作るかを決める)                           │
   │                                                                            │
[命令レジスタ(IR)] … 命令を保持：１［命令部(opcode)］＋２［アドレス部(操作対象の指定)］  │
   ↑                                                                            │
[プログラムカウンタ(PC)] ──→ 命令フェッチ（次に実行する命令の在処）                │
[各種レジスタ]（SP, ベースR, インデックスR, 汎用R …）―――――――――――――――――――――――┘

* 流れ：CPUはPCで指す場所から**命令（命令部＋アドレス部）**を取り出す → 命令レジスタ(IR)に入れる → 
      AGUが「アドレス部」を解釈して実効アドレス(EA)を作る → 
      CPUが実効アドレス(EA)でメモリにアクセスしてデータを読み書きする。
```

---

## １－１　定義（IPA準拠）と用語の由来

（１）**命令（Instruction）**

* **CPUは命令を実行する。**
* **命令は、１「命令部（オペコード）」と、２「アドレス部（オペランド指定）」から構成される。**

  * 例：`MOV R1, [0x1000]` なら、命令部は「MOV」、アドレス部は「\[0x1000]」。

（１）ー１**命令部（Opcode）**

* **命令部は、CPUに“何をするか”を指示する。**（移動する、足す、比較する など）

（２）ー２**アドレス部（Operand specifier）**

* **アドレス部は、“どこを対象にするか／何を対象にするか”を指示する。**
* **CPUはアドレス部の解釈方法（＝アドレス指定方式）にもとづいて、実効アドレスを計算する。**

（３）**実効アドレス（Effective Address; EA）**

* CPUは実効アドレスを**実際にアクセスするメモリ**上の番地”として使う。

（４）**アドレス指定方式（Addressing Mode）**

* **アドレス指定方式は、“アドレス部をどう解釈してEAを作るか”のルールである。**
* 由来：Direct（直接）、Indirect（間接）、Relative（相対）、Base（基底）、Index（指標）、Immediate（即値）など、英語名がそのまま機能を表す。

---
なるほど！承知しました 👍
では「前者＝定義・役割レベル」で、イメージがクリアになるように整理します。

---

（５） **R1（汎用レジスタ）**
* **場所**：CPUの中
* **役割**：演算やデータ処理の途中結果を一時的に保存する箱
* **性質**：主記憶（RAM）のように大量にはない。CPU内部に少数だけ存在。
* **たとえ**：

  * 主記憶＝大きな倉庫
  * R1＝作業机の上の小皿

---

（６）**SP（スタックポインタ）**

* **場所**：CPUの中（特殊レジスタのひとつ）
* **役割**：スタック領域（主記憶の一部）の**一番上（先頭アドレス）を保持する**
* **性質**：戻り値そのものを入れるのではなく、関数の戻り先アドレスなどを置いた「スタック」の位置を覚えている
* **たとえ**：

  * スタック＝積み上げられた皿の山（主記憶の一部）
  * SP＝「いま一番上にある皿の位置を指している指差し棒」

---

👉 まとめると：

* **R1は「CPU内部の作業用レジスタ」**
* **SPは「スタック（メモリ領域）の先頭を指すしるべ」**
* **SPは戻り値を直接保存しない**。戻り値は通常「汎用レジスタ（例：R0）」や特定の場所に置かれる。

---


## １－２　技術の必要性（解決する具体的課題）

（１）**CPUは様々な場所のデータを扱う必要がある。**
* 配列の要素、構造体のフィールド、スタック上の変数、固定番地のI/O領域など。

（２）**アドレス指定方式は、それぞれ異なる“取り回し”を解決する。**

* **直接方式**は“固定番地”にすばやく届く。
* **間接方式**は“ポインタ”を経由して柔軟に届く。
* \*\*相対方式（PC相対）\*\*は“どこにロードされても動く”プログラムを実現する。
* **基底／指標方式**は“配列やレコード”のアクセスを簡潔に書ける。
* **即値方式**は“定数そのもの”を手早く使える（メモリアクセス不要で速い）。

---

## １－３　試験の着眼点（頻出領域と解答に必要な知識）

（１）**頻出の見分けポイント**

* **「そのまま使う」**→**直接（＝絶対）方式**
* **「メモリを一度読んで、その中身をアドレスとして使う」**→**間接方式**
* **「レジスタの値＋変位」**→**相対／基底／指標**

  * **PC＋変位**→**相対**、**SP＋変位**→出題によって**相対（SP相対）**または**基底**のどちらかとして扱われることがある（注記）。

（２）**試験作成者が狙う誤解**（誰が何を狙うかを明示）

* **試験作成者は、受験者が「PC相対＝相対、SP相対＝相対（or基底）」の線引きを曖昧にする誤解を狙ってくる。**
* **試験作成者は、受験者が「間接＝直接」と取り違える誤解を狙ってくる。**
* **試験作成者は、受験者が「即値＝実効アドレス」と誤解する（データそのもの）点を狙ってくる。**

---

## １－４　体系マップ（分類・関係・比較表）

（１）**分類図（箱と矢印）**

```
アドレス指定方式
 ├─ 直接（絶対）…… [アドレス部の値] を そのままEA（実行アドレス）に → MEM（主記憶）
 ├─ 間接 ……………… [アドレス部の値] が指すMEM（主記憶）を読んだ中身をEA(実効アドレス)に → MEM(主記憶)
 ├─ 相対（PC相対/SP相対）… [基準R(PC,SP)] + 変位 → EA(実効アドレス) → MEM(主記憶)
 ├─ 基底（ベース）……… [ベースR] + 変位 → EA(実効アドレス) → MEM(主記憶)
 ├─ 指標（インデックス）… [インデックスR] + 変位（+ベース） → EA(実効アドレス) → MEM(主記憶)
 └─ 即値 ………………… [アドレス部の値] = データそのもの（MEM(主記憶)アクセス不要）
```

（２）**比較表（2～3列簡易表）**

| 方式（和名/英名）      | EAの作り方の主語・述語・目的語                                      |
| -------------- | ----------------------------------------------------- |
| 直接（絶対, Direct） | **CPUは、アドレス部の値を、そのまま実効アドレス（EA）として使う。**                    |
| 間接（Indirect）   | **CPUは、アドレス部の値で指すメモリを1回読み、その読み出した値を実効アドレス（EA）として使う。**     |
| 相対（Relative）   | **CPUは、基準レジスタ（PCやSP）の値に、命令中の変位を加えて、実効アドレス（EA）を作る。**       |
| 基底（Base）       | **CPUは、ベースレジスタの値に、命令中の変位を加えて、実効アドレス（EA）を作る。**             |
| 指標（Index）      | **CPUは、インデックスレジスタの値に、命令中の変位（＋任意のベース）を加えて、実効アドレス（EA）を作る。** |
| 即値（Immediate）  | **CPUは、アドレス部の値を、アドレスではなくデータとして使う。**                   |

---

## １．基準レジスタ（Base Register と呼ばれる場合もある）ー　相対

* **場所**：CPU内部の特殊レジスタ
* **役割**：プログラムでアクセスする **基準となるメモリアドレスを保持する**
* **用途**：プログラムが大きいときに、**どの領域を使うか**を切り替えるために使う。
* **イメージ**：

  * 「社宅の入口住所」を覚えておいて、そこに部屋番号を足して実際の住所を得る。

---

## ２．ベースレジスタ（Base Register）ー基底

* **場所**：CPU内部の特殊レジスタ
* **役割**：命令のアドレス部に書かれた「変位（オフセット）」に、**自分の中身を足して実効アドレスを生成する**
* **用途**：**プログラムやデータの位置が移動しても、ベースレジスタの値を変えるだけで動作可能**にするため。
* **イメージ**：

  * 「アパートの建物の基準位置」を覚えておいて、部屋番号を足して目的の部屋を探す。

👉 注意：教科書や文脈によって「基準レジスタ」と「ベースレジスタ」をほぼ同義に扱う場合があります。

---

## ３．インデックスレジスタ（Index Register）　ー指標

* **場所**：CPU内部の特殊レジスタ
* **役割**：命令のアドレス部に書かれたアドレスに、**自分の中身を足して実効アドレスを生成する**
* **用途**：**配列や繰り返し処理で、同じ基準に対して連続したデータを扱うとき**に便利。
* **イメージ**：

  * 「本棚の先頭の位置」を決めておいて、インデックスレジスタを +1 ずつ増やして、次の本・次の本を参照する。

---

## まとめ（比較表）

| レジスタ名      | 保持する値           | 主な用途                   | たとえ             |
| ---------- | --------------- | ---------------------- | --------------- |
| 基準レジスタ     | 基準となるメモリアドレス    | プログラムやデータ領域の基準を決める     | 社宅の入口住所         |
| ベースレジスタ    | 基準アドレス（ほぼ同義に使う） | プログラムをメモリのどこに置いても動かすため | アパートの建物の位置      |
| インデックスレジスタ | 配列のオフセット値       | 繰り返し・配列アクセス            | 本棚の先頭から何冊目かを数える |

---

-

## １－５　代表例（正答例・誤答例）

（１）**本問の選択肢の評価**

* **エ：命令のアドレス部の値をそのまま実効アドレスとする。→ 正しい（絶対＝直接アドレス方式）。**
* **ア：SPを基準に変位を加える。→ 相対（SP相対）または基底として出題される領域。絶対ではない。**
* **イ：命令アドレスレジスタ（PC）を基準に変位を加える。→ 相対。**
* **ウ：アドレス部で指定したメモリの内容をEAにする。→ 間接。**

（２）**誤答が生まれる理由**

* **受験者は、「基準レジスタ＋変位」を全部“相対”と雑に覚えがちである。**
* **受験者は、「メモリを1回余分に読む」のが間接である点を見落としがちである。**

---

## １－６　よくある誤解と正しい知識

（１）**誤解**：「絶対アドレス方式」と「直接アドレス方式」は別物。

* **正しい知識**：**両者は同義**。IPA問題では表記ゆれがある。

（２）**誤解**：「相対はPCのみ」。

* **正しい知識**：**PC相対が基本だが、SP相対を“相対”または“基底”として扱う出題もある。** 設問文の言い回しに合わせて判定する。

（３）**誤解**：「即値は“即席のアドレス”」。

* **正しい知識**：**即値は“データそのもの”**。メモリ番地ではない。\*\*即値は高速（メモリアクセス不要）\*\*という性能上の特徴も覚える。

（４）**誤解**：「間接は直接と同じ速さ」。

* **正しい知識**：\*\*間接は“メモリ参照が1回増える”ため、直接より遅い（重い）\*\*ことが多い。

---

## １－７　一問一答（5問：問題→回答→解説）

**Q1** `MOV R1, [0x1000]` を直接（絶対）方式とみなすとき、CPUは何をするか。
→ **A**：**CPUは、0x1000をそのまま実効アドレスとして使い、メモリ0x1000からデータを読み、R1へ格納する。**
解説：**「そのままEA(実効アドレス)」＝直接**。余計な計算なし。

**Q2** `MOV R1, [[0x2000]]` を間接方式とみなすとき、CPUは何をするか。
→ **A**：**CPUは、まずメモリ0x2000を読み、その中身（たとえば0x3000）をEA(実効アドレス)として使い、メモリ0x3000からデータを読み、R1へ格納する。**
解説：**“メモリを1回余分に読む”→間接**。

**Q3** PC=0x4000のとき、`MOV R1, [PC + 0x10]` を相対方式とみなすとき、CPUは何をするか。
→ **A**：**CPUは、0x4000に0x10を加えてEA=0x4010を作り、メモリ0x4010からデータを読み、R1へ格納する。**
解説：**PC＋変位**＝相対。

**Q4** SP=0x8000のとき、`MOV R1, [SP + 8]` をSP相対とみなすとき、CPUは何をするか。
→ **A**：**CPUは、0x8000に8を加えてEA=0x8008を作り、メモリ0x8008からデータを読み、R1へ格納する。**
解説：**SP＋変位**。出題によって“相対”または“基底”の枠に置かれる。

**Q5** `MOV R1, #5`（即値）について、CPUは何をするか。
→ **A**：**CPUは、数値5をメモリアドレスではなくデータとして扱い、R1に5を書き込む。**
解説：**即値はデータそのもの**。メモリ参照不要で速い（軽い）。

---

## 具体例：同じメモリ配置を、方式ごとにどう解釈するか（図解＋MOV）

**前提となるメモリの中身（例）**

```
アドレス : 内容
0x1000  : 0xAAAA   （データ）
0x2000  : 0x1000   （ポインタ：0x1000を指す）
0x4010  : 0xBBBB   （データ）
0x8008  : 0xCCCC   （データ）
```

（１）**直接（絶対）**：`MOV R1, [0x1000]`

* **CPUは、0x1000をEA(実効アドレス)として使い、MEM(主記憶)\[0x1000]=0xAAAAを読み、R1に入れる。**

（２）**間接**：`MOV R1, [[0x2000]]`

* **CPUは、MEM(主記憶)\[0x2000]を読み、その内容0x1000をEA(実効アドレス)として使い、MEM(主記憶)\[0x1000]=0xAAAAを読み、R1に入れる。**

（３）**相対（PC相対）**：PC=0x4000で `MOV R1, [PC（プログラムカウンタ）+0x10]`

* **CPUは、EA(実効アドレス)=0x4000+0x10=0x4010を作り、MEM(主記憶)\[0x4010]=0xBBBBを読み、R1に入れる。**

（４）**SP相対（相対／基底どちらかで出題）**：SP=0x8000で `MOV R1, [SP+8]`

* **CPUは、EA(実効アドレス)=0x8000+8=0x8008を作り、MEM(主記憶)\[0x8008]=0xCCCCを読み、R1に入れる。**

（５）**即値**：`MOV R1, #5`

* **CPUは、5をEA(実効アドレス)ではなくデータとしてそのままR1に入れる（メモリは読まない）。**

---

## １－８　要約（3行以内）

**CPUは、命令の「アドレス部」をアドレス指定方式にもとづいて解釈し、実効アドレス(EA)を作ってメモリにアクセスする。**
**「そのまま使う」なら直接（＝絶対）、一度メモリを辿るなら間接、レジスタ＋変位なら相対／基底／指標、定数は即値である。**
**本問は「アドレス部の値をそのまま実効アドレスにする」ので、絶対（直接）アドレス方式が正解である。**

---
