USER
AP試験の午後のデータベースの問題にはSQL文の穴埋め問題があるよね。
どうやってアプローチすればいいだろうか。
私は、次のような点からアプローチしている。
FROM句の表の属性（ER図から）を探って、使われていない属性はないか。
SELECT内に集約関数があれば、GROUP BYが使われているか。
COALESCEが使われていれば、LEFT JOINが使われているはずだ。
埋め込み変数”例 ：発注番号”が本文で設定されていれば、必ずSQL文内には使われる。
本文に「昇順」「降順」とあれば、ORDER BYが使われる。
本文に「ごとに」と記載されていれば、GROUP BYが使われる。
LEFT JOINされた後の表（別名）にはNULLが含まれているので、それをどうにかして処理しなければならない。
など。
今までの過去問を分析して、どのようにアプローチすればいいか、一覧として出力して。質問があったらお願いします。

LLM
いい着眼点をすでに持っていますね。
午後のデータベースSQL穴埋め問題は「本文・ER図・SQL部分の三点照合」をしながら、典型的な“お作法”を抑えるのがコツです。

以下に、過去問分析から整理した **アプローチ一覧** を提示します。

---

# 応用情報技術者試験 SQL穴埋め問題の体系的解法

## 1. SQL穴埋め問題への基本アプローチ

### 1.1. 問題読解のプロセスと3つの着眼点
SQLの穴埋め問題を解く際は、以下のプロセスと着眼点を意識することが重要です。

*   **読解プロセス**: 基本的な確認の順番は `本文（問題文） → ER図 → 部分SQL → 解答欄` です。

---

### 1.1. 解答を導く3つの着眼点

SQLの穴埋め問題を解く上で、以下の3つの視点から多角的にアプローチすることが、正答への近道となります。

1.  **本文のキーワード**: 問題文中の「～ごとに」「～がない場合でも」といった日本語の表現が、適切なSQL構文（例: `GROUP BY`, `LEFT JOIN`）に正しく反映されているかを確認します。

2.  **ER図とテーブル構造**: ER図やテーブル定義から読み取れるテーブル間の関係性や構造が、SQLに正確に落とし込まれているかを検証します。これには、以下の具体的なチェックポイントが含まれます。

3.  **SQL構文の正当性**: 集約関数と`GROUP BY`句の整合性や、サブクエリの戻り値の数など、SQLの基本的な文法ルールが守られているかをチェックします。

### 1.2. ER図とテーブル構造から読み解くべきポイント

特にER図とテーブル構造の分析は、問題の根幹を理解する上で極めて重要です。以下のポイントを重点的に確認することで、設問の意図を正確に把握し、ミスを未然に防ぐことができます。

*   **リレーションシップの確認**
    *   **JOIN条件の特定**: ER図におけるテーブル間のリレーション（例: 「多←1」の矢印）を正確に読み取り、主キーと外部キーに基づく正しい`JOIN`条件（例: `ON T1.外部キー = T2.主キー`）が記述されているかを確認します。
    *   **中間表の役割**: 「多対多」の関係を解消するための中間表（例：注文明細テーブル）は、`JOIN`の記述漏れが起こりやすい箇所です。その必要性とクエリ内での使われ方を特に注意してチェックします。

*   **属性の利用状況の確認**
    *   **属性の過不足チェック**: `FROM`句で指定されているテーブルの全属性をリストアップし、それらが`SELECT`句、`WHERE`句、`JOIN`条件などで過不足なく使用されているかを確認します。これにより、考慮から漏れている属性がないかを検証できます。

---

## 2. 出題者が狙う誤答パターン（頻出の罠）

応用情報技術者試験では、SQLの基本的な知識だけでなく、間違いやすいポイントを意図的に狙った問題が出題されます。

### 条件句の混同
*   **`WHERE`句 と `HAVING`句 の混同**
    *   **狙い**: 集約「前」の条件と集約「後」の条件の使い分けを理解しているかを問う。
    *   **正しい理解**:
        *   `WHERE`：`GROUP BY`で集約する前の、個々の行に対する条件。
        *   `HAVING`：`GROUP BY`で集約した後の、グループに対する条件。
    *   **誤答例**: `SELECT 部署ID, AVG(給与) FROM 社員 WHERE AVG(給与) >= 300000 GROUP BY 部署ID;` （`WHERE`句で集約関数は使えない）

*   **`ON`句 と `WHERE`句 の混同 (特に`LEFT JOIN`時)**
    *   **狙い**: `LEFT JOIN`において、結合条件と絞り込み条件の違いが結果にどう影響するかを理解しているかを問う。
    *   **正しい理解**:
        *   `ON`：テーブルを「結合するための条件」。ここに右側テーブルの条件を書くと、条件に合わない行は`NULL`として結合されるが、左側テーブルの行は残る。
        *   `WHERE`：結合が「完了した後の結果」から行を絞り込む条件。ここに右側テーブルの条件を書くと、`NULL`の行が除外され、`INNER JOIN`と同じ結果になることがある。
    *   **例**: `LEFT JOIN ... WHERE B.状態='有効'` と書くと、`B`テーブルに対応するデータがない行（`B.状態`が`NULL`）が除外されてしまう。

### NULLの取り扱いに関する罠
*   **`NOT IN` と `NULL` の罠**
    *   **狙い**: `NOT IN`のサブクエリに`NULL`が含まれる場合の挙動を知っているかを問う。
    *   **正しい理解**: サブクエリの結果に一つでも`NULL`が含まれていると、`NOT IN`句の評価結果が不明と判断され、すべてFALSEとなり、結果セットが0件になる危険性がある。
    *   **安全策**: `NOT EXISTS`を使用するが安全。`NOT EXISTS`は`NULL`の影響を受けないため、より安全で確実。

*   **`LEFT JOIN` 後の `COALESCE` 忘れ**
    *   **狙い**: 「～ない場合は0と表示」という要件に対し、`LEFT JOIN`だけで満足し、`NULL`を`0`に置換し忘れるミスを誘う。
    *   **正しい理解**: `LEFT JOIN`で対応するデータがなかった場合、集計関数(`SUM`, `COUNT`など)の結果は`NULL`になる。これを`0`として表示するには`COALESCE(SUM(...), 0)`のように明示的な変換が必要。

### 集約と列指定のルール違反
*   **`GROUP BY` の記述漏れ**
    *   **狙い**: `SELECT`句に集約関数と非集約列を混在させる際のルールを理解しているかを問う。
    *   **正しい理解**: `SELECT`句に集約関数とそれ以外の列（非集約列）を記述する場合、すべての非集約列を`GROUP BY`句に指定しなければならない。

*   **スカラサブクエリの複数行返却**
    *   **狙い**: `SELECT`句内や`WHERE`句の`=`の右辺で使うサブクエリが、必ず単一の値（1行1列）を返さなければならないというルールを突く。
    *   **正しい理解**: サブクエリが複数行を返す可能性がある場合、`MAX`, `MIN`などで1行に絞るか、`IN`や`EXISTS`を使うなど、構文を切り替える必要がある。

---
## 3. 頻出SQLパターン 実践コード演習

問題文に登場する特定のキーワードは、使用すべき頻出のSQL構文を判断するための重要なヒントとなります。
---

### 問題1
社員テーブルから、部署ごとの社員数を算出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 部署ID, COUNT(*)
FROM 社員
【 a 】 部署ID;
```
【回答】
`GROUP BY`

【問題文内のキーワード】
「～ごと」

【解説】
「～ごとに」「部署別に」といった、特定の単位でデータをグループ化して集計処理を行う場合は`GROUP BY`句を使用します。

【頻出パターン】
`SELECT`句で指定した集計関数以外の列（ここでは`部署ID`）は、必ず`GROUP BY`句にも指定する必要があります。

---

### 問題2
注文テーブルから、注文金額の合計を算出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 【 a 】(金額)
FROM 注文;
```
【回答】
`SUM`

【問題文内のキーワード】
「合計」

【解説】
データの「合計」「平均」「最大」「最小」「件数」などを計算するには集約関数を使用します。合計を求める場合は`SUM()`関数を使います。

【頻出パターン】
`SUM()`（合計）、`AVG()`（平均）、`MAX()`（最大）、`MIN()`（最小）、`COUNT()`（件数）はセットで覚え、`GROUP BY`句と組み合わせて使うことが非常に多いです。

---

### 問題3
部署ごとの平均給与を算出し、その平均給与が30万円以上の部署のみを抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 部署ID
FROM 社員
GROUP BY 部署ID
【 a 】 AVG(給与) >= 300000;
```
【回答】
`HAVING`

【問題文内のキーワード】
「平均給与が30万円以上」

【解説】
「～ごとの合計が～を超える」のように、`GROUP BY`で集計した後の結果に対してさらに条件を指定する場合は`HAVING`句を使用します。

【頻出パターン】
`WHERE`句は集計前のデータ（行単位）を絞り込み、`HAVING`句は集計後の結果（グループ単位）を絞り込む、という使い分けは必須の知識です。

---

### 問題4
商品マスタと注文テーブルを結合し、販売実績がない商品も一覧に含めて表示するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT P.商品名
FROM 商品 P 【 a 】 注文 O
ON P.商品ID = O.商品ID;
```
【回答】
`LEFT JOIN`

【問題文内のキーワード】
「～がない場合でも表示」

【解説】
「実績がない場合も」「注文が存在しない顧客も」のように、一方のテーブルにデータが存在しなくても、基準となるテーブル（この場合は商品マスタ）の情報をすべて表示したい場合に`LEFT JOIN`（外部結合）を使用します。

【頻出パターン】
マスターデータを基準にした集計（例: 社員がいない部署、一度も購入していない顧客の一覧）で頻繁に利用されます。

---

### 問題5
販売実績がない商品の売上数量を`NULL`ではなく`0`と表示するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT
    P.商品名,
    【 a 】(SUM(O.数量), 0) AS 売上数量
FROM
    商品 P LEFT JOIN 注文 O
ON P.商品ID = O.商品ID
GROUP BY
    P.商品名;
```
【回答】
`COALESCE`

【問題文内のキーワード】
「実績がない場合は0と表示」

【解説】
`LEFT JOIN`などで発生した`NULL`値を、`0`や特定の文字列など、別の値に置き換えたい場合は`COALESCE`関数を使用します。`COALESCE(値1, 値2)`は、値1が`NULL`でなければ値1を、`NULL`であれば値2を返します。

【頻出パターン】
`LEFT JOIN`と`COALESCE(集計関数(...), 0)`は、実績のない項目を0として表示する際の定番の組み合わせです。

---

### 問題6
注文テーブルを参照し、一度でも注文したことがある顧客の名前を顧客テーブルから抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT C.顧客名
FROM 顧客 C
WHERE 【 a 】 (
  SELECT 1 FROM 注文 O WHERE O.顧客ID = C.顧客ID
);
```
【回答】
`EXISTS`

【問題文内のキーワード】
「存在するか」

【解説】
「該当があるか」のように、条件に一致するデータがサブクエリ内に1件でも存在するかどうかを判定したい場合に`EXISTS`を使用します。

【頻出パターン】
`EXISTS`はサブクエリの実行結果が存在するかどうかだけをチェックするため、`IN`句よりもパフォーマンスが良い場合があります。

---

### 問題7
注文テーブルを参照し、一度も注文したことがない顧客の名前を顧客テーブルから抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT C.顧客名
FROM 顧客 C
WHERE 【 a 】 (
  SELECT 1 FROM 注文 O WHERE O.顧客ID = C.顧客ID
);
```
【回答】
`NOT EXISTS`

【問題文内のキーワード】
「～したことがない」

【解説】
「含まれていない」「除外したい」など、条件に一致するデータがサブクエリ内に一件も存在しないことを確認したい場合は`NOT EXISTS`を使用します。

【頻出パターン】
`NOT IN`はサブクエリの結果に`NULL`が含まれていると意図通りに動作しない可能性があるため、`NOT EXISTS`の使用がより安全で推奨されます。

---

### 問題8
まず部署ごとの社員数を集計し、その結果から社員数が10人以上の部署のみを抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT T.部署ID
FROM (
    SELECT 部署ID, COUNT(*) AS 社員数
    FROM 社員
    GROUP BY 部署ID
) AS 【 a 】
WHERE T.社員数 >= 10;
```
【回答】
`T` （または任意のエイリアス名）

【問題文内のキーワード】
「まず集計してから」「～した結果に対して」

【解説】
ある集計処理を行った結果を一時的なテーブルとみなし、それに対してさらに絞り込みや結合を行いたい場合、`FROM`句でサブクエリ（派生表）を使用します。

【頻出パターン】
`FROM`句でサブクエリを使用する場合、そのサブクエリには必ず`AS`を使ってテーブルエイリアス（別名）を付ける必要があります。

---

### 問題9
社員テーブルの全レコードを、給与が高い順に並べ替えて表示するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 社員名, 給与
FROM 社員
ORDER BY 給与 【 a 】;
```
【回答】
`DESC`

【問題文内のキーワード】
「～の順で」「高い順」

【解説】
結果の表示順序を指定するには`ORDER BY`句を使用します。昇順（小さい順）は`ASC`、降順（大きい順）は`DESC`を指定します。

【頻出パターン】
`ORDER BY`句は`SELECT`文の最後に記述します。昇順を指定する`ASC`は省略可能です。
日付は、過去からなら、ASC、最近の者からならDESC。

---

### 問題10
注文テーブルから、最新の注文を上位5件だけ取得するSQL文です。空欄【 a 】と【 b 】を埋めてください。(※構文はデータベース製品により異なります)
```sql
-- 標準SQLの場合
SELECT *
FROM 注文
ORDER BY 注文日 DESC
【 a 】 【 b 】 ROWS ONLY;
```
【回答】
a: `FETCH FIRST`
b: `5`

【問題文内のキーワード】
「最新」「上位○件」

【解説】
`ORDER BY`句で並べ替えた後、先頭から指定した件数のみを取得する処理です。ランキングや最新履歴の表示などで使用します。

【頻出パターン】
この構文はデータベース製品によって異なります。MySQLでは`LIMIT 5`、SQL Serverでは`TOP (5)`と記述するのが一般的です。
---



### 問題1
社員テーブルから、部署ごとの社員数を算出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 部署ID, COUNT(*)
FROM 社員
【 a 】 部署ID;
```
【回答】
`GROUP BY`

【問題文内のキーワード】
「～ごと」

【解説】
「～ごと」という集計単位を指定するには`GROUP BY`句を使用します。このSQLでは、部署IDを基準にグループ化し、それぞれのグループに含まれる行数（社員数）を`COUNT(*)`で数えています。

【頻出パターン】
`SELECT`句で指定した集計関数以外の列（ここでは`部署ID`）は、必ず`GROUP BY`句にも指定する必要があります。

---

### 問題2
社員テーブルから、部署ごとの平均給与を算出し、その平均給与が30万円以上の部署のみを抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 部署ID, AVG(給与)
FROM 社員
GROUP BY 部署ID
【 a 】 AVG(給与) >= 300000;
```
【回答】
`HAVING`

【問題文内のキーワード】
「平均給与が30万円以上の部署のみ」

【解説】
`GROUP BY`句によってグループ化された結果に対して条件を指定する場合は、`WHERE`句ではなく`HAVING`句を使用します。`HAVING`句では`AVG()`のような集計関数を条件に含めることができます。

【頻出パターン】
`WHERE`句はグループ化する前（行単位）の絞り込み、`HAVING`句はグループ化した後（グループ単位）の絞り込み、という使い分けは必須の知識です。

---

### 問題3
社員テーブルと部署テーブルを結合し、社員名と部署名を取得するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 社員名, 部署名
FROM 社員 INNER JOIN 部署
【 a 】 社員.部署ID = 部署.部署ID;
```
【回答】
`ON`

【問題文内のキーワード】
「結合し」

【解説】
`JOIN`句でテーブル同士を結合する際、どの列を基準に関連付けるかを指定するのが`ON`句の役割です。ここでは、両テーブルに共通する`部署ID`を結合条件にしています。

【頻出パターン】
`FROM テーブルA JOIN テーブルB ON A.ID = B.ID` という構文は、テーブル結合の基本形として非常によく使われます。

---

### 問題4
部署ごとに所属する社員数を表示します。社員が一人もいない部署も「0人」として表示するためのSQL文です。空欄【 a 】と【 b 】を埋めてください。
```sql
SELECT
    部署.部署ID,
    【 a 】(COUNT(社員.社員ID), 0)
FROM
    部署 【 b 】 社員
ON
    部署.部署ID = 社員.部署ID
GROUP BY
    部署.部署ID;
```
【回答】
a: `COALESCE`
b: `LEFT JOIN`

【問題文内のキーワード】
「社員が一人もいない部署も」「0人として表示」

【解説】
基準となるテーブル（この場合は部署テーブル）の情報をすべて残したい場合は`LEFT JOIN`（外部結合）を使用します。`LEFT JOIN`では、右側の社員テーブルに一致するデータがない部署の`COUNT(社員.社員ID)`が`NULL`になるため、`COALESCE`関数を使って`NULL`を`0`に変換します。

【頻出パターン】
「会員ごとの購入履歴（購入歴のない会員も表示）」「商品ごとの売上（一度も売れていない商品も表示）」など、マスターデータを基準に集計する際によく使われる組み合わせです。

---

### 問題5
社員テーブル自身を結合（自己結合）して、各社員の氏名とその上司の氏名を取得するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT
    E.社員名,
    M.社員名 AS 上司名
FROM
    社員 E LEFT JOIN 社員 【 a 】
ON
    E.上司ID = M.社員ID;
```
【回答】
`M`

【問題文内のキーワード】
「社員テーブル自身を結合」

【解説】
同じテーブルを結合する場合、それぞれを区別するためにテーブルエイリアス（別名）を付けます。このSQLでは、部下側のテーブルを「E (Employee)」、上司側のテーブルを「M (Manager)」として扱い、部下の「上司ID」と上司の「社員ID」を紐づけています。

【頻出パターン】
親子関係のあるカテゴリ一覧や、企業の組織図など、一つのテーブル内に階層構造を持つデータを扱う際によく利用されます。

---

### 問題6
全社員の平均給与をサブクエリで算出し、その平均給与よりも高い給与をもらっている社員名を抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 社員名
FROM 社員
WHERE 給与 > 【 a 】;
```
【回答】
`(SELECT AVG(給与) FROM 社員)`

【問題文内のキーワード】
「平均給与よりも高い」

【解説】
`WHERE`句などで比較する値が固定値ではなく、別のSQLで取得する必要がある場合にサブクエリを使用します。この例のように、単一の値を返すサブクエリは特に「スカラサブクエリ」と呼ばれます。

【頻出パターン】
`WHERE 列 > (SELECT AVG(列) FROM ...)` のように、全体の平均値や特定条件の合計値などを条件として使いたい場合に頻繁に登場します。

---

### 問題7
注文テーブルに一度も登場したことがない（=注文したことがない）顧客名を、顧客テーブルから抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 顧客名
FROM 顧客
WHERE 【 a 】 (
  SELECT 1 FROM 注文
  WHERE 注文.顧客ID = 顧客.顧客ID
);
```
【回答】
`NOT EXISTS`

【問題文内のキーワード】
「一度も登場したことがない」

【解説】
`EXISTS`は、サブクエリが1件でも結果を返せば真となる条件演算子です。`NOT EXISTS`はその逆で、1件も結果を返さない場合に真となります。「～したことがない」「～が存在しない」といった条件の判定に適しています。

【頻出パターン】
`NOT IN (SELECT ...)` を使う方法もありますが、サブクエリ内に`NULL`が含まれていると意図しない結果になるため、`NOT EXISTS`を使う方が安全で確実です。

---

### 問題8
まず顧客ごとの注文件数を集計し、その結果から注文件数が5件以上の顧客IDのみを抽出するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 顧客ID, 注文件数
FROM (
    SELECT 顧客ID, COUNT(*) AS 注文件数
    FROM 注文
    GROUP BY 顧客ID
) 【 a 】
WHERE 注文件数 >= 5;
```
【回答】
`AS 集計` （または `集計` のみ）

【問題文内のキーワード】
「集計し、その結果から」

【解説】
`FROM`句の中に直接`SELECT`文を記述し、その結果を一つの仮想的なテーブルとして扱うことができます。この仮想テーブルを「派生表」または「インラインビュー」と呼びます。

【頻出パターン】
`FROM`句でサブクエリ（派生表）を使用する場合、その派生表には必ずテーブルエイリアス（別名）を付けなければならない、という構文上のルールがあります。(`AS`は省略可能です)

---

### 問題9
社員テーブルの全レコードを、給与が高い順（降順）に並べ替えて表示するSQL文です。空欄【 a 】を埋めてください。
```sql
SELECT 社員名, 給与
FROM 社員
ORDER BY 給与 【 a 】;
```
【回答】
`DESC`

【問題文内のキーワード】
「高い順（降順）に」

【解説】
SQLの実行結果を特定の順序で並べ替えたい場合は`ORDER BY`句を使用します。昇順（小さい順）は`ASC`、降順（大きい順）は`DESC`を指定します。

【頻出パターン】
`ORDER BY`句は`SELECT`文の最後に記述します。昇順の`ASC`はデフォルトであるため省略可能です。

---

### 問題10
社員の給与が30万円以上なら「高給」、そうでなければ「通常」と表示を分けるSQL文です。空欄【 a 】と【 b 】を埋めてください。
```sql
SELECT
    社員名,
    【 a 】 WHEN 給与 >= 300000 THEN '高給'
          ELSE '通常'
    【 b 】 AS 給与カテゴリ
FROM
    社員;
```
【回答】
a: `CASE`
b: `END`

【問題文内のキーワード】
「～なら～、そうでなければ～と表示を分ける」

【解説】
SQLの中で、プログラミング言語のif文のように条件に応じて表示内容を切り替えたい場合は`CASE`式を使用します。`CASE`で始まり、`WHEN ... THEN ...`で条件と結果を記述し、最後に`END`で式を閉じます。

【頻出パターン】
`CASE WHEN 条件1 THEN 結果1 WHEN 条件2 THEN 結果2 ELSE デフォルト結果 END` という一連の構文は非常によく使われます。`AS`を使って分かりやすい別名を付けるのが一般的です。