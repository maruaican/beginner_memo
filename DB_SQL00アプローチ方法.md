USER
AP試験の午後のデータベースの問題にはSQL文の穴埋め問題があるよね。
どうやってアプローチすればいいだろうか。
私は、次のような点からアプローチしている。
FROM句の表の属性（ER図から）を探って、使われていない属性はないか。
SELECT内に集約関数があれば、GROUP BYが使われているか。
COALESCEが使われていれば、LEFT JOINが使われているはずだ。
埋め込み変数”例 ：発注番号”が本文で設定されていれば、必ずSQL文内には使われる。
本文に「昇順」「降順」とあれば、ORDER BYが使われる。
本文に「ごとに」と記載されていれば、GROUP BYが使われる。
LEFT JOINされた後の表（別名）にはNULLが含まれているので、それをどうにかして処理しなければならない。
など。
今までの過去問を分析して、どのようにアプローチすればいいか、一覧として出力して。質問があったらお願いします。

LLM
いい着眼点をすでに持っていますね。
午後のデータベースSQL穴埋め問題は「本文・ER図・SQL部分の三点照合」をしながら、典型的な“お作法”を抑えるのがコツです。

以下に、過去問分析から整理した **アプローチ一覧** を提示します。

---

# 応用情報技術者試験 SQL穴埋め問題の体系的解法

## 1. SQL穴埋め問題への基本アプローチ

### 1.1. 問題読解のプロセスと3つの着眼点
SQLの穴埋め問題を解く際は、以下のプロセスと着眼点を意識することが重要です。

*   **読解プロセス**: 基本的な確認の順番は `本文（問題文） → ER図 → 部分SQL → 解答欄` です。

---

### 1.1. 解答を導く3つの着眼点

SQLの穴埋め問題を解く上で、以下の3つの視点から多角的にアプローチすることが、正答への近道となります。

1.  **本文のキーワード**: 問題文中の「～ごとに」「～がない場合でも」といった日本語の表現が、適切なSQL構文（例: `GROUP BY`, `LEFT JOIN`）に正しく反映されているかを確認します。

2.  **ER図とテーブル構造**: ER図やテーブル定義から読み取れるテーブル間の関係性や構造が、SQLに正確に落とし込まれているかを検証します。これには、以下の具体的なチェックポイントが含まれます。

3.  **SQL構文の正当性**: 集約関数と`GROUP BY`句の整合性や、サブクエリの戻り値の数など、SQLの基本的な文法ルールが守られているかをチェックします。

### 1.2. ER図とテーブル構造から読み解くべきポイント

特にER図とテーブル構造の分析は、問題の根幹を理解する上で極めて重要です。以下のポイントを重点的に確認することで、設問の意図を正確に把握し、ミスを未然に防ぐことができます。

*   **リレーションシップの確認**
    *   **JOIN条件の特定**: ER図におけるテーブル間のリレーション（例: 「多←1」の矢印）を正確に読み取り、主キーと外部キーに基づく正しい`JOIN`条件（例: `ON T1.外部キー = T2.主キー`）が記述されているかを確認します。
    *   **中間表の役割**: 「多対多」の関係を解消するための中間表（例：注文明細テーブル）は、`JOIN`の記述漏れが起こりやすい箇所です。その必要性とクエリ内での使われ方を特に注意してチェックします。

*   **属性の利用状況の確認**
    *   **属性の過不足チェック**: `FROM`句で指定されているテーブルの全属性をリストアップし、それらが`SELECT`句、`WHERE`句、`JOIN`条件などで過不足なく使用されているかを確認します。これにより、考慮から漏れている属性がないかを検証できます。

---

## 2. 出題者が狙う誤答パターン（頻出の罠）

応用情報技術者試験では、SQLの基本的な知識だけでなく、間違いやすいポイントを意図的に狙った問題が出題されます。

### 条件句の混同
*   **`WHERE`句 と `HAVING`句 の混同**
    *   **狙い**: 集約「前」の条件と集約「後」の条件の使い分けを理解しているかを問う。
    *   **正しい理解**:
        *   `WHERE`：`GROUP BY`で集約する前の、個々の行に対する条件。
        *   `HAVING`：`GROUP BY`で集約した後の、グループに対する条件。
    *   **誤答例**: `SELECT 部署ID, AVG(給与) FROM 社員 WHERE AVG(給与) >= 300000 GROUP BY 部署ID;` （`WHERE`句で集約関数は使えない）

*   **`ON`句 と `WHERE`句 の混同 (特に`LEFT JOIN`時)**
    *   **狙い**: `LEFT JOIN`において、結合条件と絞り込み条件の違いが結果にどう影響するかを理解しているかを問う。
    *   **正しい理解**:
        *   `ON`：テーブルを「結合するための条件」。ここに右側テーブルの条件を書くと、条件に合わない行は`NULL`として結合されるが、左側テーブルの行は残る。
        *   `WHERE`：結合が「完了した後の結果」から行を絞り込む条件。ここに右側テーブルの条件を書くと、`NULL`の行が除外され、`INNER JOIN`と同じ結果になることがある。
    *   **例**: `LEFT JOIN ... WHERE B.状態='有効'` と書くと、`B`テーブルに対応するデータがない行（`B.状態`が`NULL`）が除外されてしまう。

### NULLの取り扱いに関する罠
*   **`NOT IN` と `NULL` の罠**
    *   **狙い**: `NOT IN`のサブクエリに`NULL`が含まれる場合の挙動を知っているかを問う。
    *   **正しい理解**: サブクエリの結果に一つでも`NULL`が含まれていると、`NOT IN`句の評価結果が不明と判断され、すべてFALSEとなり、結果セットが0件になる危険性がある。
    *   **安全策**: `NOT EXISTS`を使用するが安全。`NOT EXISTS`は`NULL`の影響を受けないため、より安全で確実。

*   **`LEFT JOIN` 後の `COALESCE` 忘れ**
    *   **狙い**: 「～ない場合は0と表示」という要件に対し、`LEFT JOIN`だけで満足し、`NULL`を`0`に置換し忘れるミスを誘う。
    *   **正しい理解**: `LEFT JOIN`で対応するデータがなかった場合、集計関数(`SUM`, `COUNT`など)の結果は`NULL`になる。これを`0`として表示するには`COALESCE(SUM(...), 0)`のように明示的な変換が必要。

### 集約と列指定のルール違反
*   **`GROUP BY` の記述漏れ**
    *   **狙い**: `SELECT`句に集約関数と非集約列を混在させる際のルールを理解しているかを問う。
    *   **正しい理解**: `SELECT`句に集約関数とそれ以外の列（非集約列）を記述する場合、すべての非集約列を`GROUP BY`句に指定しなければならない。

*   **スカラサブクエリの複数行返却**
    *   **狙い**: `SELECT`句内や`WHERE`句の`=`の右辺で使うサブクエリが、必ず単一の値（1行1列）を返さなければならないというルールを突く。
    *   **正しい理解**: サブクエリが複数行を返す可能性がある場合、`MAX`, `MIN`などで1行に絞るか、`IN`や`EXISTS`を使うなど、構文を切り替える必要がある。

---
## 3. 頻出SQLパターン 実践コード演習


### 問題1

月末棚卸しのため、「倉庫C003で在庫が100以上ある商品」について、**全倉庫での在庫合計**を出したい。空欄を埋めよ。

```sql
SELECT 商品コード, SUM(在庫数) AS 在庫合計
FROM 在庫
WHERE 商品コード 【 a 】 (
  SELECT 商品コード
  FROM 在庫
  WHERE 倉庫番号 = 'C003' AND 在庫数 >= 100
)
GROUP BY 商品コード;
```

**【回答】**
`a`: IN

**【この構文が必要な理由】**
内側は「商品コードの集合（1列複数行）」を返すため、外側の行がその集合に**属するか**を判定する `IN` が最短・明解。

**【構文の解説】**

* 形：`値 IN (サブクエリ)`（サブクエリは1列複数行）
* 役割：集合への所属判定。重複は自動的に無害化される。
* 評価順注記：**FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY**（WHERE で対象行確定→外側で集計）

**【初心者が陥りがちな誤解や誤答例】**

* **誤答**：`商品コード = (SELECT 商品コード ...)`

  * **解説**：サブクエリが複数行を返す可能性があり不適切。`=` は**1行1列**専用。
* **誤答**：`EXISTS (SELECT ...)` に置換

  * **解説**：書けるが「集合所属」は `IN` が自然で可読性・保守性が高い。
* **性能感**：`IN` は**軽い/高速**（索引があれば特に）。内側に適切な索引（`在庫(倉庫番号, 在庫数, 商品コード)`）でさらに高速。

---

### 問題2

「**一度でも注文した顧客**」を抽出したい。相関で存在だけ確認する形にする。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客 外側
WHERE 【 a 】 (
  SELECT 1
  FROM 注文 内側
  WHERE 内側.顧客ID = 外側.顧客ID
);
```

**【回答】**
`a`: EXISTS

**【この構文が必要な理由】**
「関連行が**1件でも存在**するか」を問う設計には `EXISTS` が最短で、行の中身ではなく**存在**だけを見るため効率的。

**【構文の解説】**

* 形：`EXISTS (SELECT 1 FROM 関連表 WHERE 関連表.key = 外側.key AND 条件)`
* 役割：存在の有無だけ真偽化（件数は不要）。
* 評価順注記：**FROM→WHERE(外側)** → `EXISTS` 内部で必要最小限の探索。

**【初心者が陥りがちな誤解や誤答例】**

* **誤解**：`SELECT *` にしないと速くならない

  * **解説**：`EXISTS` は**存在のみ**評価。`SELECT 1` で十分（中身は読まない）。
* **誤答**：`IN (SELECT 顧客ID FROM 注文)` に必ず置換

  * **解説**：`IN` でも等価になりやすいが、相関条件や追加条件が多いと `EXISTS` の方が**軽い/高速**になる場面が多い（索引命中時）。

---

### 問題3

「**一度も注文が無い顧客**」を抽出したい。NULLに影響されない否定形を用いる。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客 外側
WHERE 【 a 】 (
  SELECT 1
  FROM 注文 内側
  WHERE 内側.顧客ID = 外側.顧客ID
);
```

**【回答】**
`a`: NOT EXISTS

**【この構文が必要な理由】**
`NOT IN` は内側に `NULL` が混入すると意図せず結果が**0件**になり得る。`NOT EXISTS` は**NULL非依存**で安全。

**【構文の解説】**

* 形：`NOT EXISTS (相関サブクエリ)`
* 役割：関連行が**1件も無い**ことの判定（NULLの影響なし）。
* 評価順注記：外側を1行ずつ検査→内側で該当行の有無だけチェック。

**【初心者が陥りがちな誤解や誤答例】**

* **誤答**：`顧客ID NOT IN (SELECT 顧客ID FROM 注文)`

  * **解説**：内側 `顧客ID` に `NULL` が1つでもあると三値論理で**UNKNOWN**に倒れ外側が落ちる。
* **性能感**：適切な索引（`注文(顧客ID)`）があれば **軽い/高速**。フルスキャンは**重い/低速**。

---

### 問題4

「**ブラックリスト顧客**（テーブル：取引停止(顧客ID)）を除外して顧客を一覧」する。`NOT IN` を安全に使うための**NULL除外**を入れよ。

```sql
SELECT 顧客ID, 顧客名
FROM 顧客
WHERE 顧客ID 【 a 】 (
  SELECT 顧客ID
  FROM 取引停止
  WHERE 顧客ID 【 b 】 
);
```

**【回答】**
`a`: NOT IN
`b`: IS NOT NULL

**【この構文が必要な理由】**
`NOT IN` は内側に `NULL` があると外側が**全落ち**するため、内側で `IS NOT NULL` を加えて候補から除外しておく。

**【構文の解説】**

* 形：`値 NOT IN (SELECT 列 FROM T WHERE 列 IS NOT NULL)`
* 役割：否定の集合比較だが、**NULL除外**が実務必須。
* 評価順注記：内側WHEREでNULL除外→外側WHEREで否定所属判定。

**【初心者が陥りがちな誤解や誤答例】**

* **誤解**：`NOT IN` は `NULL` を自動無視

  * **解説**：いいえ。`NOT IN` は `NULL` が1つでもあるとUNKNOWNへ。
* **代案**：`NOT EXISTS` が**推奨**（より安全・読みやすい）。
* **性能感**：`NOT EXISTS` の方が最適化しやすく**速い**ことが多い。

---

### 問題5

「**特売商品**（特売商品(商品コード)）に含まれる商品だけ、商品マスタから抽出」したい。

```sql
SELECT 商品コード, 商品名
FROM 商品マスタ
WHERE 商品コード = 【 a 】 (
  SELECT 商品コード
  FROM 特売商品
);
```

**【回答】**
`a`: ANY

**【この構文が必要な理由】**
`= ANY(集合)` は `IN(集合)` と等価で、**単一値比較の形**で集合所属を表現できる。

**【構文の解説】**

* 形：`式 = ANY (サブクエリ)`（1列複数行）
* 量化の意味：**いずれか**と等しければ真。
* 評価順注記：内側で候補集合→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

* **誤解**：`ANY` は「任意の値より大きい」の意味

  * **解説**：演算子と**組み合わせ**で意味が決まる。`= ANY` は `IN`、`> ALL` は「最大より大きい」など。
* **性能感**：`IN` と同程度。索引が利くと**高速**。

---

### 問題6

「**部門内で給与が全員より高い社員**」を抽出する。自分自身は除外して比較する。

```sql
SELECT 社員ID, 社員名, 部署ID, 給与
FROM 社員 自
WHERE 給与 【 a 】 (
  SELECT 給与
  FROM 社員 他
  WHERE 他.部署ID = 自.部署ID
    AND 他.社員ID <> 自.社員ID
);
```

**【回答】**
`a`: > ALL

**【この構文が必要な理由】**
`> ALL(集合)` は「集合の**最大値より大きい**」と同値。部署内の全員より高いを1発で表現。

**【構文の解説】**

* 形：`式 > ALL(サブクエリ)`
* 等価形：`給与 > (SELECT MAX(給与) FROM 社員 WHERE 部署ID = 自.部署ID AND 社員ID <> 自.社員ID)`
* 評価順注記：内側で比較集合→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

* **誤答**：`>= ALL`

  * **解説**：自分と同額の誰かがいれば成立してしまう。問題は\*\*「全員より高い」\*\*なので `>`。
* **性能感**：`MAX` 等価形に書き換えると**軽い/高速**になりやすい（集約1回）。

---

### 問題7

「**競合より最安**の自社商品」を抽出する（競合価格(商品コード, 競合単価)）。

```sql
SELECT 自.商品コード, 自.商品名, 自.単価
FROM 商品マスタ 自
WHERE 自.単価 【 a 】 (
  SELECT 競合単価
  FROM 競合価格 競
  WHERE 競.商品コード = 自.商品コード
);
```

**【回答】**
`a`: <= ALL

**【この構文が必要な理由】**
`<= ALL(集合)` は「集合の**最小値以上ではない**」= **最小値以下**。競合のどれよりも高くない → **最安**を表現。

**【構文の解説】**

* 形：`式 <= ALL(サブクエリ)`
* 等価形：`自.単価 <= (SELECT MIN(競合単価) FROM 競合価格 WHERE 商品コード=自.商品コード)`
* 評価順注記：内側で比較集合（商品ごと）→外側で量化比較。

**【初心者が陥りがちな誤解や誤答例】**

* **誤解**：`< ANY` で最安

  * **解説**：`< ANY` は「**どれか1つ**より小さい」だけ。最安保証にならない。
* **性能感**：`MIN` 等価形は**軽い/高速**になりやすい。

---

### 問題8

「**部門平均より給与が高い社員**」を抽出する。内側を**1行1列**に収める集約関数を入れよ。

```sql
SELECT 社員ID, 社員名, 部署ID, 給与
FROM 社員 外側
WHERE 給与 > (
  SELECT 【 a 】(給与)
  FROM 社員 同部署
  WHERE 同部署.部署ID = 外側.部署ID
);
```

**【回答】**
`a`: AVG

**【この構文が必要な理由】**
スカラサブクエリ（`=` や `>` と比較）は**必ず1行1列**。部門ごとに複数行になる集合を `AVG` で**単一値**へ縮約する。

**【構文の解説】**

* 形：`式 [比較] (SELECT 集約(列) FROM ... WHERE ...)`
* 役割：相関して**部門単位の代表値**（平均）を得る。
* 評価順注記：外側1行ごとに内側を評価（相関）。
* 補足：`GROUP BY 部署ID` を使わず相関で1部署に限定→1行化。

**【初心者が陥りがちな誤解や誤答例】**

* **誤答**：`WHERE 給与 > (SELECT 給与 FROM 社員 WHERE 部署ID = 外側.部署ID)`

  * **解説**：内側が**複数行**になり不適。集約（`AVG`/`MAX`）で1行化が必要。
* **性能感**：相関は行数分だけ内側が回るため**重い/低速**になりがち。等価形（`JOIN`＋`GROUP BY`）で改善可。

---

### 問題9

「**部署ごとの平均給与が30万円以上の部署**」の部署名と平均給与を求める。

```sql
SELECT 部署名, AVG(給与) AS 平均給与
FROM 社員
JOIN 部署 ON 部署.部署ID = 社員.部署ID
【 a 】 部署名
【 b 】 AVG(給与) >= 300000;
```

**【回答】**
`a`: GROUP BY
`b`: HAVING

**【この構文が必要な理由】**
**集計後の条件**は `HAVING`。`WHERE` は集計**前**の行を絞る。役割分担が逆だと論理破綻。

**【構文の解説】**

* 形：`... GROUP BY 集約単位 HAVING 集約結果の条件`
* 役割：`GROUP BY` で単位を作り、`HAVING` で**集計結果**をフィルタ。
* 評価順注記：**FROM→WHERE→GROUP BY→HAVING→SELECT**（WHEREは前処理、HAVINGは後処理）。

**【初心者が陥りがちな誤解や誤答例】**

* **誤答**：`WHERE AVG(給与) >= 300000`

  * **解説**：`WHERE` では集約関数は使えない（まだ集計していない）。
* **性能感**：前段の `WHERE` で母集団を減らせるなら**高速化**。適切な索引（`社員(部署ID, 給与)`）。

---

### 問題10

「**2025年9月に一度でも売れた商品**」の**全倉庫在庫合計**を出す。内側のキー重複を抑えて効率化したい。

```sql
SELECT 在庫.商品コード, SUM(在庫.在庫数) AS 在庫合計
FROM 在庫
WHERE 在庫.商品コード IN (
  SELECT 【 a 】 商品コード
  FROM 注文
  JOIN 注文明細 ON 注文明細.注文ID = 注文.注文ID
  WHERE 注文.注文日 >= DATE '2025-09-01'
    AND 注文.注文日 <  DATE '2025-10-01'
)
GROUP BY 在庫.商品コード;
```

**【回答】**
`a`: DISTINCT

**【この構文が必要な理由】**
`IN` は重複に強いが、内側の結果を `DISTINCT` で**最小化**するとヒット検査が**軽い/高速**になりやすい（実装依存）。

**【構文の解説】**

* 形：`IN (SELECT DISTINCT キー FROM ... WHERE 条件)`
* 役割：**キー集合**を先に確定（非相関）→外側で合計。
* 評価順注記：内側WHEREで月を確定→`DISTINCT` でキー縮約→外側WHERE→外側GROUP BY。

**【初心者が陥りがちな誤解や誤答例】**

* **誤解**：`DISTINCT` は常に不要

  * **解説**：論理的には不要でも、物理的には**重複削減**がプラン最適化に効く場合がある。
* **代案**：`EXISTS` への等価変形（半結合）でも**高速**になることが多い。

---

## 補助メモ（検算テンプレ：頭の中で常に往復）

* `t.key IN (SELECT key FROM S WHERE 条件)`
  ⇔ `EXISTS (SELECT 1 FROM S WHERE 条件 AND S.key = t.key)`
* `x > ALL(SELECT y FROM S WHERE 条件)`
  ⇔ `x > (SELECT MAX(y) FROM S WHERE 条件)`
* `x < = ALL(SELECT y FROM S WHERE 条件)`
  ⇔ `x <= (SELECT MIN(y) FROM S WHERE 条件)`
* **評価順**は常に：**FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY**
* **NULL安全原則**：否定は `NOT EXISTS`、やむを得ず `NOT IN` なら**内側で `IS NOT NULL`**





#### 問題1
**【問題】**
営業部門から、「部署ごとに所属する社員が何人いるか」を急ぎで集計してほしいと依頼がありました。社員テーブルから、部署ごとの社員数を算出するためのSQL文です。空欄【 a 】を埋めてください。

```sql
SELECT
    部署名,
    COUNT(社員ID) AS 社員数
FROM
    社員
【 a 】
    部署名;
```

**【回答】**
`a`: `GROUP BY`

**【この構文が必要な理由】**
「部署ごと」のように、特定の項目（ここでは部署名）でデータをグループにまとめて、そのグループ単位で件数や合計などの集計処理を行うために `GROUP BY` 句が必要です。

**【構文の解説】**
`GROUP BY 列名;`
`SELECT`文で取得した結果を、指定した列の値が同じデータ同士でグループ化します。`COUNT()` や `SUM()` などの集約関数と組み合わせて使用するのが一般的です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `SELECT`句に集計関数ではない列（この問題では `部署名`）を指定したにもかかわらず、`GROUP BY`句を書き忘れてしまう。
*   **解説**: ほとんどのデータベースでは、`SELECT`句に集計関数とそれ以外の列を一緒に記述する場合、その「それ以外の列」は必ず `GROUP BY` 句で指定しなければならないというルールがあります。これを忘れると、「集計キーが指定されていない」といった内容のエラーが発生します。

---

#### 問題2
**【問題】**
人事部から、部署ごとの平均給与を算出し、その中でも特に「平均給与が400万円以上の部署」だけをリストアップしてほしい、という分析依頼がありました。空欄【 a 】を埋めてください。

```sql
SELECT
    部署名,
    AVG(給与) AS 平均給与
FROM
    社員
GROUP BY
    部署名
【 a 】
    AVG(給与) >= 4000000;
```

**【回答】**
`a`: `HAVING`

**【この構文が必要な理由】**
「部署ごとに集計した後、その集計結果に対して条件を適用する」ために `HAVING` 句が必要です。`WHERE`句は集計前の個々の行に条件を適用しますが、`HAVING`句は `GROUP BY` で集約された後のグループに対して条件を適用します。

**【構文の解説】**
`HAVING 集計関数を用いた条件式;`
`GROUP BY` 句の後ろに記述し、集計結果を絞り込むための条件を指定します。`WHERE`句では `AVG()` のような集計関数を条件に使うことはできません。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WHERE AVG(給与) >= 4000000` のように、集計結果の条件を `WHERE` 句に書いてしまう。
*   **解説**: SQLが処理される順序として、`WHERE`句による絞り込みは `GROUP BY` による集計よりも先に行われます。そのため、`WHERE`句の時点ではまだ `AVG(給与)` という集計値は計算されておらず、条件として使用できないためエラーになります。集計後の絞り込みは `HAVING` の役割です。

---


#### 問題3
**【問題】**
マーケティング部で、関東地方（東京、神奈川、千葉）の店舗における売上上位の担当者を分析することになりました。まず関東の売上データを抽出し、その結果から担当者ごとの売上合計を算出します。以下の`FROM`句サブクエリを使ったSQLは長くて読みにくいため、書き直してください。空欄【 a 】と【 b 】を埋めてください。

```sql
【 a 】 関東売上 AS (
    SELECT
        担当者ID,
        金額
    FROM
        売上明細
    WHERE
        店舗所在地 IN ('東京', '神奈川', '千葉')
)
SELECT
    担当者名,
    SUM(金額) AS 売上合計
FROM
    関東売上
【 b 】
    社員 ON 関東売上.担当者ID = 社員.社員ID
GROUP BY
    担当者名;
```

**【回答】**
`a`: `WITH`
`b`: `INNER JOIN`

**【この構文が必要な理由】**
複雑なSQLを複数のステップに分割し、それぞれに名前を付けて管理するために `WITH`句（共通テーブル式: CTE）が必要です。これにより、SQL文全体の見通しが良くなり、可読性とメンテナンス性が劇的に向上します。

**【構文の解説】**
`WITH 別名 AS (SELECT文) SELECT ... FROM 別名;`
`SELECT`文の前に `WITH`句を定義します。`WITH`句の中で定義した「一時的な結果セット（ここでは `関東売上`）」は、後の `SELECT`文から通常のテーブルのように参照できます。複数のCTEをカンマで区切って定義することも可能です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WITH`句で定義したCTEを、全く別のSQL文から参照しようとする。
*   **解説**: CTEの有効範囲は、それが定義された一つのSQL文の中だけです。CTEは一時的なものであり、データベースに永続的に保存されるテーブルやビューとは異なります。

---

#### 問題4
**【問題】**
人事部から、「各部署内で、給与が高い順に社員のランキングを付けたい」という依頼がありました。`GROUP BY`では集計されてしまい個々の社員情報が消えてしまいます。個々の社員情報を残したまま、グループ内での順位を計算するSQLです。空欄【 a 】と【 b 】を埋めてください。

```sql
SELECT
    社員名,
    部署名,
    給与,
    【 a 】() OVER (【 b 】 部署名 ORDER BY 給与 DESC) AS 部署内順位
FROM
    社員;
```
**【回答】**
`a`: `RANK`
`b`: `PARTITION BY`

**【この構文が必要な理由】**
全体の集計ではなく、「グループごと」の集計や順位付けを行いつつ、元の行の情報を保持するためにウィンドウ関数が必要です。`PARTITION BY`でグループ分けの基準を、`ORDER BY`で順位付けの基準を指定します。

**【構文の解説】**
`関数() OVER (PARTITION BY グループ化する列 ORDER BY 順位付けの列)`
`PARTITION BY`は、データを指定した列の値に基づいて小さな窓（ウィンドウ）に分割する役割を果たします。`RANK()`関数はその窓の中で順位を計算します。`GROUP BY`と異なり、元の行を一つにまとめることなく処理できるのが最大の特徴です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `RANK()`と`DENSE_RANK()`の違いを理解せず、何となく使ってしまう。
*   **解説**: 同順位があった場合、その次の順位の扱いが異なります。例えば、2位が2人いた場合、`RANK()`の次の順位は4位になりますが（3位は欠番）、`DENSE_RANK()`の次の順位は3位となり、順位が詰まります。要件に応じて正しく使い分ける必要があります。

---

#### 問題5
**【問題】**
経営分析チームが、月次の売上トレンドを分析しています。「各月の売上と、その前月の売上を並べて表示し、前月比を計算したい」という要望がありました。自己結合を使わなくても、ウィンドウ関数でスマートに実現できます。空欄【 a 】を埋めてください。

```sql
SELECT
    売上月,
    月次売上,
    【 a 】(月次売上, 1) OVER (ORDER BY 売上月) AS 前月売上
FROM
    月次売上サマリ;
```

**【回答】】**
`a`: `LAG`

**【この構文が必要な理由】**
現在の行を基準として、それより「前」または「後」の行のデータを直接参照するために `LAG`（前）や `LEAD`（後）といったウィンドウ関数が必要です。これにより、複雑な自己結合やサブクエリなしで、時系列データの前後の値との比較が簡単に行えます。

**【構文の解説】**
`LAG(参照したい列, ずらす行数, [NULLの場合のデフォルト値]) OVER (ORDER BY 並び順)`
`ORDER BY`で指定された順序に基づき、現在の行から指定した行数だけ前の行のデータを取得します。このSQLでは、売上月で並べた上で1つ前の行（`LAG(月次売上, 1)`）の`月次売上`を取得しています。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `OVER`句の中に`ORDER BY`を書き忘れる。
*   **解説**: `LAG`や`LEAD`関数にとって、「何順で並べた上での前/後なのか」という基準は不可欠です。`ORDER BY`を省略すると、データベースはどの行が「前」なのか判断できず、エラーになります。

---

#### 問題6
**【問題】**
休眠顧客を把握するため、顧客マスタに登録はされているものの、「一度も注文をしたことがない顧客」を特定する必要があります。空欄【 a 】を埋めてください。

```sql
SELECT
    C.顧客名
FROM
    顧客マスタ AS C
WHERE
    【 a 】 (SELECT 1 FROM 注文 AS O WHERE O.顧客ID = C.顧客ID);
```

**【回答】】**
`a`: `NOT EXISTS`

**【この構文が必要な理由】**
ある条件に一致するデータが、別のテーブル（サブクエリ内）に「一件も存在しないこと」を確認するために `NOT EXISTS` 演算子が必要です。これにより、「注文履歴がない」という条件を効率的に判定できます。

**【構文の解説】**
`WHERE NOT EXISTS (サブクエリ)`
サブクエリが1行も結果を返さない場合に `TRUE` となり、条件を満たすと判定されます。`NOT IN`と異なり、サブクエリ内の `NULL` の影響を受けないため、より安全で確実な方法とされています。

---

#### 問題7
**【問題】**
問題6と同じく、「一度も注文をしたことがない顧客」を特定します。今度はテーブルを外部結合し、データが存在しないことを利用するアプローチです。空欄【 a 】と【 b 】を埋めてください。

```sql
SELECT
    C.顧客名
FROM
    顧客マスタ AS C
【 a 】
    注文 AS O ON C.顧客ID = O.顧客ID
WHERE
    O.注文ID IS 【 b 】;
```

**【回答】】**
`a`: `LEFT JOIN`
`b`: `NULL`

**【この構文が必要な理由】**
`LEFT JOIN` を使うと、基準となる左側のテーブル（顧客マスタ）のデータはすべて残り、右側のテーブル（注文）に対応するデータがない場合はその列が `NULL` になります。この性質を利用し、「注文IDが `NULL` であること」を条件に絞り込むことで、注文履歴のない顧客を抽出できます。

**【2つのアプローチの比較】**
*   **`NOT EXISTS`（問題6）**: 「存在チェック」の意図が明確で、可読性が高いと考える人もいます。一般的にパフォーマンスが良い傾向があります。
*   **`LEFT JOIN ... IS NULL`（問題7）**: 結合結果をイメージしやすく直感的です。顧客情報だけでなく、他の結合したテーブルの情報も `SELECT`句で利用したい場合に拡張しやすいという利点があります。

**応用情報技術者試験では、このように同じ結果を得るための複数のSQLを理解し、その特性を説明できる能力が問われることがあります。**


---

## 【完全網羅版】応用情報技術者試験対策 SQL最高傑作問題集

#### 問題

**【問題】**
「商品マスタ」テーブルから、2024年4月1日から4月30日までに入荷された商品のうち、商品名に「SQL」というキーワードを含む書籍の情報をすべて抽出してください。

```sql
SELECT
    商品コード,
    商品名,
    価格,
    入荷日
FROM
    商品マスタ
【 a 】
    商品名 【 b 】 '%SQL%'
【 c 】
    入荷日 【 d 】 '2024-04-01' AND '2024-04-30';
```

**【回答】**
`a`: WHERE
`b`: LIKE
`c`: AND
`d`: BETWEEN

**【この構文が必要な理由】**
膨大なデータの中から、特定の条件（文字列の部分一致、期間範囲）を満たすレコードだけを効率的に探し出すために、`WHERE`句とその中で使われる`LIKE`演算子や`BETWEEN`演算子はデータ検索の基本かつ最重要の構文です。

**【構文の解説】**
*   `WHERE 句`: `FROM`句で指定したテーブルから、条件に合致する行のみを抽出します。
*   `LIKE 演算子`: 文字列の部分一致検索を行います。`%`は0文字以上の任意の文字列、`_`は任意の1文字を表すワイルドカードです。
*   `BETWEEN A AND B`: AからBまでの範囲内（AとBを含む）にある値を抽出します。日付や数値の範囲指定に用いられます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WHERE 入荷日 >= '2024-04-01' AND 入荷日 < '2024-05-01'` のように、`BETWEEN`を使わずに比較演算子で範囲を指定しようとする。
*   **解説**: この書き方でも正しい結果が得られますが、`BETWEEN`を使うことで「期間内」という意図がより明確になり、クエリの可読性が向上します。ただし、`BETWEEN`は境界値を含む（以上/以下）点に注意が必要です。応用情報技術者試験では、業務要件を正確にSQLへ落とし込む能力が問われます。

---

#### 問題

**【問題】**
ある社員（社員ID: 'S010'）が営業部に異動し、基本給が300,000円に昇給しました。この情報を「社員」テーブルに反映させてください。また、その後、退職した社員（社員ID: 'S003'）のデータをテーブルから削除する必要が出てきました。

```sql
-- ① 異動と昇給の反映
【 a 】 社員
【 b 】 部署コード = 'D03', 基本給 = 300000
【 c 】 社員ID = 'S010';

-- ② 退職者データの削除
【 d 】 FROM 社員
【 c 】 社員ID = 'S003';
```

**【回答】**
`a`: UPDATE
`b`: SET
`c`: WHERE
`d`: DELETE

**【この構文が必要な理由】**
`UPDATE`は既存データの値を変更し、`DELETE`は既存の行を削除するために不可欠な命令です。これらの操作で最も重要なのは`WHERE`句であり、処理対象を正確に特定しないと、意図しないデータ破壊を引き起こす危険があります。

**【構文の解説】**
*   `UPDATE テーブル名 SET 列 = 値 WHERE 条件;`: 条件に一致する行の指定された列の値を更新します。
*   `DELETE FROM テーブル名 WHERE 条件;`: 条件に一致する行を削除します。
*   **重要**: `UPDATE`と`DELETE`において`WHERE`句を省略すると、テーブルの**全行**が対象となります。これは致命的な操作ミスに繋がるため、実行前には必ず`SELECT`文で対象行を確認することが鉄則です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 他のテーブルのデータを使って更新したい場合に、どうすればいいかわからない（相関副問合せUPDATE）。
*   **解説**: 例えば、「各社員の基本給を、所属部署の平均基本給に更新する」といった高度な更新には `UPDATE 社員 S SET 基本給 = (SELECT AVG(基本給) FROM 社員 S2 WHERE S2.部署コード = S.部署コード)` のように、`SET`句や`WHERE`句の中で相関副問合せを使います。このテクニックは応用情報技術者試験の難問で出題される可能性があります。

---

#### 問題

**【問題】**
「社員」テーブルと「部署」テーブルがあります。以下の4つの要件でデータを取得する場合、それぞれどの結合方法が適切ですか？
1.  部署に所属している社員とその部署名の一覧
2.  **すべての**社員と、もし所属していればその部署名の一覧
3.  **すべての**部署と、もし所属していればその社員の一覧
4.  社員と部署の全組み合わせ（所属有無に関わらず）を表示

```sql
-- 要件2: 全ての社員を表示
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 a 】 部署 AS D ON S.部署コード = D.部署コード;

-- 要件3: 全ての部署を表示
SELECT S.氏名, D.部署名 FROM 社員 AS S 【 b 】 部署 AS D ON S.部署コード = D.部署コード;
```
*(`INNER JOIN`と`FULL OUTER JOIN`は空欄から省略)*

**【回答】**
`a`: LEFT JOIN (または LEFT OUTER JOIN)
`b`: RIGHT JOIN (または RIGHT OUTER JOIN)

**【この構文が必要な理由】**
業務要件に応じて、2つのテーブルの関係性をどのように表現するかが変わります。`INNER JOIN`は関連があるデータのみ、`LEFT/RIGHT JOIN`は片方のテーブルを軸に、`FULL OUTER JOIN`は両方のテーブルの全データを軸に結合するため、これらの適切な使い分けは必須のスキルです。

**【構文の解説】**
*   `INNER JOIN` (要件1): 両テーブルに共通のキーが存在するデータのみを結合。
*   `LEFT JOIN` (要件2): 左テーブル（`社員`）の全データを表示し、右テーブル（`部署`）に一致データがあれば結合、なければ`NULL`。
*   `RIGHT JOIN` (要件3): 右テーブル（`部署`）の全データを表示し、左テーブル（`社員`）に一致データがあれば結合、なければ`NULL`。
*   `FULL OUTER JOIN` (要件4): 両テーブルの全データを表示し、片方にしか存在しないデータはもう片方を`NULL`として結合。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `LEFT JOIN`と`RIGHT JOIN`はテーブルの記述順を入れ替えれば同じなので、`LEFT JOIN`だけ覚えればよいと考えてしまう。
*   **解説**: 理論的にはその通りですが、SQLでは主軸となる情報を左側に置く`LEFT JOIN`が好まれる傾向にあり、可読性が高まります。しかし、既存の複雑なクエリを修正する際など、`RIGHT JOIN`のままの方が変更箇所が少なく済む場合もあります。応用情報技術者試験では、どちらの結合も読んで理解できる必要があります。

---

#### 問題

**【問題】**
「売上明細」テーブルから、商品カテゴリごとに売上合計金額を計算し、その**合計金額が50万円を超えているカテゴリ**のみを抽出してください。

```sql
SELECT
    カテゴリ,
    SUM(単価 * 数量) AS 売上合計
FROM
    売上明細
【 a 】
    カテゴリ
【 b 】
    SUM(単価 * 数量) > 500000;
```

**【回答】**
`a`: GROUP BY
`b`: HAVING

**【この構文が必要な理由】**
`GROUP BY`でデータを特定の単位（カテゴリ）で集約し、その集計結果（売上合計）に対して条件を適用するために`HAVING`句が必要です。`WHERE`句は集計前の個々の行をフィルタリングするのに対し、`HAVING`句は集計後のグループをフィルタリングするという役割の違いを理解することが極めて重要です。

**【構文の解説】**
SQLの論理的な処理順序は `FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` です。この流れを意識すると、`WHERE`句で集計関数 (`SUM`など) が使えず、`HAVING`句で使う理由が明確に理解できます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `SELECT`句に書いた列のエイリアスを`GROUP BY`句や`HAVING`句で使おうとしてエラーになる。（例: `HAVING 売上合計 > 500000`）
*   **解説**: SQLの処理順序上、`SELECT`句で付けられた別名は`GROUP BY`や`HAVING`の処理段階ではまだ認識されていません。そのため、`HAVING`句では`SUM(単価 * 数量)`のように集計関数そのものを記述する必要があります。このルールは多くのデータベースシステムで共通しており、試験でも問われる可能性があります。

---



#### 問題

**【問題】**
「社員」テーブルから社員一覧を出す際に、`備考`列が`NULL`の場合は「特記事項なし」と表示し、かつ`役職コード`に応じて役職名を日本語で表示したい（'MGR'なら「部長職」、'TL'なら「チームリーダー」、それ以外は「一般職」）。

```sql
SELECT
    氏名,
    【 a 】 役職コード
        WHEN 'MGR' THEN '部長職'
        WHEN 'TL'  THEN 'チームリーダー'
        【 b 】 '一般職'
    【 c 】 AS 役職名,
    【 d 】(備考, '特記事項なし') AS 備考欄
FROM
    社員;
```

**【回答】**
`a`: CASE
`b`: ELSE
`c`: END
`d`: COALESCE

**【この構文が必要な理由】**
`CASE`式は、SQL内で条件分岐ロジックを実現し、データを変換・分類するために不可欠です。`COALESCE`関数は、`NULL`値を別の値に置き換えるためのシンプルで強力な方法であり、表示や計算で`NULL`が原因となる問題を回避するために頻繁に使用されます。

**【構文の解説】**
*   `CASE WHEN 条件 THEN 値 ... ELSE 値 END`: 一連の条件を評価し、最初に真となった条件に対応する値を返します。
*   `COALESCE(値1, 値2, ...)`: 引数リストの中で最初に見つかった`NULL`でない値を返します。`IFNULL`や`NVL`といった各DBMS固有の関数の標準SQL版です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `CASE`式で`ELSE`句を省略してしまう。
*   **解説**: `ELSE`句を省略した場合、どの`WHEN`条件にも一致しない行は`NULL`が返されます。これが意図した動作であれば問題ありませんが、意図せず`NULL`が生まれると後続の計算に影響を与える可能性があります。必ずデフォルトの値を`ELSE`で指定する癖をつけることが堅牢なクエリ作成に繋がります。

---
#### 問題

**【問題】**
一度でも商品を購入したことがある顧客の情報だけを「顧客マスタ」から抽出したい。また、逆に、まだ一度も購入履歴がない顧客を抽出したい。

```sql
-- ① 購入履歴のある顧客
SELECT 氏名 FROM 顧客マスタ AS C
WHERE 【 a 】 (SELECT 1 FROM 購入履歴 AS H WHERE H.顧客ID = C.顧客ID);

-- ② 購入履歴のない顧客
SELECT 氏名 FROM 顧客マスタ AS C
WHERE 【 b 】 (SELECT 1 FROM 購入履歴 AS H WHERE H.顧客ID = C.顧客ID);
```
**【回答】**
`a`: EXISTS
`b`: NOT EXISTS

**【この構文が必要な理由】**
`EXISTS`は「関連データが一件でも存在するか」という事実だけを確認したい場合に、最も効率的な手段です。副問合せの結果をすべて取得して比較する`IN`句と異なり、`EXISTS`は該当データが一件見つかった時点で評価を打ち切るため、特に副問合せの対象テーブルが大きい場合にパフォーマンスが向上します。

**【構文の解説】**
*   `EXISTS (相関副問合せ)`: 副問合せが1行でも結果を返せば真 (TRUE) となります。
*   `NOT EXISTS (相関副問合せ)`: 副問合せが1行も結果を返さなければ真 (TRUE) となります。
*   **相関副問合せ**: 副問合せの中から主問合せのテーブル（`C.顧客ID`）を参照する形式。主問合せの行ごとに副問合せが実行されるイメージです。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `NOT IN (SELECT 顧客ID FROM 購入履歴)` を使って購入履歴のない顧客を抽出しようとする。
*   **解説**: これは非常に有名な「`NOT IN`と`NULL`の罠」です。もし`購入履歴`テーブルの`顧客ID`列に一件でも`NULL`が含まれていると、`NOT IN (..., NULL, ...)` の評価結果が常に`UNKNOWN`（偽）となり、最終的な結果が**一件も返らなく**なります。一方、`NOT EXISTS`はこの`NULL`問題の影響を受けません。そのため、応用情報技術者試験では、データの欠損を考慮した堅牢な構文として`NOT EXISTS`を選択できるかが問われます。

---
#### 問題

**【問題】**
各部署の売上合計と全社平均売上を比較するレポートを作成したい。まず部署ごとの売上合計を計算し、その結果を使って最終的なレポートを出力するという、段階的な処理を分かりやすく記述してください。

```sql
【 a 】
部署別売上 (部署コード, 合計売上) AS (
    SELECT 部署コード, SUM(売上額)
    FROM 売上実績
    GROUP BY 部署コード
),
全社平均 (平均売上) AS (
    SELECT AVG(売上額) FROM 売上実績
)
SELECT
    D.部署名,
    B.合計売上,
    A.平均売上
FROM
    部署別売上 AS B
JOIN 部署マスタ AS D ON B.部署コード = D.部署コード
CROSS JOIN 全社平均 AS A;
```
**【回答】**
`a`: WITH

**【この構文が必要な理由】**
`WITH`句（共通表式: Common Table Expression, CTE）は、複雑なSQLを論理的なパーツに分割し、それぞれに名前を付けることで、クエリ全体の可読性と再利用性を劇的に向上させます。長い副問合せ（インラインビュー）の入れ子構造を解消し、処理の流れを上から下へ自然に追えるようにします。

**【構文の解説】**
`WITH CTE名1 AS (SELECT文1), CTE名2 AS (SELECT文2) ...` の形式で、メインの`SELECT`文の前に一時的な名前付き結果セットを複数定義できます。定義したCTEは、後続のクエリで通常のテーブルのように扱うことができます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: すべての副問合せを`WITH`句に書き出すべきだと考えてしまう。
*   **解説**: `WITH`句は可読性を高めますが、非常に単純な副問合せ（例: `SELECT`句内のスカラ副問合せ）まで`WITH`句にすると、かえって記述が冗長になることもあります。`WITH`句は、①複数回参照される副問合せ、②それ自体が複雑なロジックを持つ副問合せ、を切り出す際に特に効果を発揮します。応用情報技術者試験では、保守性の高いコードを書く意識が評価されます。

---



#### 問題

**【問題】**
運用中の「社員」テーブルに、新しく`メールアドレス`列を追加する必要が出てきました。この列には重複した値を許可しないようにしたい。また、個人情報保護のため、人事部のユーザにのみ基本給情報を公開し、他のユーザには氏名と部署名だけを閲覧できる`社員公開ビュー`を提供したい。

```sql
-- ① 列の追加と制約の付与
【 a 】 社員
【 b 】 メールアドレス VARCHAR(255) 【 c 】;

-- ② ビューの作成
【 d 】 社員公開ビュー AS
SELECT
    氏名,
    部署名
FROM
    社員 S
INNER JOIN
    部署 D ON S.部署コード = D.部署コード;
```

**【回答】**
`a`: ALTER TABLE
`b`: ADD COLUMN
`c`: UNIQUE
`d`: CREATE VIEW

**【この構文が必要な理由】**
`ALTER TABLE`は、ビジネス要件の変更に伴い、稼働中のデータベースの構造を柔軟に変更するために必要です。`CREATE VIEW`は、複雑なクエリを単純化したり、元テーブルへのアクセスを制限してセキュリティを向上させたりするための強力な仮想テーブル機能です。

**【構文の解説】**
*   `ALTER TABLE テーブル名 ADD COLUMN 列定義 [制約];`: 既存のテーブルに新しい列を追加します。
*   `UNIQUE制約`: 列内の値の重複を許しませんが、`NULL`は複数許容される場合があります（DBMSによる）。主キー(`PRIMARY KEY`)もユニークですが、`NULL`を許可しない点が異なります。
*   `CREATE VIEW ビュー名 AS SELECT文;`: `SELECT`文の結果を名前付きのオブジェクト（ビュー）として保存します。ビューに対してクエリを実行すると、裏で定義された`SELECT`文が実行されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: ビューは単なるクエリのショートカットであり、ビューに権限を与えれば元テーブルにもアクセスできると考えてしまう。
*   **解説**: ビューへの権限と、そのビューが参照している実テーブル（ベーステーブル）への権限は独立しています。ユーザにビューへの`SELECT`権限だけを与え、実テーブルへの権限を与えなければ、ユーザはビューで定義された範囲のデータしか見ることができません。これは「最小権限の原則」を実践する上で非常に重要なセキュリティ機能です。

---

#### 問題

**【問題】**
新入社員のユーザ`'user_trainee'`を作成しました。このユーザに、前問で作成した`社員公開ビュー`に対する参照（`SELECT`）権限を与えたい。その後、このユーザが研修を終えたため、その権限を剥奪する必要が出てきました。

```sql
-- ① 権限の付与
【 a 】 SELECT
【 b 】 社員公開ビュー
【 c 】 'user_trainee';

-- ② 権限の剥奪
【 d 】 SELECT
【 b 】 社員公開ビュー
FROM 'user_trainee';
```
**【回答】**
`a`: GRANT
`b`: ON
`c`: TO
`d`: REVOKE

**【この構文が必要な理由】**
`GRANT`と`REVOKE`は、データベースのセキュリティを管理する中心的な命令（DCL: Data Control Language）です。誰がどのデータに対して何をできるのかを厳密に制御し、不正なアクセスや意図しないデータ改ざんからシステムを保護するために不可欠です。

**【構文の解説】**
*   `GRANT 権限 ON オブジェクト TO ユーザ;`: ユーザにオブジェクト（テーブル、ビューなど）に対する操作権限（`SELECT`, `INSERT`, `UPDATE`など）を与えます。
*   `REVOKE 権限 ON オブジェクト FROM ユーザ;`: ユーザから指定した権限を剥奪します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 管理を楽にするために、非常に強い権限（例: すべてのテーブルに対する全操作権限）を一般ユーザに与えてしまう。
*   **解説**: これはセキュリティ上、最も避けるべき過ちです。「最小権限の原則」に基づき、ユーザには業務を遂行するために必要最低限の権限のみを付与するべきです。応用情報技術者試験では、データベースの運用管理やセキュリティに関する知識も問われるため、DCLの役割を正しく理解しておくことが重要です。

---

### 問題
**シナリオ**: あなたは人事データベースを担当しています。上司から「特定の社員（社員ID 'E005'）が所属する部署と、その部署より上位の階層にある部署をすべてリストアップしてほしい」と依頼されました。

社員テーブルと部署テーブルを使い、社員 'E005' が所属する「開発2部」からルートの「社長室」まで、階層を遡って表示する必要があります。このような親子関係を持つデータを再帰的に検索するには、どのSQL構文を使えばよいでしょうか。

```sql
【 a 】 部署階層(部署ID, 部署名, 上位部署ID) AS (
  -- 再帰の起点（アンカーメンバー）
  SELECT 部署ID, 部署名, 上位部署ID FROM 部署マスタ
  WHERE 部署ID = (SELECT 所属部署ID FROM 社員 WHERE 社員ID = 'E005')
  
  【 b 】
  
  -- 前の結果を使って再帰的に検索（再帰メンバー）
  SELECT D.部署ID, D.部署名, D.上位部署ID
  FROM 部署マスタ D
  JOIN 部署階層 H ON D.部署ID = H.上位部署ID
)
SELECT 部署名 FROM 部署階層;

```
**【回答】**
`a`: `WITH RECURSIVE`
`b`: `UNION ALL`
**【この構文が必要な理由】**
組織図のような階層構造を持つデータに対して、ある地点から最上位（または最下位）までの全階層を一度のクエリで取得する必要があるため、自己参照を繰り返す再帰的な問い合わせ構文が不可欠です。

**【構文の解説】**
`WITH RECURSIVE <CTE名>(<列リスト>) AS ( <アンカーメンバー> UNION ALL <再帰メンバー> ) SELECT ... FROM <CTE名>;`
*   `WITH RECURSIVE`: 以降で再帰的な共通テーブル式（CTE: Common Table Expression）を定義することを宣言します。
*   **アンカーメンバー**: 再帰検索の開始点となる最初の`SELECT`文です。
*   `UNION ALL`: アンカーメンバーの結果と、後続の再帰メンバーの結果を結合します。再帰処理では重複を気にする必要がないケースが多いため、パフォーマンス上有利な`UNION ALL`が主に使われます。
*   **再帰メンバー**: 直前の`SELECT`文の結果（この例では`部署階層`）を参照して、次の階層のデータを取得します。この処理が結果を返さなくなるまで繰り返されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `JOIN`を何度も繰り返せば同じことができると考えてしまう。
*   **解説**: 階層の深さが事前に分かっている（例：3階層固定）場合は、自己結合（`JOIN`）を繰り返すことでも実現可能です。しかし、階層の深さが可変であったり、不定である場合には対応できません。`WITH RECURSIVE`は、階層の深さに関わらず、終点に達するまで自動的に検索を繰り返してくれる点で根本的に異なります。

---

### 問題
**シナリオ**: 社員の勤怠情報を管理するシステムで、各社員の氏名とその所属部署名を並べて表示する一覧表を作成する必要があります。社員の情報は「社員」テーブルに、部署の情報は「部署マスタ」に格納されています。

これら2つのテーブルを「部署ID」で紐付けて、両方のテーブルに存在するデータだけを正しく組み合わせるには、どの結合方法を選択すればよいでしょうか。

```sql
SELECT
  S.氏名,
  D.部署名
FROM
  社員 S
【 a 】
  部署マスタ D
【 b 】
  S.所属部署ID = D.部署ID;
```
**【回答】**
`a`: `INNER JOIN`
`b`: `ON`
**【この構文が必要な理由】**
社員データと部署データを、関連性のある情報（この場合は部署ID）に基づいて1つの結果セットにまとめる必要があるためです。`INNER JOIN`は、両方のテーブルに共通のキーを持つ行だけを結合する最も基本的な方法です。

**【構文の解説】**
`SELECT ... FROM <テーブル1> INNER JOIN <テーブル2> ON <結合条件>;`
*   `INNER JOIN`: 内部結合を指示する句です。2つのテーブルを指定された条件で結合し、条件に一致する行のみを返します。
*   `ON`: 結合するテーブル間で、どの列をキーとして関連付けるかを指定する句です。`ON`句で指定された条件が`TRUE`になる行の組み合わせが結果として返されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WHERE`句で結合条件を書く古い方法（`FROM 社員 S, 部署マスタ D WHERE S.所属部署ID = D.部署ID;`）と何が違うのかわからない。
*   **解説**: 結果は同じになりますが、`JOIN`句と`ON`句を使うことで、「テーブルの結合条件」と「データの絞り込み条件（`WHERE`句）」を明確に分離できます。これにより、SQL文が長くなったときに可読性が大幅に向上し、意図しない結合（デカルト積）を避けることにも繋がります。応用情報技術者試験では`INNER JOIN ... ON ...`の形式が標準です。

---

### 問題
**シナリオ**: 全社員の一覧を作成するにあたり、まだどの部署にも正式配属されていない研修中の社員（所属部署IDが`NULL`）もリストに含める必要があります。社員テーブルを主軸として、部署名も合わせて表示するには、どの結合方法が適切でしょうか。

```sql
SELECT
  S.氏名,
  D.部署名
FROM
  社員 S
【 a 】
  部署マスタ D
ON
  S.所属部署ID = D.部署ID;

```
**【回答】**
`a`: `LEFT OUTER JOIN`
**【この構文が必要な理由】**
「社員」という主軸となるテーブルのデータはすべて表示し、それに関連する「部署」の情報があれば表示し、なければ`NULL`としてでも表示したい、という要件を満たす必要があるためです。

**【構文の解説】**
`SELECT ... FROM <左テーブル> LEFT OUTER JOIN <右テーブル> ON <結合条件>;`
*   `LEFT OUTER JOIN` (または `LEFT JOIN`): 左外部結合を指示する句です。`FROM`句の直後に書かれたテーブル（左テーブル）の行をすべて残し、`ON`句の条件に一致する右テーブルの行を結合します。一致する行が右テーブルにない場合は、右テーブルの列は`NULL`として表示されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `INNER JOIN`を使ってしまう。
*   **解説**: `INNER JOIN`を使うと、両方のテーブルに結合キー（この場合は部署ID）が存在するレコード、つまり、いずれかの部署に所属している社員しか抽出されません。要件である「まだ配属されていない社員もリストに含める」を満たせず、データが欠落してしまいます。「～を基準に」「～はすべて表示して」といった要件がある場合は、`OUTER JOIN`を疑う必要があります。

---

### 問題
**シナリオ**: アパレルECサイトで、取り扱う全ての色（`色マスタ`テーブル）と全てのサイズ（`サイズマスタ`テーブル）の組み合わせを網羅した商品マスタの雛形を一度に生成したい、という要望がありました。考えられるすべての組み合わせ（デカルト積）を作成するには、どの結合方法を使用しますか。

```sql
SELECT
  C.色名,
  S.サイズ名
FROM
  色マスタ C
【 a 】
  サイズマスタ S;
```
**【回答】**
`a`: `CROSS JOIN`
**【この構文が必要な理由】**
2つのテーブル間に直接的な関連（キー）は無いものの、それぞれのテーブルの全レコードを総当たりで組み合わせて、考えられるすべてのパターンのリストを作成する必要があるためです。

**【構文の解説】**
`SELECT ... FROM <テーブル1> CROSS JOIN <テーブル2>;`
*   `CROSS JOIN`: 交差結合（またはデカルト積）を行うための句です。テーブル1の各行に対して、テーブル2のすべての行を組み合わせた結果を返します。通常、`ON`句による結合条件は指定しません。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `FROM 色マスタ, サイズマスタ` のようにカンマでテーブルを区切って記述してしまう。
*   **解説**: このカンマ区切りの記法でも多くのデータベースで`CROSS JOIN`と同じ結果が得られますが、これは古いANSI SQL-89標準の書き方です。ANSI SQL-92以降では`CROSS JOIN`というキーワードで明示的に意図を示すことが推奨されています。また、`INNER JOIN`のつもりで`WHERE`句の結合条件を書き忘れると、意図せず`CROSS JOIN`となり、膨大な数のレコードが生成されてシステムに負荷をかける原因となるため、結合の種類を明示することが重要です。

---

### 問題
**シナリオ**: 「東京本社」と「大阪支社」に勤務する全社員の社員番号を、重複を除いて一つのリストとして表示したいと考えています。それぞれの社員リストを取得する2つの`SELECT`文の結果を、1つに統合するにはどの集合演算子を使えばよいでしょうか。

```sql
SELECT 社員番号 FROM 社員 WHERE 勤務地 = '東京本社'
【 a 】
SELECT 社員番号 FROM 社員 WHERE 勤務地 = '大阪支社';
```
**【回答】**
`a`: `UNION`
**【この構文が必要な理由】**
2つ以上の別々の条件で抽出した結果セットを、1つの結果セットとして縦に連結する必要があるためです。特に、両方の条件に合致するデータ（例：兼務者）が存在する場合でも、結果としては1件として扱いたい（重複を排除したい）という要件を満たします。

**【構文の解説】**
`SELECT ... FROM ... UNION SELECT ... FROM ...;`
*   `UNION`: 2つ以上の`SELECT`文の結果を結合するための集合演算子です。結合する際、自動的に結果セット全体から重複する行を取り除きます。
*   **注意**: `UNION`で結合する各`SELECT`文は、列の数と、対応する列のデータ型が一致している必要があります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: パフォーマンスを考えずに、常に`UNION`を使ってしまう。
*   **解説**: `UNION`は重複を排除するために、内部的にソート処理のような負荷のかかる処理を実行します。もし「重複があっても構わない、単純に結果を連結したいだけ」という要件であれば、重複排除を行わない `UNION ALL` を使うべきです。`UNION ALL`の方が高速に動作するため、要件に応じて適切に使い分けることが重要です。

---

### 問題
**シナリオ**: ECサイトの売上ログを分析しています。4月度の売上履歴（`売上履歴_4月`テーブル）と5月度の売上履歴（`売上履歴_5月`テーブル）を、単純に縦に連結して一つの時系列データとして扱いたいと考えています。この場合、重複チェックは不要です。

このような場合に、2つの`SELECT`文の結果を高速に結合するには、どの集合演算子を使えばよいでしょうか。

```sql
SELECT 注文日, 商品ID, 金額 FROM 売上履歴_4月
【 a 】
SELECT 注文日, 商品ID, 金額 FROM 売上履歴_5月;
```
**【回答】**
`a`: `UNION ALL`
**【この構文が必要な理由】**
複数のテーブルや`SELECT`文の結果を、重複排除の処理を行わずに、そのまま高速に連結したい場合に最適だからです。ログデータのように、もともと重複という概念がない（あるいは重複していても問題ない）データを単純にまとめる際に使用されます。

**【構文の解説】**
`SELECT ... FROM ... UNION ALL SELECT ... FROM ...;`
*   `UNION ALL`: 2つ以上の`SELECT`文の結果を結合するための集合演算子です。`UNION`とは異なり、重複行の排除を行わず、すべての行をそのまま返します。そのため、`UNION`よりも処理負荷が低く、高速に動作します。
*   **注意**: `UNION ALL`で結合する各`SELECT`文も、`UNION`と同様に列の数とデータ型が一致している必要があります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `UNION`と`UNION ALL`は同じものだと思い、`UNION`を使ってしまう。
*   **解説**: 「重複を排除するかしないか」という明確な違いがあります。要件が「ユニークな一覧が欲しい」のであれば`UNION`、「すべてのデータを単純に連結したい」のであれば`UNION ALL`です。今回のシナリオで`UNION`を使うと、もし4月と5月に全く同じ内容（注文日、商品ID、金額）の売上があった場合に、それが1件にまとめられてしまい、正確な売上分析ができなくなる可能性があります。

---

### 問題
**シナリオ**: 商品の売上データを分析し、商品カテゴリごとの売上合計金額を算出することになりました。「売上明細」テーブルと「商品マスタ」テーブルを結合し、`商品カテゴリ`でデータを分類して集計するには、どの句を使用すればよいでしょうか。

```sql
SELECT
  P.商品カテゴリ,
  SUM(S.金額) AS カテゴリ別合計
FROM
  売上明細 S
INNER JOIN
  商品マスタ P ON S.商品ID = P.商品ID
【 a 】 P.商品カテゴリ;
```
**【回答】**
`a`: `GROUP BY`
**【この構文が必要な理由】**
行全体を特定の列（この場合は`商品カテゴリ`）の値に基づいてグループにまとめ、それぞれのグループに対して`SUM()`や`COUNT()`といった集約関数を適用し、要約されたデータを生成する必要があるためです。

**【構文の解説】**
`SELECT <グループ化列>, <集約関数> FROM ... GROUP BY <グループ化列>;`
*   `GROUP BY`: 指定された列の値が同じ行を一つのグループとしてまとめます。
*   `SELECT`句には、`GROUP BY`句で指定した列と、集約関数（`SUM()`, `COUNT()`, `AVG()`, `MAX()`, `MIN()`など）しか記述できません。これは、グループ化によって複数行が1行にまとめられるため、どの行の値を表示すればよいか不定になるからです。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `SELECT`句に、`GROUP BY`で指定していない列（例：`商品名`）を追加してしまう。
*   **解説**: `SELECT P.商品カテゴリ, P.商品名, SUM(S.金額) ... GROUP BY P.商品カテゴリ;` のようなSQLは多くのデータベースでエラーになります。なぜなら、「文房具」というカテゴリに「鉛筆」「消しゴム」があった場合、集計結果の1行に表示すべき`商品名`が特定できないからです。`SELECT`句に集約関数と通常の列を混在させる場合は、そのすべての通常列を`GROUP BY`句に含める必要があります。

---

### 問題
**シナリオ**: 商品カテゴリごとの合計売上金額を算出した後、さらに「合計売上金額が100万円以上のカテゴリだけ」に絞り込んでレポートを作成したいという追加要望がありました。

`GROUP BY`で集約した後の結果に対して条件を指定するには、`WHERE`句ではなく、どの句を使えばよいでしょうか。

```sql
SELECT
  P.商品カテゴリ,
  SUM(S.金額) AS カテゴリ別合計
FROM
  売上明細 S
INNER JOIN
  商品マスタ P ON S.商品ID = P.商品ID
GROUP BY
  P.商品カテゴリ
【 a 】 SUM(S.金額) >= 1000000;
```
**【回答】**
`a`: `HAVING`
**【この構文が必要な理由】**
`WHERE`句がテーブルの個々の行を絞り込むのに対し、`HAVING`句は`GROUP BY`によってグループ化・集約された後の結果セットに対して条件を指定する役割を持つためです。集約関数 (`SUM()`, `COUNT()`など) を使った条件は`HAVING`句にしか書けません。

**【構文の解説】**
`SELECT ... FROM ... WHERE ... GROUP BY ... HAVING <グループに対する条件>;`
*   `HAVING`: `GROUP BY`句で作成されたグループに対して、絞り込み条件を指定します。
*   **評価順序**: SQLの内部的な処理の順序は `FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY` となります。このため、`WHERE`句は集約前のデータに、`HAVING`句は集約後のデータに適用されるという違いが生まれます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `WHERE SUM(S.金額) >= 1000000;` のように、集約関数の条件を`WHERE`句に書いてしまう。
*   **解説**: これは典型的なエラーです。`WHERE`句は、`GROUP BY`でデータが集約される「前」に、1行1行のデータを評価します。そのため、`WHERE`句の時点ではまだ`SUM(S.金額)`という集計値は計算されておらず、条件として使用できません。集計結果に対する絞り込みは、必ず`HAVING`句を使用します。

---

### 問題
**シナリオ**: 社員名簿に、各社員の給与が全社内で何位にあたるのかを示す「給与ランキング」列を追加して表示したいと考えています。`GROUP BY`のように行をまとめることなく、各行に対してランキングを計算するには、どのような関数を使えばよいでしょうか。

```sql
SELECT
  氏名,
  給与,
  RANK() 【 a 】 (ORDER BY 給与 DESC) AS 給与ランキング
FROM
  社員;
```
**【回答】**
`a`: `OVER`
**【この構文が必要な理由】**
個々の行の情報を維持したまま、集団（この場合は全社員）の中での相対的な位置（ランキング）や累積値などを計算する必要があるためです。`GROUP BY`では行が集約されてしまうため、このような計算はできません。

**【構文の解説】**
`<ウィンドウ関数>() OVER (PARTITION BY <分割列> ORDER BY <順序列>)`
*   **ウィンドウ関数**: `RANK()`, `ROW_NUMBER()`, `SUM()`, `AVG()`など、集計を行う関数が使えます。
*   `OVER()`: ウィンドウ関数の計算対象となる行の範囲（ウィンドウ）を指定する句です。
*   `PARTITION BY <分割列>`: (オプション) `GROUP BY`のように、ここで指定した列の値ごとにデータをグループ分けし、そのグループ内でウィンドウ関数の計算を行います。
*   `ORDER BY <順序列>`: ウィンドウ内で、どの列を基準にどのような順序（`ASC`/`DESC`）で計算を行うかを指定します。ランキング計算では必須です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `RANK()`関数を知っていても、`OVER()`句を付け忘れる。
*   **解説**: `RANK()`や`SUM()`といった関数は、`OVER()`句を伴うことで「ウィンドウ関数」として機能します。`OVER()`句がない場合、`SUM()`などは通常の集約関数として扱われ、`GROUP BY`句が必要になります。`OVER()`句は、これらの関数に「どの範囲の行を対象に計算するか」を教える、非常に重要な役割を担っています。

---

### 問題
**シナリオ**: 2024年中に一度でも商品を購入したことがある顧客のリストを作成したいと考えています。「顧客マスタ」に存在する顧客のうち、「売上履歴」テーブルにその顧客の売上データが一件でも「存在する」かどうかを判定して絞り込むには、どの述語が適しているでしょうか。

```sql
SELECT
  顧客名
FROM
  顧客マスタ C
WHERE
【 a 】 (
  SELECT 1 FROM 売上履歴 S
  WHERE S.顧客ID = C.顧客ID AND S.売上日 BETWEEN '2024-01-01' AND '2024-12-31'
);
```
**【回答】**
`a`: `EXISTS`
**【この構文が必要な理由】**
副問合せ（サブクエリ）の結果そのものが必要なわけではなく、単に「条件に合致する行が1件でも存在するかどうか」という事実だけを知りたいからです。`EXISTS`は存在チェックに特化しており、条件に合う行が見つかった時点で検索を打ち切るため、効率的に処理できます。

**【構文の解説】**
`WHERE EXISTS (<副問合せ>)`
*   `EXISTS`: 副問合せを実行し、結果の行が1行でも返されれば`TRUE`、1行も返されなければ`FALSE`を返します。
*   副問合せ内の`SELECT`句には、通常`SELECT *`や`SELECT 1`のように、特定の列を指定する必要がないダミーの値を記述します。これは、`EXISTS`が列の値ではなく、行の「存在」のみを判定するためです。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `IN`を使って `WHERE C.顧客ID IN (SELECT S.顧客ID FROM 売上履歴 S ...)` と書いてしまう。
*   **解説**: `IN`でも同様の結果を得られることが多いですが、パフォーマンスの観点から違いがあります。一般的に、副問合せの結果セットが非常に大きい場合、`EXISTS`の方が効率的であると言われています。`EXISTS`は相関副問合せとして動作し、外側のクエリの行ごとに内側のクエリの存在チェックを行うため、インデックスが効果的に利用されやすいからです。

---

### 問題
**シナリオ**: 特定のキャンペーン対象商品（商品IDが 'A001', 'B005', 'C012' のいずれか）の情報を「商品マスタ」から一度に取得したいと考えています。

`WHERE`句で、ある列の値が指定した複数の値のリストの「中に含まれる」かどうかを判定するには、どの演算子を使えばよいでしょうか。

```sql
SELECT
  商品名,
  単価
FROM
  商品マスタ
WHERE
  商品ID 【 a 】 ('A001', 'B005', 'C012');
```
**【回答】**
`a`: `IN`
**【この構文が必要な理由】**
複数の`OR`条件（`WHERE 商品ID = 'A001' OR 商品ID = 'B005' OR ...`）を記述する代わりに、より簡潔で可読性の高い形で、値の集合との比較を行う必要があるためです。

**【構文の解説】**
`WHERE <列名> IN (<値1>, <値2>, ...)`
*   `IN`: 指定した列の値が、括弧内のリストに含まれるいずれかの値と等しい場合に`TRUE`を返します。
*   括弧内には直接値を列挙するだけでなく、`SELECT`文（副問合せ）を記述して、その結果セットをリストとして使用することも可能です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `NOT IN (副問合せ)` を使用する際に、副問合せの結果に`NULL`が含まれていると意図しない結果になる。
*   **解説**: `WHERE 列名 NOT IN (1, 2, NULL)` のような条件は、`列名 <> 1 AND 列名 <> 2 AND 列名 <> NULL` とほぼ等価に評価されます。SQLでは`NULL`との比較（`<> NULL`）は「不明(UNKNOWN)」となり、結果として全体の条件式が`TRUE`にならないため、1行も返ってこないという現象が起こります。`NOT IN`で副問合せを使う場合は、副問合せ側で`NULL`を返さないように`WHERE ... IS NOT NULL`でフィルタリングするなどの注意が必要です。

---

### 問題
**シナリオ**: 各商品の価格を、その商品が属するカテゴリの平均価格と比較して更新する、という少し複雑な`UPDATE`処理を考えます。「商品マスタ」テーブルの各行に対して、同じテーブルから計算したカテゴリ別平均価格を取得し、条件分岐を行う必要があります。

このように、`UPDATE`文の`WHERE`句などで、更新対象の行の値を使いながら実行される副問合せを何と呼びますか。

```sql
UPDATE 商品マスタ M1
SET 備考 = 'カテゴリ内平均より高価格'
WHERE
  M1.単価 > (
    -- ここが【 a 】
    SELECT AVG(M2.単価)
    FROM 商品マスタ M2
    WHERE M2.商品カテゴリ = M1.商品カテゴリ
  );
```
**【回答】**
`a`: `相関副問合せ`
**【この構文が必要な理由】**
外側のクエリ（主問合せ）で処理されている行のデータ（この例では`M1.商品カテゴリ`）を、内側のクエリ（副問合せ）の条件として利用し、行ごとに異なる計算や比較を行う必要があるためです。

**【構文の解説】**
**相関副問合せ** (Correlated Subquery)
*   通常の副問合せが単独で実行可能なのに対し、相関副問合せは外側のクエリから値を受け取らないと実行できません。
*   外側のクエリの行が1行処理されるたびに、その行の値を参照して内側の副問合せが一度実行されます。そのため、外側のテーブルの行数が多いとパフォーマンスが低下する可能性があります。
*   `UPDATE`文や`DELETE`文の`WHERE`句、`SELECT`リストの中などで、行ごとの複雑な条件判定や値の取得によく利用されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 副問合せ内で、外側のテーブルのエイリアス（`M1`）を参照できることを知らない。
*   **解説**: 相関副問合せの最も重要な特徴が、まさにこの「外側のクエリで定義されたテーブル（エイリアス）を内側から参照できる」点にあります。これにより、`M2.商品カテゴリ = M1.商品カテゴリ`のような、外側の行と内側の行を関連付ける条件式が記述可能になります。

---

### 問題
**シナリオ**: 各部署に所属する社員の「平均年齢」をまず計算し、その結果をあたかも一つのテーブルであるかのように扱って、さらに社員の情報と結合したいと考えています。

`FROM`句の中に直接`SELECT`文を記述し、その結果を一時的なテーブル（導出テーブル）として利用するテクニックを何と呼びますか。

```sql
SELECT
  S.氏名,
  S.年齢,
  DeptAvg.平均年齢
FROM
  社員 S
INNER JOIN (
  -- この部分が【 a 】
  SELECT 所属部署ID, AVG(年齢) AS 平均年齢
  FROM 社員
  GROUP BY 所属部署ID
) AS DeptAvg ON S.所属部署ID = DeptAvg.所属部署ID;
```
**【回答】**
`a`: `インラインビュー`
**【この構文が必要な理由】**
SQLの処理の途中で動的に作成した集計結果や中間テーブルに対して、さらに`JOIN`などの操作を加えたい場合に必要となります。事前にビューを作成するまでもない、その場限りの一時的なテーブルとして非常に便利です。

**【構文の解説】**
`FROM (<SELECT文>) AS <エイリアス名>`
*   **インラインビュー**: `FROM`句の中に記述された副問合せのことです。この`SELECT`文の実行結果が、メモリ上で一時的なテーブルとして扱われます。
*   `AS <エイリアス名>`: インラインビューには必ず別名（エイリアス）を付ける必要があります。このエイリアスを使って、他のテーブルとの結合や列の参照を行います。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 複雑な処理をしようとして、一つの`SELECT`文の中ですべてを完結させようと試み、ウィンドウ関数や相関副問合せを不必要に多用してしまう。
*   **解説**: まずインラインビューを使って中間的な集計結果をシンプルに作成し、その結果に対して改めて`JOIN`や`WHERE`を適用する、というように処理を分割して考えることで、SQL全体の見通しが良くなり、間違いが少なくなります。インラインビューは、複雑なSQLを構造化するための強力な手段です。

---

### 問題
**シナリオ**: 現在の「売上明細」テーブルから、売上金額が10万円以上の高額取引のレコードだけを抽出し、新しく作成した「高額取引履歴」テーブルに丸ごとコピー（挿入）することになりました。

`SELECT`文の実行結果を、そのまま別のテーブルに挿入するには、どのような構文を使用すればよいでしょうか。

```sql
【 a 】 高額取引履歴 (注文ID, 顧客ID, 金額, 取引日)
【 b 】
  注文ID, 顧客ID, 金額, 取引日
FROM
  売上明細
WHERE
  金額 >= 100000;
  ```
**【回答】**
`a`: `INSERT INTO`
`b`: `SELECT`
**【この構文が必要な理由】**
あるテーブルから特定の条件で抽出したデータを、一行ずつではなく一括で効率的に別のテーブルにバックアップしたり、移し替えたりする必要があるためです。データ移行やバッチ処理などで頻繁に利用されます。

**【構文の解説】**
`INSERT INTO <テーブル名> (<列リスト>) SELECT <列リスト> FROM ...;`
*   `INSERT INTO ... SELECT ...`: `VALUES`句を使って1行ずつデータを指定する代わりに、`SELECT`文の実行結果セットをまるごと挿入データとして使用します。
*   **注意**: `INSERT`句の列リストの列数・データ型と、`SELECT`句の列リストの列数・データ型は、一致している必要があります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 挿入先のテーブル（高額取引履歴）が存在しない状態で実行しようとする。
*   **解説**: `INSERT INTO`文は、既にあるテーブルにデータを「追加」するための命令です。テーブル自体が存在しない場合は、まず`CREATE TABLE`文でテーブルの構造を定義しておく必要があります。データベース製品によっては`SELECT ... INTO <新テーブル>`という構文でテーブル作成とデータ挿入を同時に行えるものもありますが、標準SQLでは分けるのが一般的です。

---

### 問題
**シナリオ**: よく利用する、社員情報と部署情報を結合した結果を、毎回長い`SELECT`文を書かずに、あたかも一つのテーブルのように手軽に参照できるようにしたいと考えています。

このような、保存された`SELECT`文である「仮想的なテーブル」を作成するには、どのDDL（データ定義言語）文を使用すればよいでしょうか。

```sql
【 a 】 社員部署一覧_V (社員名, 部署名, 内線番号) AS
SELECT
  S.氏名,
  D.部署名,
  S.内線番号
FROM
  社員 S
INNER JOIN
  部署マスタ D ON S.所属部署ID = D.部署ID;
```
**【回答】**
`a`: `CREATE VIEW`
**【この構文が必要な理由】**
複雑なSQLクエリや頻繁に利用する結合結果を、データベース内に名前を付けて保存しておくことで、再利用性を高め、クエリを単純化するためです。また、元のテーブルの一部の列だけを公開することで、セキュリティを高める目的でも使用されます。

**【構文の解説】**
`CREATE VIEW <ビュー名> (<ビューの列リスト>) AS <SELECT文>;`
*   `CREATE VIEW`: 新しいビューを定義します。ビューは実データを持たず、参照されるたびに内部的に`SELECT`文が実行されます。
*   `<ビューの列リスト>`: (オプション) ビューとして公開する列に別名を付けることができます。
*   `AS <SELECT文>`: ビューの元となる`SELECT`文を定義します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: ビューは実際のデータを持っているテーブルだと勘違いする。
*   **解説**: ビューは「保存されたクエリ」であり、実体は`SELECT`文そのものです。ビューに対してクエリを実行すると、データベースシステムがビューの定義（`SELECT`文）とユーザーのクエリを組み合わせて、元の実テーブルにアクセスします。そのため、元のテーブルのデータが更新されれば、ビューから見えるデータも即座に変わります。

---

### 問題
**シナリオ**: システム開発の初期段階で、社員情報を格納するための新しいテーブル「社員」を作成することになりました。社員を一意に識別するための「社員ID」列を主キーとして設定し、社員の「氏名」は必須入力（`NULL`を許可しない）とします。

テーブルを新規に作成し、列のデータ型や制約を定義するには、どのDDL文を使用すればよいでしょうか。

```sql
【 a 】 社員 (
  社員ID   CHAR(5)    【 b 】,
  氏名     VARCHAR(40) NOT NULL,
  所属部署ID CHAR(4)
);
```
**【回答】**
`a`: `CREATE TABLE`
`b`: `PRIMARY KEY`
**【この構文が必要な理由】**
データベースにデータを格納するための器である「テーブル」の構造（スキーマ）を定義するために必要です。どのような列があり、それぞれのデータ型や制約（主キー、非NULLなど）はどうなっているかを定める、データ管理の基本となる命令です。

**【構文の解説】**
`CREATE TABLE <テーブル名> ( <列名1> <データ型> <制約>, <列名2> <データ型> <制約>, ... );`
*   `CREATE TABLE`: 新しいテーブルを作成します。
*   **列定義**: 列名、データ型（`CHAR`, `VARCHAR`, `INTEGER`, `DATE`など）、そしてその列に対する制約を記述します。
*   `PRIMARY KEY`: 主キー制約。その列の値がテーブル内で一意（重複不可）であり、かつ`NULL`であってはならないことを示します。テーブルの行を特定するための最も重要なキーです。
*   `NOT NULL`: 非NULL制約。その列に`NULL`値の格納を許可しないことを示します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 主キー(`PRIMARY KEY`)とユニークキー(`UNIQUE`)の違いを混同する。
*   **解説**: どちらも「重複を許可しない」という点は共通ですが、重要な違いがあります。一つのテーブルに`PRIMARY KEY`は一つしか設定できませんが、`UNIQUE`キーは複数設定できます。また、`PRIMARY KEY`は`NULL`を許可しませんが、`UNIQUE`制約は（製品によりますが）一般的に`NULL`を許可します（ただし`NULL`の重複は許さないなど挙動に差があります）。

---

### 問題
**シナリオ**: データベースの設計変更で、既存の「売上明細」テーブルの「商品ID」列が、「商品マスタ」テーブルの「商品ID」を必ず参照するように、整合性を保つための制約（外部キー制約）を追加することになりました。

既存のテーブルの定義を変更して、制約を追加するにはどのDDL文を使用しますか。

```sql
【 a 】 売上明細
【 b 】 FK_商品ID
  FOREIGN KEY (商品ID) REFERENCES 商品マスタ(商品ID);
```
**【回答】**
`a`: `ALTER TABLE`
`b`: `ADD CONSTRAINT`
**【この構文が必要な理由】**
テーブルを一度作成した後で、業務要件の変更などに応じて、列を追加・削除したり、制約を追加・削除したりする必要があるためです。データベースの運用・保守において不可欠な命令です。

**【構文の解説】**
`ALTER TABLE <テーブル名> ADD CONSTRAINT <制約名> <制約定義>;`
*   `ALTER TABLE`: 既存のテーブルの構造を変更します。
*   `ADD CONSTRAINT`: テーブルに新しい制約を追加します。制約には名前（この例では`FK_商品ID`）を付けることが推奨されます。
*   `FOREIGN KEY (列名) REFERENCES <親テーブル>(列名)`: 外部キー制約を定義します。これにより、「売上明細」の「商品ID」列には、「商品マスタ」の「商品ID」列に存在する値しか登録できなくなり、データの整合性が保たれます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 外部キー制約を追加しようとしたらエラーになった。
*   **解説**: エラーになる最も一般的な原因は、制約を追加しようとしている子テーブル（売上明細）に、親テーブル（商品マスタ）に存在しない値がすでに入力されている場合です。例えば、商品マスタに存在しない商品ID 'X999' が売上明細に記録されていると、制約を追加した時点で整合性が崩れるため、データベースがエラーを返します。先に関連データを修正または削除する必要があります。

---

### 問題
**シナリオ**: 新入社員の研修用に、データベースのアカウント `kenshu01` を作成しました。このアカウントには、「商品マスタ」テーブルのデータを閲覧する権限だけを与え、書き込みや削除はできないように設定したいと考えています。

特定のユーザーに対して、テーブルへの操作権限を付与するには、どのDCL（データ制御言語）文を使用すればよいでしょうか。

```sql
【 a 】 SELECT ON 商品マスタ TO kenshu01;
```
**【回答】**
`a`: `GRANT`
**【この構文が必要な理由】**
データベースのセキュリティを維持するため、ユーザーごとに許可する操作を細かく制御する必要があるためです。これにより、意図しないデータの更新や削除、機密情報への不正なアクセスを防ぎます。

**【構文の解説】**
`GRANT <権限種別> ON <オブジェクト名> TO <ユーザー名>;`
*   `GRANT`: ユーザーに権限を付与します。
*   **権限種別**: `SELECT`（参照）、`INSERT`（挿入）、`UPDATE`（更新）、`DELETE`（削除）などの操作を指定します。複数の権限をカンマで区切って指定することも可能です（例：`GRANT SELECT, INSERT ...`）。
*   `ON <オブジェクト名>`: 権限を付与する対象となるテーブル名やビュー名を指定します。
*   `TO <ユーザー名>`: 権限を付与する相手のユーザーアカウントを指定します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 権限を取り消す方法を知らない。
*   **解説**: 付与した権限を取り消す（剥奪する）には、`GRANT`の対になる`REVOKE`文を使用します。構文は似ており、`REVOKE SELECT ON 商品マスタ FROM kenshu01;`のように記述します。権限の付与と剥奪はセットで覚えることが重要です。

---

### 問題
**シナリオ**: 部署ごとの月間売上レポートを作成しています。`LEFT JOIN`を使って社員と売上を結合したところ、その月に売上がなかった社員の売上額は`NULL`と表示されてしまいました。この`NULL`を`0`に置き換えて、後続の計算（合計など）を正しく行えるようにしたいです。

`NULL`である場合に、指定した別の値に変換するには、どの関数を使えばよいでしょうか。

```sql
SELECT
  S.氏名,
  【 a 】(U.売上額, 0) AS 月間売上
FROM
  社員 S
LEFT OUTER JOIN
  月間売上 U ON S.社員ID = U.社員ID;
```
**【回答】**
`a`: `COALESCE`
**【この構文が必要な理由】**
`NULL`は「値が存在しない」状態を表すため、四則演算（例: `NULL + 100`）を行うと結果も`NULL`になってしまいます。集計や計算を正しく行うために、`NULL`を`0`のような具体的な数値に事前に変換しておく必要があるためです。

**【構文の解説】**
`COALESCE(<値1>, <値2>, ...)`
*   `COALESCE`（コアレス）関数は、引数を左から順に評価し、最初に現れた`NULL`でない値を返します。
*   `COALESCE(U.売上額, 0)` の場合、`U.売上額`が`NULL`でなければその値を、`NULL`であれば次の引数である`0`を返します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `CASE`文を使って `CASE WHEN U.売上額 IS NULL THEN 0 ELSE U.売上額 END` と書いてしまう。
*   **解説**: この`CASE`文でも全く同じ結果が得られ、間違いではありません。しかし、単に`NULL`を別の値に置き換えたいだけであれば、`COALESCE`関数を使った方がはるかに短く、直感的に記述できます。`COALESCE`は、この特定の目的のために用意された便利なショートカット関数だと理解すると良いでしょう。

---

### 問題
**シナリオ**: ログデータが、'20240901' のような `YYYYMMDD` 形式の文字列（`VARCHAR`型）でテーブルに格納されています。このログデータから、2024年9月1日以降のレコードを日付として正しく比較・抽出したいと考えています。

文字列を日付型などの別のデータ型に明示的に変換するには、どの関数を使用すればよいでしょうか。

```sql
SELECT
  ログ本文
FROM
  アクセスログ
WHERE
  【 a 】(記録日時 AS DATE) >= '2024-09-01';
```
**【回答】**
`a`: `CAST`
**【この構文が必要な理由】**
'20240901' のような文字列のままでは、日付としての大小比較や日付関数を使った計算ができません。データを適切なデータ型に変換することで、その型が持つ本来の機能（日付の比較、数値計算など）を利用できるようにするためです。

**【構文の解説】**
`CAST(<変換する値> AS <変換後のデータ型>)`
*   `CAST`: 値のデータ型を明示的に変換するための標準SQL関数です。
*   **変換後のデータ型**: `INTEGER`, `VARCHAR(n)`, `DATE`, `TIMESTAMP`など、変換したいデータ型を指定します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 型変換をせずに、`WHERE 記録日時 >= '20240901'` のように文字列のまま比較してしまう。
*   **解説**: この例では、文字列としての辞書順比較でも偶然正しい結果が得られます。しかし、日付のフォーマットが '01/09/2024' (DD/MM/YYYY) のような場合、文字列比較では '02/08/2024' の方が大きいと誤判定されてしまいます。また、'2024-9-1' のように桁数が違うと正しく比較できません。日付や数値の比較は、必ず適切なデータ型に変換してから行うのが鉄則です。

---

### 問題
**シナリオ**: あるキャンペーン期間中に、商品を購入した顧客が「何人」いたのかを調べる必要があります。一人の顧客が期間中に複数回購入していても、1人と数えたいです。

「売上明細」テーブルから、重複を除いたユニークな顧客IDの数を数えるには、`COUNT`関数をどのように使えばよいでしょうか。

```sql
SELECT
  【 a 】(顧客ID) AS 購入顧客数
FROM
  売上明細
WHERE
  売上日 BETWEEN '2024-08-01' AND '2024-08-31';
```
**【回答】**
`a`: `COUNT(DISTINCT `
**【この構文が必要な理由】**
単純な行数（延べ人数）ではなく、対象となるエンティティ（この場合は顧客）の純粋な数（正味人数）を把握する必要があるためです。`DISTINCT`キーワードにより、集計前に対象列から重複値を取り除くことができます。

**【構文の解説】**
`COUNT(DISTINCT <列名>)`
*   `COUNT(<列名>)`: 指定した列の`NULL`でない行の数を数えます。
*   `COUNT(*)`: `NULL`を含めたすべての行の数を数えます。
*   `DISTINCT`: `COUNT`関数と組み合わせることで、集計対象の列から重複する値を除外してから、その件数を数えます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `COUNT(*)` や `COUNT(顧客ID)` を使ってしまう。
*   **解説**: `COUNT(*)`や`COUNT(顧客ID)`を使うと、売上の「件数」（延べ購入回数）がカウントされてしまいます。例えば、Aさんが3回、Bさんが2回購入した場合、`5`という結果が返ってきます。要件である「何人いたか（購入者数）」を調べるには、AさんとBさんの2人を数える必要があるので、`COUNT(DISTINCT 顧客ID)`を使い、`2`という結果を得るのが正解です。

---

### 問題
**シナリオ**: 顧客マスタから、氏名に「木村」という文字が含まれるすべての顧客を検索したいと考えています。前方一致や後方一致ではなく、文字列の任意の位置に含まれているかどうかを判定するには、どの演算子を使えばよいでしょうか。

```sql
SELECT
  顧客ID,
  氏名
FROM
  顧客マスタ
WHERE
  氏名 【 a 】 '%木村%';
```
**【回答】**
`a`: `LIKE`
**【この構文が必要な理由**】
`=`（イコール）による完全一致検索では不十分で、文字列の一部がパターンに合致するかどうかという、より柔軟な条件で検索を行う必要があるためです。

**【構文の解説】**
`WHERE <列名> LIKE '<パターン>'`
*   `LIKE`: 文字列の部分一致検索を行うための演算子です。
*   **ワイルドカード**: パターン内では、特殊な意味を持つワイルドカードを使用します。
    *   `%` (パーセント): 任意の0文字以上の文字列に一致します。`'%木村%'`は、「木村」の前後にどんな文字列があっても（あるいはなくても）良いことを意味します。
    *   `_` (アンダースコア): 任意の一文字に一致します。`'木村_子'`は、「木村亜子」「木村優子」などに一致します。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 検索したい文字列に`%`や`_`自体が含まれている場合の対処法を知らない。
*   **解説**: 例えば「50%割引」という文字列を検索したい場合、`LIKE '%50%%'`と書くと意図通りに動作しません。この場合、`ESCAPE`句を使ってエスケープ文字を定義します。`WHERE 列名 LIKE '%50#%%' ESCAPE '#'`のように記述すると、`#`の直後にある`%`はワイルドカードではなく、ただの文字として扱われます。

---

### 問題
**シナリオ**: 2024年4月1日から4月30日までの売上データをすべて抽出したいと考えています。`WHERE`句で、日付が特定の範囲に「収まっている」ことを判定するには、`>=` と `<=` を使う以外に、どのような演算子が使えるでしょうか。

```sql
SELECT
  売上日,
  金額
FROM
  売上明細
WHERE
  売上日 【 a 】 '2024-04-01' AND '2024-04-30';
```
**【回答】**
`a`: `BETWEEN`
**【この構文が必要な理由】**
開始値と終了値を含んだ範囲指定を、`>=`と`<=`と`AND`を組み合わせるよりも、より直感的で可読性の高いコードで表現するためです。

**【構文の解説】**
`WHERE <列名> BETWEEN <開始値> AND <終了値>`
*   `BETWEEN ... AND ...`: 指定した列の値が、`<開始値>`以上かつ`<終了値>`以下である場合に`TRUE`を返します。
*   この演算子は、数値、日付、文字列など、順序を比較できるデータ型に対して使用できます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `<開始値>`と`<終了値>`を含まない、つまり「より大きく」「より小さい」範囲だと勘違いする。
*   **解説**: `BETWEEN`は `<列名> >= <開始値> AND <列名> <= <終了値>` と等価です。つまり、境界値である開始値と終了値は範囲に**含まれます**。もし境界値を含まない範囲（例：4月2日から4月29日まで）を指定したい場合は、`WHERE 売上日 > '2024-04-01' AND 売上日 < '2024-04-30'` のように、不等号を明示的に使う必要があります。


承知いたしました。現在の出力を自己評価し、「最高傑作」と呼ぶにふさわしいレベルへと昇華させるための改善点と、それに基づいた修正版を提示します。

### 自己評価と改善方針

現在の出力は、ご指示いただいたルールに沿っており、SQL初学者にとって有用な学習資料となっています。しかし、「私の能力の限界を示す最高傑作」という基準で評価すると、以下の点でさらなる向上が可能だと判断します。

1.  **学習体験の連続性**: 現状は各問題が独立しており、知識が断片的になりがちです。これを、**「一人のデータ分析担当者が、ECサイトの売上データを分析していく」という一貫したストーリー**に再編します。これにより、学習者は個々の構文を学びながら、実際のデータ分析のプロセスを疑似体験でき、知識が有機的に繋がります。
2.  **シナリオの現実味**: 問題文のシナリオをより具体的にし、「なぜその分析が必要なのか」というビジネス上の背景を色濃く反映させます。単なるデータ抽出ではなく、「売上改善のアクションに繋げる」という目的意識を持たせることで、学習の動機付けを強化します。
3.  **解説の深度**: 「なぜそうなるのか」という理由を、**SQLの内部的な実行順序**にまで踏み込んで解説します。これにより、単なる丸暗記ではなく、SQLの動作原理に基づいた本質的な理解を促します。
4.  **誤答例の質**: 単純な文法エラーだけでなく、**「エラーにはならないが、意図と違う結果を返す」という、実務でより陥りやすい巧妙な罠**を誤答例として提示します。なぜその誤りが静かに問題を引き起こすのかを解説し、デバッグ能力の素養を養います。

これらの改善方針に基づき、以下に修正版「最高傑作」を提示します。

---

## 【最高傑作】SQL問題集：ECサイト売上分析編

あなたは、ECサイト「TechMart」のデータ分析チームに配属された新人アナリストです。店長から「データに基づいて売上改善のヒントを見つけてほしい」というミッションを与えられました。一連の分析作業を通して、SQLの神髄をマスターしていきましょう。

### 問題1: 全体像の把握 〜 利益率の高い優良カテゴリの特定

**【問題】**
最初のステップとして、どの商品カテゴリが収益の柱となっているかを把握します。「売上明細」テーブルには個々の売上記録が蓄積されています。ここから、カテゴリごとに売上合計を算出し、その**合計額が500万円を超えている**優良カテゴリのみを特定したいと考えています。**集計した結果**に対して絞り込みを行うには、どの句を使えばよいでしょうか。

```sql
SELECT
    カテゴリ,
    SUM(売上金額) AS 売上合計
FROM
    売上明細
【 a 】
    カテゴリ
【 b 】
    SUM(売上金額) > 5000000;
```

**【回答】**
`a`: `GROUP BY`
`b`: `HAVING`

**【この構文が必要な理由】**
個々の売上データ（行）ではなく、`GROUP BY`で集約した結果のグループ（カテゴリごとの売上合計）に対して条件を適用する必要があるためです。`WHERE`句はグループ化の前に個々の行を評価するため、この目的には使えません。

**【構文の解説】**
`GROUP BY <列名>` で指定した列を基準にデータをグループ化し、`HAVING <集約結果に対する条件>` でそのグループを絞り込みます。
SQLの内部的な実行順序は `FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` の順です。この流れを理解すると、`WHERE`句（`GROUP BY`の前）で集約関数が使えず、`HAVING`句（`GROUP BY`の後）で使える理由が明確になります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 集約後の条件を`WHERE`句に書いてしまう。
    ```sql
    -- 誤答例
    WHERE SUM(売上金額) > 5000000
    ```
*   **解説**: これは最も典型的な誤りです。SQLがデータを処理する際、まず`FROM`句でテーブルを読み込み、次に`WHERE`句で**1行ずつ**条件を評価します。この段階ではまだ`SUM()`の計算、つまりグループ化が行われていないため、「売上合計」という概念が存在せず、エラーになります。集約結果に対する条件は、必ず集約処理の「後」に行う`HAVING`句の役割です。

---

### 問題2: 分析範囲の網羅 〜 売れていない商品もリストアップ

**【問題】**
優良カテゴリが特定できましたが、逆に「全く売れていない商品」も把握し、販売戦略の見直しに繋げたいと考えました。「商品マスタ」のすべての商品と、「売上明細」の情報を紐付け、売上がない商品も`NULL`としてリストに表示する必要があります。左側（商品マスタ）のデータをすべて残す結合を行うには、どの構文を使えばよいでしょうか。

```sql
SELECT
    M.商品名,
    U.売上日
FROM
    商品マスタ AS M
【 a 】
    売上明細 AS U
【 b 】
    M.商品ID = U.商品ID;
```

**【回答】**
`a`: `LEFT JOIN`
`b`: `ON`

**【この構文が必要な理由】**
分析の網羅性を担保するためです。`INNER JOIN`では売れた記録のある商品しか抽出できませんが、`LEFT JOIN`を使うことで、「商品マスタ」に存在するすべての商品を基準として、売上があってもなくても結果に含めることができます。

**【構文の解説】**
`FROM テーブルA LEFT JOIN テーブルB ON <結合条件>`
`LEFT JOIN`（左外部結合）は、左側のテーブルAの行をすべて保持します。`ON`句の条件に一致する行が右側のテーブルBにあれば結合し、なければその列を`NULL`として結果を返します。これにより、「存在しない（売れていない）」という情報を含んだデータセットを作成できます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `LEFT JOIN`の後、`WHERE`句で右側のテーブル（売上明細）の条件を指定してしまう。
    ```sql
    -- 意図しない結果になる例
    ... LEFT JOIN 売上明細 AS U ON M.商品ID = U.商品ID
    WHERE U.売上日 >= '2025-04-01'
    ```
*   **解説**: これはエラーにはなりませんが、非常に危険な間違いです。`LEFT JOIN`によって、売上のない商品は`U.売上日`が`NULL`になります。その後の`WHERE`句で `NULL >= '2025-04-01'` が評価されますが、`NULL`との比較は常に「不明（偽）」と判定されるため、せっかく`LEFT JOIN`で残したはずの売れていない商品の行がすべて除外されてしまいます。結果、`INNER JOIN`とほぼ同じ結果になり、「全商品を分析する」という当初の目的を果たせません。

---

### 問題3: データ整形 〜 「ない」は「0」と表現する

**【問題】**
前の手順で、売れていない商品の売上データが`NULL`になることが分かりました。このままでは集計レポートとして不親切なので、売上合計を計算する際に、売上がない（`SUM`の結果が`NULL`になる）商品の合計金額を「**0**」として明示的に表示したいです。`NULL`を別の値に置き換えるには、どの関数が最適でしょうか。

```sql
SELECT
    M.商品名,
    【 a 】(SUM(U.売上金額), 0) AS 売上合計
FROM
    商品マスタ AS M
LEFT JOIN
    売上明細 AS U ON M.商品ID = U.商品ID
GROUP BY
    M.商品ID, M.商品名;
```

**【回答】**
`a`: `COALESCE`

**【この構文が必要な理由】**
データ利用者の誤解を防ぎ、レポートの品質を高めるためです。`NULL`は「データが存在しない」状態を表し、`0`は「存在するが値がゼロ」という明確な数値を表します。この違いを意識し、ビジネス要件（今回は「0円」と表示）に合わせて`NULL`を明示的に変換する必要があります。

**【構文の解説】**
`COALESCE(値1, 値2, ...)`
引数リストを左から順に評価し、最初に見つかった`NULL`ではない値を返します。`COALESCE(SUM(U.売上金額), 0)`は、「`SUM`の結果が`NULL`でなければその値を、もし`NULL`なら`0`を返す」という意味になり、売上がない商品の合計を`0`として表示するのに最適な関数です。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `SUM`関数は自動で`NULL`を`0`にしてくれるだろうと期待し、`COALESCE`を付け忘れる。
*   **解説**: `SUM`関数は計算の過程で`NULL`値を「無視」しますが、集計対象の行が一件も存在しない場合、`SUM`関数の**結果自体が`NULL`**になります。これは`COUNT`関数の結果が`0`になる挙動と異なるため、混同しやすいポイントです。`NULL`（不明）と`0`（ゼロ）はSQLでは明確に区別されるため、意図して`0`を表示するには`COALESCE`による変換が不可欠です。

---

### 問題4: 分析粒度の深化 〜 誰が何を売ったのか？

**【問題】**
次に、カテゴリごとの売上をさらに掘り下げ、「どの担当者が、どのカテゴリでいくら売り上げたか」を分析することにしました。`SELECT`句で`担当者名`、`カテゴリ`、そして`SUM(売上金額)`を表示しようとしています。集約の単位を正しくデータベースに伝えるために、`GROUP BY`句には何を指定すべきでしょうか。

```sql
SELECT
    担当者名,
    カテゴリ,
    SUM(売上金額) AS 売上合計
FROM
    売上明細
【 a 】
    【 b 】;
```

**【回答】**
`a`: `GROUP BY`
`b`: `担当者名, カテゴリ`

**【この構文が必要な理由】**
「誰が」「何を」という2つの軸で集計を行うため、グループ化の基準（キー）としてその両方を指定する必要があるからです。`GROUP BY`は、これから行う集計計算の「切り口」を定義する重要な役割を担います。

**【構文の解説】**
`GROUP BY <列1>, <列2>, ...`
`SELECT`句に集約関数（`SUM`など）と非集約列（`担当者名`、`カテゴリ`）を混在させる場合、**すべての非集約列を`GROUP BY`句に指定しなければならない**という厳密なルールがあります。これにより、「`担当者名`と`カテゴリ`の値の組み合わせが同じ行」を一つのグループとして扱い、そのグループ内で`SUM`が計算されます。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: `GROUP BY 担当者名` のように、非集約列の一部だけを指定してしまう。
*   **解説**: この場合、データベースは「`担当者名`でグループ化したはいいが、同じ担当者（例：佐藤さん）が複数のカテゴリ（PC、周辺機器）を売り上げている場合、`SELECT`句に表示すべき`カテゴリ`は一体どれなのか？」と混乱し、エラーを返します。`SELECT`句で表示する非集約列は、すべて集約のキーとして`GROUP BY`句に含めることで、結果の各行が一意に定まることを保証する必要があります。

---

### 問題5: 施策立案への応用 〜 優良顧客の除外

**【問題】**
分析の結果、新規顧客向けのキャンペーンを企画することになりました。そこで、「これまでに**一度も購入履歴がない**顧客」のリストを作成する必要があります。「顧客マスタ」には全顧客が、「購入履歴」テーブルには購入経験のある顧客IDが記録されています。ただし、購入履歴テーブルにはデータ連携の不具合で`NULL`の顧客IDが混入している可能性があります。この`NULL`に影響されず、安全に未購入顧客を抽出するには、どの演算子が最も信頼できるでしょうか。

```sql
SELECT
    顧客名
FROM
    顧客マスタ
WHERE
    【 a 】 (
        SELECT 1 FROM 購入履歴
        WHERE 顧客マスタ.顧客ID = 購入履歴.顧客ID
    );
```

**【回答】**
`a`: `NOT EXISTS`

**【この構文が必要な理由】**
データの完全性が保証されない状況でも、確実な結果を得るためです。`NOT IN`はサブクエリに`NULL`が含まれると全件`0`件という壊滅的な結果を返す「罠」がありますが、`NOT EXISTS`は`NULL`の影響を受けず、行の「存在」のみを判定するため、より堅牢で安全な選択肢となります。

**【構文の解説】**
`WHERE NOT EXISTS (<相関サブクエリ>)`
`EXISTS`はサブクエリが1行でも結果を返せば真、`NOT EXISTS`は1行も返さなければ真となります。この構文は、主クエリの各行に対してサブクエリを実行し、「サブクエリの条件を満たす行が**存在しない**場合に、主クエリのその行を結果として返す」という動きをします。存在チェックなので、サブクエリ内の値が`NULL`かどうかは判定に影響しません。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 直感的に分かりやすい`NOT IN`を使ってしまう。
    ```sql
    -- 非常に危険な誤答例
    WHERE 顧客ID NOT IN (SELECT 顧客ID FROM 購入履歴)
    ```
*   **解説**: もし `(SELECT 顧客ID FROM 購入履歴)` の結果に一つでも`NULL`が含まれると、`NOT IN`の評価は `顧客ID IN ('C001', 'C002', NULL)` の**否定**となります。SQLでは`NULL`との比較結果は「不明」です。例えば`'C003' NOT IN ('C001', 'C002', NULL)`という評価は、「`'C003'<> 'C001'`(真) AND `'C003'<>'C002'`(真) AND `'C003'<>NULL`(不明)」となり、全体の結果が「不明」と判定され、真にはなりません。これが全行で起こるため、結果が0件になってしまうのです。

---

### 問題6: 相対的な評価 〜 カテゴリ平均との比較

**【問題】**
最後の分析として、個々の商品の売上が、その商品が属するカテゴリ全体の平均売上と比較してどうなのかを評価し、隠れた優良商品やテコ入れが必要な商品を見つけたくなりました。`SELECT`句の中で、外側のクエリ（商品ごと）のカテゴリIDを使い、内側のクエリでそのカテゴリの平均売上を計算させるには、サブクエリ内で何を行えば「単一の値（1行1列）」を返すというルールを満たせるでしょうか。

```sql
SELECT
    商品名,
    売上金額,
    (SELECT 【 a 】(売上金額) FROM 売上明細 S2 WHERE S2.カテゴリID = S1.カテゴリID) AS カテゴリ平均売上
FROM
    売上明細 S1;
```

**【回答】**
`a`: `AVG`

**【この構文が必要な理由】**
`SELECT`句に埋め込むサブクエリ（スカラサブクエリ）は、外側のクエリの各行に対して「一つの値」を返さなければならないという制約があるためです。集約関数（`AVG`, `MAX`等）を使うことで、サブクエリが返しうる複数行のデータを、ルールに適合する単一の値に集約できます。

**【構文の解説】**
`SELECT`句や`WHERE`句の比較演算子の右辺で使われる、単一の値を返すサブクエリを「スカラサブクエリ」と呼びます。外側のクエリの行（ここでは`S1`の各行）の値を、内側のサブクエリ（`S2`）の条件に使うものを特に「相関サブクエリ」と言います。この組み合わせにより、各商品の行ごとに、その商品が属するカテゴリの平均売上を動的に計算して横に並べることが可能になります。

**【初心者が陥りがちな誤解や誤答例】**
*   **誤解/誤答**: 集約関数を忘れ、平均ではなく個々の売上を返そうとしてしまう。
    ```sql
    -- エラーになる例
    (SELECT 売上金額 FROM 売上明細 S2 WHERE S2.カテゴリID = S1.カテゴリID)
    ```
*   **解説**: このサブクエリは、ある商品と同じカテゴリに属する**すべての**売上金額を返そうとします。通常、カテゴリには複数の売上記録があるため、サブクエリは複数行を返そうとして「サブクエリが複数の値を返しました」というエラーを引き起こします。各行に対して単一の「カテゴリ平均売上」という値を得るためには、`AVG()`関数で複数行のデータを集約し、必ず1行1列の結果を返すように保証する必要があります。