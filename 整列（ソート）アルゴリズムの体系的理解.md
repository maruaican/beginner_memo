

---

## 整列（ソート）アルゴリズムの体系的理解

このドキュメントでは、応用情報技術者試験で問われる主要な整列アルゴリズムについて、その分類、特徴、具体的な動作を体系的に解説します。

### 1. 整列アルゴリズムの分類

整列アルゴリズムは、その処理方式によっていくつかのグループに分類できます。

- **分割統治型**
  - **マージソート**: 問題を小さな部分問題に分割し、それぞれを解決した後に結合（マージ）することで、最終的な解を得ます。
  - **クイックソート**: 基準値（ピボット）を基にデータを分割し、各部分を再帰的に整列します。

- **改良挿入型**
  - **シェルソート**: 挿入ソートを改良したもので、ある間隔を空けた要素群を先に整列させることで、全体の効率を高めます。

- **選択木型**
  - **ヒープソート**: データ全体で順序木（ヒープ）を構築し、そこから最大値または最小値を取り出す操作を繰り返して整列します。

### 2. パフォーマンス評価の指標と比較

各アルゴリズムの特性を理解し比較するためには、以下の指標が重要です。試験では、これらの特徴を正しく区別できるかが問われます。

#### 評価指標（試験の着眼点）

- **計算量**: アルゴリズムの実行速度を示す指標です。「平均計算量」と、最悪のデータ順の場合の「最悪計算量」があります。
- **安定性**: 同じ値を持つ要素の相対的な順序が、ソート後も保持されるかどうかを示します。保持される場合を「安定ソート」と呼びます。
- **追加領域の要否**: 整列対象のデータ領域とは別に、作業用のメモリ領域を必要とするかどうかを示します。

#### 主要アルゴリズムの比較表

| アルゴリズム | 平均計算量 | 最悪計算量 | 安定性 | 追加領域 |
|:---|:---:|:---:|:---:|:---:|
| **マージソート** | O(n log n) | O(n log n) | 〇 (安定) | 要 |
| **クイックソート** | O(n log n) | O(n²) | ✕ (不安定) | 不要 |
| **シェルソート** | O(n log² n)程度 | 実装依存 | ✕ (不安定) | 不要 |
| **ヒープソート** | O(n log n) | O(n log n) | ✕ (不安定) | 不要 |
| **バブルソート** | O(n²) | O(n²) | 〇 (安定) | 不要 |

---

## 各ソートアルゴリズムの詳細解説

ここでは、各アルゴリズムの定義、特徴、具体的な動作について詳しく見ていきます。

### 1. マージソート (Merge Sort)

#### 概要と由来
整列対象を大きさ1の要素にまで分割した後、隣り合う要素（部分列）を整列させながら**併合（Merge）**していく手法です。その名前は、この併合処理に由来します。

#### 特徴
- 計算量は、データの内容によらず常に **O(n log n)** であり、安定した性能を保証します。
- 同じ値の要素の順序が保たれる**安定ソート**です。
- データを併合するための作業領域として、**追加領域が必要**になります。

#### 動作原理
「分割統治」の考え方に基づきます。まずデータを機械的に最小単位まで分割し、その後、小さい部分列を完全に整列させながら結合していくことで、最終的に全体が整列されます。**整列処理は、分割時ではなく併合時に行われます。**

#### 具体的な動作例
配列 `[38, 27, 43, 3, 9, 82, 10]` を例に見てみましょう。

- **分割フェーズ**: 配列を要素数が1になるまで再帰的に分割します。
  - `[38, 27, 43, 3]` と `[9, 82, 10]`
  - `[38, 27]` と `[43, 3]` と `[9, 82]` と `[10]`
  - `[38]`, `[27]`, `[43]`, `[3]`, `[9]`, `[82]`, `[10]`

- **併合（マージ）フェーズ**: 分割した部分列を整列しながら結合していきます。
  - `[27, 38]`, `[3, 43]`, `[9, 82]`, `[10]`
  - `[3, 27, 38, 43]` と `[9, 10, 82]`
  - 最終結果: `[3, 9, 10, 27, 38, 43, 82]`

### 2. クイックソート (Quick Sort)

#### 概要と由来
データ群から**基準値（ピボット）**を一つ選び、それを境に「基準値以下のグループ」と「基準値以上のグループ」に分割します。この分割処理を再帰的に繰り返すことで整列します。平均的に非常に**高速（Quick）**であることから名付けられました。

#### 特徴
- 平均計算量は **O(n log n)** で非常に高速であり、実用上広く使われています。
- 基準値の選び方が偏ると効率が低下し、最悪計算量は **O(n²)** となります。
- 同じ値の要素の順序が保存されない**不安定ソート**です。
- 追加領域は原則として**不要**です。

#### 動作原理
「基準値を真ん中に置き、左右を再帰的に整列する」という考え方です。**分割した瞬間に基準値（ピボット）の最終的な位置が確定する**のが特徴で、整列は分割時に進みます。

#### 具体的な動作例
配列 `[38, 27, 43, 3, 9, 82, 10]` を例に見てみましょう。（基準値は各部分配列の先頭要素とします）

- **最初の分割**: 基準値を `38` とします。
  - 38以下のグループ: `[27, 3, 9, 10]`
  - 38以上のグループ: `[43, 82]`
  - この時点で `38` の位置が確定し、配列は `[27, 3, 9, 10, 38, 43, 82]` のような並びになります。

- **再帰的な分割**:
  - `[27, 3, 9, 10]` を基準値 `27` で分割 → `[3, 9, 10]` と `[]`
  - `[43, 82]` を基準値 `43` で分割 → `[]` と `[82]`

- **最終結果**: すべての分割が終わると、全体が整列されます。
  - `[3, 9, 10, 27, 38, 43, 82]`

### 3. シェルソート (Shell Sort)

#### 概要と由来
**挿入ソートの改良版**で、考案者である**Donald Shell**の名前に由来します。まず、ある間隔おきに取り出した要素で部分列を作りそれぞれを整列し、次に間隔を狭めながら同様の操作を繰り返し、最終的に間隔が1（通常の挿入ソート）になるまで続けます。

#### 特徴
- 挿入ソートの欠点（要素の移動が一度に1つずつ）を、離れた要素を先に交換することで改善しています。中規模データに有効です。
- 計算量は間隔の取り方に依存しますが、一般的に **O(n log² n)程度**とされます。
- **不安定ソート**であり、追加領域は**不要**です。

#### 動作原理
「段階的に粗いソートから始め、最後に仕上げる」という考え方です。遠くの要素を先に大まかに移動させておくことで、最後の挿入ソート（間隔1）での要素の移動回数を大幅に減らすことができます。

#### 具体的な動作例
配列 `[38, 27, 43, 3, 9, 82, 10]` を例に見てみましょう。

- **間隔 h=3 でソート**:
  - グループ1: `[38, 3, 10]` → 挿入ソート → `[3, 10, 38]`
  - グループ2: `[27, 9]` → 挿入ソート → `[9, 27]`
  - グループ3: `[43, 82]` → 挿入ソート → `[43, 82]`
  - この時点での配列全体: `[3, 9, 43, 10, 27, 82, 38]` （元の位置に戻す）

- **間隔 h=1 でソート（仕上げの挿入ソート）**:
  - 上記の配列に対して通常の挿入ソートを適用します。
  - 最終結果: `[3, 9, 10, 27, 38, 43, 82]`

### 4. ヒープソート (Heap Sort)

#### 概要と由来
未整列の部分を**ヒープ（順序木）**というデータ構造に変換し、そこから最大値（または最小値）を順に取り出して整列済みの部分に移す操作を繰り返す手法です。ヒープ構造を利用することから名付けられました。

#### 特徴
- 計算量は常に **O(n log n)** です。
- メモリ効率が良く、追加領域は**不要**です。
- 同じ値の要素の順序が保存されない**不安定ソート**です。

#### 動作原理
「ヒープ構造にすれば、根（ルート）が常に最大値（または最小値）になる。その根を取り出して整列済み領域の末尾に置く」という操作を繰り返すだけで、自動的に整列が完了します。

#### 具体的な動作例
配列 `[38, 27, 43, 3, 9, 82, 10]` を例に見てみましょう。（最大ヒープを構築し、昇順に並べます）

- **ヒープ構築**: 配列をヒープ構造に変換します。根（ルート）には最大値 `82` が来ます。

- **最大値の取り出しとヒープ再構築**:
  1. 根の `82` を取り出し、配列の末尾に移動させます。残りの要素でヒープを再構築します。
     - 配列: `[38, 27, 43, 3, 9, 10 | 82]` → `[82]` が確定。
  2. 再構築されたヒープの根（次の最大値 `43`）を取り出し、末尾から2番目に移動させます。
     - 配列: `[3, 9, 10, 27, 38 | 43, 82]` → `[43, 82]` が確定。
  3. この操作を配列の全要素が整列済みになるまで繰り返します。

- **最終結果**: `[3, 9, 10, 27, 38, 43, 82]`

### 5. バブルソート (Bubble Sort)

#### 概要
隣り合う要素を比較し、大小関係が逆であれば交換する操作を繰り返す、単純なアルゴリズムです。大きい（または小さい）要素が、水中の**泡（Bubble）**のように端に上がっていく様子から名付けられました。

#### 特徴
- 計算量は **O(n²)** であり、データ数が多い場合には非効率です。
- 1回の走査（パス）で、最も大きい（または小さい）値が末尾に確定します。
- **安定ソート**であり、追加領域は**不要**です。

#### 動作原理
「隣同士を比べて、大きいものを後ろに押し上げる」という操作を繰り返します。1回の走査で最大値が最後に確定し、次の走査ではその手前までを対象にする、という流れで整列が進みます。

#### 具体的な動作例
配列 `[38, 27, 43, 3, 9]` を例に見てみましょう。

- **1回目の走査**:
  - `(38, 27)` を比較・交換 → `[27, 38, 43, 3, 9]`
  - `(38, 43)` はそのまま → `[27, 38, 43, 3, 9]`
  - `(43, 3)` を比較・交換 → `[27, 38, 3, 43, 9]`
  - `(43, 9)` を比較・交換 → `[27, 38, 3, 9, 43]`
  - → 最大値 `43` が末尾に確定。

- **2回目の走査**:
  - `(38, 3)` を比較・交換 → `[27, 3, 38, 9, 43]`
  - `(38, 9)` を比較・交換 → `[27, 3, 9, 38, 43]`
  - → `38` が確定。

- **以降の走査**: 同様に繰り返し、最終的に整列が完了します。
  - 最終結果: `[3, 9, 27, 38, 43]`

---

## 試験対策：ソート処理からアルゴリズムを識別するノウハウ

試験では、ソートの途中経過を示し、どのアルゴリズムかを問う問題が出題されます。各アルゴリズムの「動きの特徴」を掴むことが重要です。

### 1. 識別のための着眼点

| アルゴリズム | 識別のためのキーワード（見抜き方） |
|:---|:---|
| **バブルソート** | **隣接要素のみ**を比較・交換し、**最大値が泡のように後ろへ**押しやられていく。 |
| **挿入ソート** | **左側が常に整列済み**の状態で、右側の未整列要素を1つずつ正しい位置に**挿入**していく。 |
| **選択ソート** | 未整列部分から**最小値（または最大値）を探し**、未整列部分の**先頭要素と交換**する。 |
| **クイックソート** | **基準値（ピボット）**を決め、それを境に**左右に分割**する。ピボットの位置はその時点で確定する。 |
| **マージソート** | いったん**バラバラに分割**してから、**小さな部分列を整列・結合**していく。 |
| **シェルソート** | **間隔を空けて**大まかに整列し、徐々に間隔を狭めて精密化していく。 |
| **ヒープソート** | 全体から**最大値を取り出して末尾に配置**する、という操作を繰り返す。 |

### 2. 動作例から見抜く実践トレーニング

配列 `[5, 3, 4, 1, 2]` を用いて、各ソートの動きの違いを確認します。

- **バブルソートの例**: 隣同士の交換が繰り返され、1回目の走査で `5` が末尾に移動します。
  - `[5, 3, 4, 1, 2]` → `[3, 5, 4, 1, 2]` → `[3, 4, 5, 1, 2]` → `[3, 4, 1, 5, 2]` → `[3, 4, 1, 2, 5]`

- **挿入ソートの例**: 左側の整列済み部分が徐々に拡大していきます。
  - `[5]` | `[3, 4, 1, 2]` → `[3, 5]` | `[4, 1, 2]` → `[3, 4, 5]` | `[1, 2]` → `[1, 3, 4, 5]` | `[2]` → `[1, 2, 3, 4, 5]`

- **選択ソートの例**: 未整列部分の最小値を探し、先頭と交換することで、先頭から順に値が確定します。
  - 最小値 `1` と `5` を交換: `[1, 3, 4, 5, 2]`
  - 残りの最小値 `2` と `3` を交換: `[1, 2, 4, 5, 3]`
  - 残りの最小値 `3` と `4` を交換: `[1, 2, 3, 5, 4]`

- **クイックソートの例**: 基準値（例：5）を決め、その位置が確定します。
  - `[5, 3, 4, 1, 2]` を基準値 `5` で分割 → `[3, 4, 1, 2]` と `[5]` に分かれるイメージ。

- **マージソートの例**: まず分割が進み、その後で結合（マージ）しながら整列されます。
  - 分割: `[5, 3]` と `[4, 1, 2]` → `[5]`, `[3]` と `[4]`, `[1, 2]` など
  - 結合: `[3, 5]` と `[1, 2, 4]` → `[1, 2, 3, 4, 5]`

- **ヒープソートの例**: ヒープ化された後、最大値が取り出され末尾に配置されます。
  - ヒープ化: `[5, 3, 4, 1, 2]`
  - 最大値 `5` を末尾へ: `[2, 3, 4, 1 | 5]`
  - 再ヒープ化後、最大値 `4` を末尾へ: `[1, 3, 2 | 4, 5]`

---

## 知識の定着と確認

### 1. よくある誤解と正しい知識

- **クイックソート**: 「必ず最速」は誤り。**平均的に高速**ですが、最悪の場合はO(n²)となり遅くなる可能性があります。
- **マージソート**: 「常に速い」は少し不正確。**安定してO(n log n)の性能**を発揮しますが、追加のメモリ領域を消費する点がデメリットになることがあります。
- **シェルソート、ヒープソート**: これらは**安定ソートではない**ことを覚えておきましょう。

### 2. 一問一答

**Q1. マージソートの最悪計算量は？**
- A1. **O(n log n)**。分割と併合の処理はデータ順に依存しないため、最悪時も計算量は変わりません。

**Q2. 基準値の選び方が偏ると性能が大きく低下するアルゴリズムは？**
- A2. **クイックソート**。最悪計算量はO(n²)になります。

**Q3. シェルソートが改良のベースとしたアルゴリズムは？**
- A3. **挿入ソート**。離れた要素を先に並べることで、後半の入れ替え回数を減らしています。

**Q4. ヒープ（順序木）というデータ構造を利用して整列を行うアルゴリズムは？**
- A4. **ヒープソート**。最大（または最小）要素を効率よく取り出すために利用します。

**Q5. 代表的な安定ソートは？**
- A5. **マージソート**、**バブルソート**など。同じ値を持つ要素の相対的な順序が保持されます。