了解です。では、「外部キー制約」と「参照制約」を明確に区別しつつ、整合性制約の全体を応用情報技術者試験向けに網羅的に整理します。

---

１　全体像（テキスト図）

```
整合性制約（データの正しさを保証するルール）
│
├─ 主キー制約（PRIMARY KEY）
│   └─ 行を一意に識別する列を指定
│
├─ 外部キー制約（Foreign Key Constraint）
│   └─ 他表の主キーを参照する列を指定（列属性）
│
├─ 参照制約（Referential Constraint）
│   └─ 外部キーを通じて、参照先表の行存在を保証するルール
│
├─ 検査制約（CHECK）
│   └─ 列値に条件を課し、不正値を防止
└─ 表明（ASSERTION）
    └─ 複数表にまたがる条件を定義
```

---

１－１　定義（IPA準拠）と用語の由来

* **主キー制約（PRIMARY KEY Constraint）**

  * **定義:** 表内の行を一意に識別する列を指定する制約
  * **由来:** 英語 "Key"。行を識別する「鍵」の意味

* **外部キー制約（Foreign Key Constraint）**

  * **定義:** 他表の主キーを参照する列（属性）を設定する制約
  * **由来:** 英語 "Foreign Key"。外部のキーを参照する列

* **参照制約（Referential Constraint）**

  * **定義:** 外部キーを通じて、参照元列の値が必ず参照先表の主キーに存在することを保証する整合性ルール
  * **由来:** 英語 "Referential"。参照関係を保証する

* **検査制約（Check Constraint）**

  * **定義:** 列値に条件を課し、不正値を防ぐ制約

* **表明（Assertion）**

  * **定義:** 複数表にまたがる条件を定義する制約（CREATE ASSERTION）

---

１－２　技術の必要性（解決する具体的課題）

* 主キー制約 → データの重複防止
* 外部キー制約 → 他表の主キーを参照する列を定義
* 参照制約 → 外部キー値が参照先に存在するか保証（整合性保持）
* CHECK → 値の妥当性確保
* ASSERTION → 複数表の条件整合性確保

具体例：

* 同じ社員番号を複数登録 → 主キー制約で防ぐ
* 注文表の部署IDが存在しない部署を参照 → 外部キー＋参照制約で防ぐ
* 商品価格が負 → CHECK制約で防ぐ
* 全社員の合計給与 ≤ 部署予算 → ASSERTIONで保証

---

１－３　試験の着眼点（頻出領域と解答に必要な知識）

* **外部キー制約** = 列（属性）を定義する
* **参照制約** = 外部キー値の存在を参照先行で保証するルール
* **SQL指定例:**

```sql
FOREIGN KEY (顧客ID) REFERENCES 顧客(顧客ID)
```

* **CHECK制約** = 列値条件
* **ASSERTION** = 複数表条件（CREATE ASSERTION）

---

１－４　体系マップ（分類・関係・比較表）

| 種類     | 指定句例                     | 対象  | 効果/意味                  |
| ------ | ------------------------ | --- | ---------------------- |
| 主キー制約  | PRIMARY KEY(列名)          | 列・行 | 行を一意に識別                |
| 外部キー制約 | FOREIGN KEY(列名)          | 列   | 他表の主キーを参照する列           |
| 参照制約   | FOREIGN KEY + REFERENCES | 列・行 | 外部キー値が参照先表の行に存在することを保証 |
| 検査制約   | CHECK (列名 条件式)           | 列   | 値の妥当性を検査               |
| 表明     | CREATE ASSERTION 条件式     | 複数表 | 複数表にまたがる整合性を保証         |

---

１－５　代表例（正答例・誤答例）

* **正答例（外部キー＋参照制約）**

```sql
CREATE TABLE 注文 (
  注文番号 INT PRIMARY KEY,
  顧客ID INT,
  FOREIGN KEY (顧客ID) REFERENCES 顧客(顧客ID)
);
```

* **誤答例（参照制約なし）**

```sql
CREATE TABLE 注文 (
  注文番号 INT PRIMARY KEY,
  顧客ID INT
);
-- 顧客IDに存在しない値が入っても制約がない
```

---

１－６　よくある誤解と正しい知識

* 誤解1：「外部キー制約と参照制約は同じ」

  * 正：外部キー = 列、参照制約 = 外部キー値の整合性ルール
* 誤解2：「参照制約＝バックアップ」

  * 正：参照制約は整合性保証であり、バックアップとは無関係
* 誤解3：「CHECKと参照制約は同じ」

  * 正：CHECKは列値条件、参照制約は他表参照整合性

---

１－７　一問一答（5問：問題→回答→解説）

**問題1:** 外部キー制約で指定するのは何か。

* 回答：参照する列（属性）
* 解説：外部キーは列そのものを指定し、参照制約で整合性を保証する

**問題2:** 外部キーを通じて参照先の主キーに存在しない値を登録できるか。

* 回答：できない
* 解説：参照制約により、存在しない値は登録不可

**問題3:** 主キー制約で行の重複を防ぐにはどの句を使うか。

* 回答：PRIMARY KEY
* 解説：表内の行を一意に識別する列に設定

**問題4:** 複数表にまたがる条件を保証する制約は何か。

* 回答：ASSERTION
* 解説：CREATE ASSERTIONで指定し、複数表の条件整合性を確保

**問題5:** CHECK制約の目的は何か。

* 回答：列の値の妥当性を検査
* 解説：条件式を満たさない値の登録を防止

---

１－８　要約（3行以内）

* 外部キー = 他表の主キーを参照する列
* 参照制約 = 外部キー値が参照先行に存在することを保証
* 主キー、CHECK、ASSERTIONと合わせ、データ整合性を確保

---


